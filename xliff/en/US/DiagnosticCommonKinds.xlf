<?xml version='1.0' encoding='UTF-8'?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://docs.oasis-open.org/xliff/xliff-core/v2.1/os/schemas/xliff_core_2.0.xsd" trgLang="en-US">
  <!--This file is automatically generated. Do not update this file directly by hand! Use `update-xliff.py`.-->
  <file id="DiagnosticCommon" original="clang/Basic/DiagnosticCommonKinds.td">
    <group id="TextSubstitution">
      <unit id="duplicate_declspec">
        <segment>
          <source>duplicate '%0' declaration specifier</source>
          <target>duplicate '{$arg0}' declaration specifier</target>
        </segment>
      </unit>
      <unit id="select_constexpr_spec_kind">
        <segment>
          <source>%select{&lt;ERROR&gt;|constexpr|consteval|constinit}0</source>
          <target>{|.match {$arg0 :integer}
0 {{&lt;ERROR&gt;}}
1 {{constexpr|consteval|constinit}}| :format arg0=$arg0}</target>
        </segment>
      </unit>
    </group>
    <group id="Diagnostic">
      <unit id="err_aix_musttail_unsupported">
        <segment>
          <source>'musttail' attribute is not supported on AIX</source>
          <target>'musttail' attribute is not supported on AIX</target>
        </segment>
      </unit>
      <unit id="err_apinotes_message">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="err_asm_invalid_type">
        <segment>
          <source>invalid type %0 in asm %select{input|output}1</source>
          <target>invalid type {$arg0} in asm {|.match {$arg1 :integer}
0 {{input}}
1 {{output}}| :format arg1=$arg1}</target>
        </segment>
      </unit>
      <unit id="err_asm_invalid_type_in_input">
        <segment>
          <source>invalid type %0 in asm input for constraint '%1'</source>
          <target>invalid type {$arg0} in asm input for constraint '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="err_attribute_not_type_attr">
        <segment>
          <source>%0%select{ attribute|}1 cannot be applied to types</source>
          <target>{$arg0}{|.match {$arg1 :integer}
0 {{ attribute}}
1 {{}}| :format arg1=$arg1} cannot be applied to types</target>
        </segment>
      </unit>
      <unit id="err_attribute_uuid_malformed_guid">
        <segment>
          <source>uuid attribute contains a malformed GUID</source>
          <target>uuid attribute contains a malformed GUID</target>
        </segment>
      </unit>
      <unit id="err_cannot_open_file">
        <segment>
          <source>cannot open file '%0': %1</source>
          <target>cannot open file '{$arg0}': {$arg1}</target>
        </segment>
      </unit>
      <unit id="err_constexpr_invalid_template_arg">
        <segment>
          <source>%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument</source>
          <target>{|.match {$arg0 :integer}
0 {{pointer}}
1 {{reference}}| :format arg0=$arg0} to {|.match {$arg1 :integer}
0 {{}}
1 {{subobject of }}| :format arg1=$arg1}{|.match {$arg2 :integer}
0 {{type_info object}}
1 {{string literal|temporary object|predefined '{$arg3}' variable}}| :format arg2=$arg2 arg3=$arg3} is not allowed in a template argument</target>
        </segment>
      </unit>
      <unit id="err_cxx23_size_t_suffix">
        <segment>
          <source>'size_t' suffix for literals is a C++23 feature</source>
          <target>'size_t' suffix for literals is a C++23 feature</target>
        </segment>
      </unit>
      <unit id="err_default_special_members">
        <segment>
          <source>only special member functions %select{|and comparison operators }0may be defaulted</source>
          <target>only special member functions {|.match {$arg0 :integer}
0 {{}}
1 {{and comparison operators }}| :format arg0=$arg0}may be defaulted</target>
        </segment>
      </unit>
      <unit id="err_deleted_non_function">
        <segment>
          <source>only functions can have deleted definitions</source>
          <target>only functions can have deleted definitions</target>
        </segment>
      </unit>
      <unit id="err_duplicate_declspec">
        <segment>
          <source>%sub{duplicate_declspec}0</source>
          <target>{:format id=duplicate_declspec arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="err_enum_template">
        <segment>
          <source>enumeration cannot be a template</source>
          <target>enumeration cannot be a template</target>
        </segment>
      </unit>
      <unit id="err_expected">
        <segment>
          <source>expected %0</source>
          <target>expected {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_expected_after">
        <segment>
          <source>expected %1 after %0</source>
          <target>expected {$arg1} after {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_expected_colon_after_setter_name">
        <segment>
          <source>method name referenced in property setter attribute must end with ':'</source>
          <target>method name referenced in property setter attribute must end with ':'</target>
        </segment>
      </unit>
      <unit id="err_expected_either">
        <segment>
          <source>expected %0 or %1</source>
          <target>expected {$arg0} or {$arg1}</target>
        </segment>
      </unit>
      <unit id="err_expected_namespace_name">
        <segment>
          <source>expected namespace name</source>
          <target>expected namespace name</target>
        </segment>
      </unit>
      <unit id="err_expected_string_literal">
        <segment>
          <source>expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0</source>
          <target>expected string literal {|.match {$arg0 :integer}
0 {{in {$arg1}}}
1 {{for diagnostic message in static_assert|for optional message in 'availability' attribute|for {\|.match {$arg1 :integer}
0 {{language name}}
1 {{source container name|USR}}\| :format arg1=$arg1} in 'external_source_symbol' attribute|as argument of '{$arg1}' attribute}}| :format arg0=$arg0 arg1=$arg1 arg1=$arg1}</target>
        </segment>
      </unit>
      <unit id="err_file_modified">
        <segment>
          <source>file '%0' modified since it was first processed</source>
          <target>file '{$arg0}' modified since it was first processed</target>
        </segment>
      </unit>
      <unit id="err_file_too_large">
        <segment>
          <source>file '%0' is too large for Clang to process</source>
          <target>file '{$arg0}' is too large for Clang to process</target>
        </segment>
      </unit>
      <unit id="err_friend_decl_spec">
        <segment>
          <source>'%0' is invalid in friend declarations</source>
          <target>'{$arg0}' is invalid in friend declarations</target>
        </segment>
      </unit>
      <unit id="err_integer_literal_too_large">
        <segment>
          <source>integer literal is too large to be represented in any %select{signed |}0integer type</source>
          <target>integer literal is too large to be represented in any {|.match {$arg0 :integer}
0 {{signed }}
1 {{}}| :format arg0=$arg0}integer type</target>
        </segment>
      </unit>
      <unit id="err_invalid_character_udl">
        <segment>
          <source>character literal with user-defined suffix cannot be used here</source>
          <target>character literal with user-defined suffix cannot be used here</target>
        </segment>
      </unit>
      <unit id="err_invalid_feature_combination">
        <segment>
          <source>invalid feature combination: %0</source>
          <target>invalid feature combination: {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_invalid_member_in_interface">
        <segment>
          <source>%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type</source>
          <target>{|.match {$arg0 :integer}
0 {{data member }}
1 {{non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }}| :format arg0=$arg0}{$arg1} is not permitted within an interface type</target>
        </segment>
      </unit>
      <unit id="err_invalid_numeric_udl">
        <segment>
          <source>numeric literal with user-defined suffix cannot be used here</source>
          <target>numeric literal with user-defined suffix cannot be used here</target>
        </segment>
      </unit>
      <unit id="err_invalid_storage_class_in_func_decl">
        <segment>
          <source>invalid storage class specifier in function declarator</source>
          <target>invalid storage class specifier in function declarator</target>
        </segment>
      </unit>
      <unit id="err_invalid_string_udl">
        <segment>
          <source>string literal with user-defined suffix cannot be used here</source>
          <target>string literal with user-defined suffix cannot be used here</target>
        </segment>
      </unit>
      <unit id="err_keyword_not_supported_on_target">
        <segment>
          <source>%0 is not supported on this target</source>
          <target>{$arg0} is not supported on this target</target>
        </segment>
      </unit>
      <unit id="err_mips_fp64_req">
        <segment>
          <source>'%0' can only be used if the target supports the mfhc1 and mthc1 instructions</source>
          <target>'{$arg0}' can only be used if the target supports the mfhc1 and mthc1 instructions</target>
        </segment>
      </unit>
      <unit id="err_module_build_disabled">
        <segment>
          <source>module '%0' is needed but has not been provided, and implicit use of module files is disabled</source>
          <target>module '{$arg0}' is needed but has not been provided, and implicit use of module files is disabled</target>
        </segment>
      </unit>
      <unit id="err_module_build_shadowed_submodule">
        <segment>
          <source>build a shadowed submodule '%0'</source>
          <target>build a shadowed submodule '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_module_cycle">
        <segment>
          <source>cyclic dependency in module '%0': %1</source>
          <target>cyclic dependency in module '{$arg0}': {$arg1}</target>
        </segment>
      </unit>
      <unit id="err_module_format_unhandled">
        <segment>
          <source>no handler registered for module format '%0'</source>
          <target>no handler registered for module format '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_module_header_missing">
        <segment>
          <source>%select{|umbrella }0header '%1' not found</source>
          <target>{|.match {$arg0 :integer}
0 {{}}
1 {{umbrella }}| :format arg0=$arg0}header '{$arg1}' not found</target>
        </segment>
      </unit>
      <unit id="err_module_not_built">
        <segment>
          <source>could not build module '%0'</source>
          <target>could not build module '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_module_not_found">
        <segment>
          <source>module '%0' not found</source>
          <target>module '{$arg0}' not found</target>
        </segment>
      </unit>
      <unit id="err_module_prebuilt">
        <segment>
          <source>error in loading module '%0' from prebuilt module path</source>
          <target>error in loading module '{$arg0}' from prebuilt module path</target>
        </segment>
      </unit>
      <unit id="err_module_rebuild_finalized">
        <segment>
          <source>cannot rebuild module '%0' as it is already finalized</source>
          <target>cannot rebuild module '{$arg0}' as it is already finalized</target>
        </segment>
      </unit>
      <unit id="err_module_shadowed">
        <segment>
          <source>import of shadowed module '%0'</source>
          <target>import of shadowed module '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_module_unavailable">
        <segment>
          <source>module '%0' %select{is incompatible with|requires}1 feature '%2'</source>
          <target>module '{$arg0}' {|.match {$arg1 :integer}
0 {{is incompatible with}}
1 {{requires}}| :format arg1=$arg1} feature '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="err_ms_asm_bitfield_unsupported">
        <segment>
          <source>an inline asm block cannot have an operand which is a bit-field</source>
          <target>an inline asm block cannot have an operand which is a bit-field</target>
        </segment>
      </unit>
      <unit id="err_nullability_conflicting">
        <segment>
          <source>nullability specifier %0 conflicts with existing specifier %1</source>
          <target>nullability specifier {$arg0} conflicts with existing specifier {$arg1}</target>
        </segment>
      </unit>
      <unit id="err_omp_more_one_clause">
        <segment>
          <source>directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2</source>
          <target>directive '#pragma omp {$arg0}' cannot contain more than one '{$arg1}' clause{|.match {$arg2 :integer}
0 {{}}
1 {{ with '{$arg3}' name modifier| with 'source' dependence}}| :format arg2=$arg2 arg3=$arg3}</target>
        </segment>
      </unit>
      <unit id="err_omp_required_clause">
        <segment>
          <source>directive '#pragma omp %0' requires the '%1' clause</source>
          <target>directive '#pragma omp {$arg0}' requires the '{$arg1}' clause</target>
        </segment>
      </unit>
      <unit id="err_opencl_extension_and_feature_differs">
        <segment>
          <source>options %0 and %1 are set to different values</source>
          <target>options {$arg0} and {$arg1} are set to different values</target>
        </segment>
      </unit>
      <unit id="err_opencl_feature_requires">
        <segment>
          <source>feature %0 requires support of %1 feature</source>
          <target>feature {$arg0} requires support of {$arg1} feature</target>
        </segment>
      </unit>
      <unit id="err_opencl_unknown_type_specifier">
        <segment>
          <source>%0 does not support the '%1' %select{type qualifier|storage class specifier}2</source>
          <target>{$arg0} does not support the '{$arg1}' {|.match {$arg2 :integer}
0 {{type qualifier}}
1 {{storage class specifier}}| :format arg2=$arg2}</target>
        </segment>
      </unit>
      <unit id="err_openclcxx_not_supported">
        <segment>
          <source>'%0' is not supported in C++ for OpenCL</source>
          <target>'{$arg0}' is not supported in C++ for OpenCL</target>
        </segment>
      </unit>
      <unit id="err_opt_not_valid_on_target">
        <segment>
          <source>option '%0' cannot be specified on this target</source>
          <target>option '{$arg0}' cannot be specified on this target</target>
        </segment>
      </unit>
      <unit id="err_opt_not_valid_with_opt">
        <segment>
          <source>option '%0' cannot be specified with '%1'</source>
          <target>option '{$arg0}' cannot be specified with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="err_opt_not_valid_with_opt_on_target">
        <segment>
          <source>option '%0' cannot be specified with '%1' for the %2 sub-architecture</source>
          <target>option '{$arg0}' cannot be specified with '{$arg1}' for the {$arg2} sub-architecture</target>
        </segment>
      </unit>
      <unit id="err_opt_not_valid_without_opt">
        <segment>
          <source>option '%0' cannot be specified without '%1'</source>
          <target>option '{$arg0}' cannot be specified without '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="err_param_redefinition">
        <segment>
          <source>redefinition of parameter %0</source>
          <target>redefinition of parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_ppc_impossible_musttail">
        <segment>
          <source>'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0</source>
          <target>'musttail' attribute for this call is impossible because {|.match {$arg0 :integer}
0 {{long calls cannot be tail called on PPC}}
1 {{indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}}| :format arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="err_requires_positive_value">
        <segment>
          <source>%select{invalid value '%0'; must be positive|value '%0' is too large}1</source>
          <target>{|.match {$arg1 :integer}
0 {{invalid value '{$arg0}'; must be positive}}
1 {{value '{$arg0}' is too large}}| :format arg1=$arg1 arg0=$arg0 arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="err_seh___except_block">
        <segment>
          <source>%0 only allowed in __except block or filter expression</source>
          <target>{$arg0} only allowed in __except block or filter expression</target>
        </segment>
      </unit>
      <unit id="err_seh___except_filter">
        <segment>
          <source>%0 only allowed in __except filter expression</source>
          <target>{$arg0} only allowed in __except filter expression</target>
        </segment>
      </unit>
      <unit id="err_seh___finally_block">
        <segment>
          <source>%0 only allowed in __finally block</source>
          <target>{$arg0} only allowed in __finally block</target>
        </segment>
      </unit>
      <unit id="err_seh_expected_handler">
        <segment>
          <source>expected '__except' or '__finally' block</source>
          <target>expected '__except' or '__finally' block</target>
        </segment>
      </unit>
      <unit id="err_size_t_literal_too_large">
        <segment>
          <source>%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values</source>
          <target>{|.match {$arg0 :integer}
0 {{signed }}
1 {{}}| :format arg0=$arg0}'size_t' literal is out of range of possible {|.match {$arg0 :integer}
0 {{signed }}
1 {{}}| :format arg0=$arg0}'size_t' values</target>
        </segment>
      </unit>
      <unit id="err_sloc_space_too_large">
        <segment>
          <source>translation unit is too large for Clang to process: ran out of source locations</source>
          <target>translation unit is too large for Clang to process: ran out of source locations</target>
        </segment>
      </unit>
      <unit id="err_target_unknown_abi">
        <segment>
          <source>unknown target ABI '%0'</source>
          <target>unknown target ABI '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_target_unknown_cpu">
        <segment>
          <source>unknown target CPU '%0'</source>
          <target>unknown target CPU '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_target_unknown_fpmath">
        <segment>
          <source>unknown FP unit '%0'</source>
          <target>unknown FP unit '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_target_unknown_triple">
        <segment>
          <source>unknown target triple '%0'</source>
          <target>unknown target triple '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_abi">
        <segment>
          <source>ABI '%0' is not supported on CPU '%1'</source>
          <target>ABI '{$arg0}' is not supported on CPU '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_abi_for_triple">
        <segment>
          <source>ABI '%0' is not supported for '%1'</source>
          <target>ABI '{$arg0}' is not supported for '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_abi_with_fpu">
        <segment>
          <source>'%0' ABI is not supported with FPU</source>
          <target>'{$arg0}' ABI is not supported with FPU</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_cpu_for_micromips">
        <segment>
          <source>micromips is not supported for target CPU '%0'</source>
          <target>micromips is not supported for target CPU '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_execute_only">
        <segment>
          <source>execute only is not supported for the %0 sub-architecture</source>
          <target>execute only is not supported for the {$arg0} sub-architecture</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_fpmath">
        <segment>
          <source>the '%0' unit is not supported with this instruction set</source>
          <target>the '{$arg0}' unit is not supported with this instruction set</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_mcmse">
        <segment>
          <source>-mcmse is not supported for %0</source>
          <target>-mcmse is not supported for {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_tp_hard">
        <segment>
          <source>hardware TLS register is not supported for the %0 sub-architecture</source>
          <target>hardware TLS register is not supported for the {$arg0} sub-architecture</target>
        </segment>
      </unit>
      <unit id="err_target_unsupported_unaligned">
        <segment>
          <source>the %0 sub-architecture does not support unaligned accesses</source>
          <target>the {$arg0} sub-architecture does not support unaligned accesses</target>
        </segment>
      </unit>
      <unit id="err_too_large_for_fixed_point">
        <segment>
          <source>this value is too large for this fixed point type</source>
          <target>this value is too large for this fixed point type</target>
        </segment>
      </unit>
      <unit id="err_unable_to_make_temp">
        <segment>
          <source>unable to make temporary file: %0</source>
          <target>unable to make temporary file: {$arg0}</target>
        </segment>
      </unit>
      <unit id="err_unable_to_rename_temp">
        <segment>
          <source>unable to rename temporary '%0' to output file '%1': '%2'</source>
          <target>unable to rename temporary '{$arg0}' to output file '{$arg1}': '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="err_unimplemented_conversion_with_fixed_point_type">
        <segment>
          <source>conversion between fixed point and %0 is not yet supported</source>
          <target>conversion between fixed point and {$arg0} is not yet supported</target>
        </segment>
      </unit>
      <unit id="err_unknown_analyzer_checker_or_package">
        <segment>
          <source>no analyzer checkers or packages are associated with '%0'</source>
          <target>no analyzer checkers or packages are associated with '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="err_unsupported_abi_for_opt">
        <segment>
          <source>'%0' can only be used with the '%1' ABI</source>
          <target>'{$arg0}' can only be used with the '{$arg1}' ABI</target>
        </segment>
      </unit>
      <unit id="err_unsupported_bom">
        <segment>
          <source>%0 byte order mark detected in '%1', but encoding is not supported</source>
          <target>{$arg0} byte order mark detected in '{$arg1}', but encoding is not supported</target>
        </segment>
      </unit>
      <unit id="err_use_of_tag_name_without_tag">
        <segment>
          <source>must use '%1' tag to refer to type %0%select{| in this scope}2</source>
          <target>must use '{$arg1}' tag to refer to type {$arg0}{|.match {$arg2 :integer}
0 {{}}
1 {{ in this scope}}| :format arg2=$arg2}</target>
        </segment>
      </unit>
      <unit id="ext_c23_bitint_suffix">
        <segment>
          <source>'_BitInt' suffix for literals is a C23 extension</source>
          <target>'_BitInt' suffix for literals is a C23 extension</target>
        </segment>
      </unit>
      <unit id="ext_c99_longlong">
        <segment>
          <source>'long long' is an extension when C99 mode is not enabled</source>
          <target>'long long' is an extension when C99 mode is not enabled</target>
        </segment>
      </unit>
      <unit id="ext_c_empty_initializer">
        <segment>
          <source>use of an empty initializer is a C23 extension</source>
          <target>use of an empty initializer is a C23 extension</target>
        </segment>
      </unit>
      <unit id="ext_clang_diagnose_if">
        <segment>
          <source>'diagnose_if' is a clang extension</source>
          <target>'diagnose_if' is a clang extension</target>
        </segment>
      </unit>
      <unit id="ext_clang_enable_if">
        <segment>
          <source>'enable_if' is a clang extension</source>
          <target>'enable_if' is a clang extension</target>
        </segment>
      </unit>
      <unit id="ext_cxx11_longlong">
        <segment>
          <source>'long long' is a C++11 extension</source>
          <target>'long long' is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="ext_cxx23_size_t_suffix">
        <segment>
          <source>'size_t' suffix for literals is a C++23 extension</source>
          <target>'size_t' suffix for literals is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="ext_cxx_bitint_suffix">
        <segment>
          <source>'_BitInt' suffix for literals is a Clang extension</source>
          <target>'_BitInt' suffix for literals is a Clang extension</target>
        </segment>
      </unit>
      <unit id="ext_duplicate_declspec">
        <segment>
          <source>%sub{duplicate_declspec}0</source>
          <target>{:format id=duplicate_declspec arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="ext_integer_literal_too_large_for_signed">
        <segment>
          <source>integer literal is too large to be represented in a signed integer type, interpreting as unsigned</source>
          <target>integer literal is too large to be represented in a signed integer type, interpreting as unsigned</target>
        </segment>
      </unit>
      <unit id="ext_old_implicitly_unsigned_long_cxx">
        <segment>
          <source>integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards</source>
          <target>integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will {|.match {$arg0 :integer}
0 {{have type 'long long'}}
1 {{be ill-formed}}| :format arg0=$arg0} in C++11 onwards</target>
        </segment>
      </unit>
      <unit id="ext_variadic_templates">
        <segment>
          <source>variadic templates are a C++11 extension</source>
          <target>variadic templates are a C++11 extension</target>
        </segment>
      </unit>
      <unit id="ext_warn_duplicate_declspec">
        <segment>
          <source>%sub{duplicate_declspec}0</source>
          <target>{:format id=duplicate_declspec arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="fatal_too_many_errors">
        <segment>
          <source>too many errors emitted, stopping now</source>
          <target>too many errors emitted, stopping now</target>
        </segment>
      </unit>
      <unit id="note_also_found">
        <segment>
          <source>also found</source>
          <target>also found</target>
        </segment>
      </unit>
      <unit id="note_apinotes_message">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="note_constexpr_invalid_template_arg">
        <segment>
          <source>%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument</source>
          <target>{|.match {$arg0 :integer}
0 {{pointer}}
1 {{reference}}| :format arg0=$arg0} to {|.match {$arg1 :integer}
0 {{}}
1 {{subobject of }}| :format arg1=$arg1}{|.match {$arg2 :integer}
0 {{type_info object}}
1 {{string literal|temporary object|predefined '{$arg3}' variable}}| :format arg2=$arg2 arg3=$arg3} is not allowed in a template argument</target>
        </segment>
      </unit>
      <unit id="note_decl_hiding_tag_type">
        <segment>
          <source>%1 %0 is hidden by a non-type declaration of %0 here</source>
          <target>{$arg1} {$arg0} is hidden by a non-type declaration of {$arg0} here</target>
        </segment>
      </unit>
      <unit id="note_declared_at">
        <segment>
          <source>declared here</source>
          <target>declared here</target>
        </segment>
      </unit>
      <unit id="note_duplicate_case_prev">
        <segment>
          <source>previous case defined here</source>
          <target>previous case defined here</target>
        </segment>
      </unit>
      <unit id="note_file_misc_sloc_usage">
        <segment>
          <source>%0 additional files entered using a total of %1B (%human1B) of space</source>
          <target>{$arg0} additional files entered using a total of {$arg1}B ({$arg1 :human}B) of space</target>
        </segment>
      </unit>
      <unit id="note_file_sloc_usage">
        <segment>
          <source>file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2</source>
          <target>file entered {$arg0} time{|.match {$arg0 :integer}
1 {{}}
* {{s}}| :format arg0=$arg0} using {$arg1}B ({$arg1 :human}B) of space{|.match {$arg2 :range}
0 {{}}
* {{ plus {$arg2}B ({$arg2 :human}B) for macro expansions}}| :format arg2=$arg2 arg2=$arg2}</target>
        </segment>
      </unit>
      <unit id="note_forward_declaration">
        <segment>
          <source>forward declaration of %0</source>
          <target>forward declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="note_invalid_subexpr_in_const_expr">
        <segment>
          <source>subexpression not valid in a constant expression</source>
          <target>subexpression not valid in a constant expression</target>
        </segment>
      </unit>
      <unit id="note_matching">
        <segment>
          <source>to match this %0</source>
          <target>to match this {$arg0}</target>
        </segment>
      </unit>
      <unit id="note_possibility">
        <segment>
          <source>one possibility</source>
          <target>one possibility</target>
        </segment>
      </unit>
      <unit id="note_pragma_entered_here">
        <segment>
          <source>#pragma entered here</source>
          <target>#pragma entered here</target>
        </segment>
      </unit>
      <unit id="note_previous_declaration">
        <segment>
          <source>previous declaration is here</source>
          <target>previous declaration is here</target>
        </segment>
      </unit>
      <unit id="note_previous_definition">
        <segment>
          <source>previous definition is here</source>
          <target>previous definition is here</target>
        </segment>
      </unit>
      <unit id="note_previous_implicit_declaration">
        <segment>
          <source>previous implicit declaration is here</source>
          <target>previous implicit declaration is here</target>
        </segment>
      </unit>
      <unit id="note_previous_use">
        <segment>
          <source>previous use is here</source>
          <target>previous use is here</target>
        </segment>
      </unit>
      <unit id="note_suggest_disabling_all_checkers">
        <segment>
          <source>use -analyzer-disable-all-checks to disable all static analyzer checkers</source>
          <target>use -analyzer-disable-all-checks to disable all static analyzer checkers</target>
        </segment>
      </unit>
      <unit id="note_total_sloc_usage">
        <segment>
          <source>%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)</source>
          <target>{$arg0}B ({$arg0 :human}B) in local locations, {$arg1}B ({$arg1 :human}B) in locations loaded from AST files, for a total of {$arg2}B ({$arg2 :human}B) ({$arg3}% of available space)</target>
        </segment>
      </unit>
      <unit id="note_type_being_defined">
        <segment>
          <source>definition of %0 is not complete until the closing '}'</source>
          <target>definition of {$arg0} is not complete until the closing '}'</target>
        </segment>
      </unit>
      <unit id="note_using">
        <segment>
          <source>using</source>
          <target>using</target>
        </segment>
      </unit>
      <unit id="note_valid_options">
        <segment>
          <source>valid target CPU values are: %0</source>
          <target>valid target CPU values are: {$arg0}</target>
        </segment>
      </unit>
      <unit id="remark_module_lock_failure">
        <segment>
          <source>could not acquire lock file for module '%0': %1</source>
          <target>could not acquire lock file for module '{$arg0}': {$arg1}</target>
        </segment>
      </unit>
      <unit id="remark_module_lock_timeout">
        <segment>
          <source>timed out waiting to acquire lock file for module '%0'</source>
          <target>timed out waiting to acquire lock file for module '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="remark_sloc_usage">
        <segment>
          <source>source manager location address space usage:</source>
          <target>source manager location address space usage:</target>
        </segment>
      </unit>
      <unit id="warn_apinotes_message">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_apinotes_private_case">
        <segment>
          <source>private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'</source>
          <target>private API notes file for module '{$arg0}' should be named '{$arg0}_private.apinotes', not '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="warn_apinotes_private_case_system">
        <segment>
          <source>private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'</source>
          <target>private API notes file for module '{$arg0}' should be named '{$arg0}_private.apinotes', not '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="warn_attribute_ignored">
        <segment>
          <source>%0 attribute ignored</source>
          <target>{$arg0} attribute ignored</target>
        </segment>
      </unit>
      <unit id="warn_c23_compat_bitint_suffix">
        <segment>
          <source>'_BitInt' suffix for literals is incompatible with C standards before C23</source>
          <target>'_BitInt' suffix for literals is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="warn_c23_compat_empty_initializer">
        <segment>
          <source>use of an empty initializer is incompatible with C standards before C23</source>
          <target>use of an empty initializer is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="warn_conflicting_nullability_attr_overriding_param_types">
        <segment>
          <source>conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1</source>
          <target>conflicting nullability specifier on parameter types, {$arg0} conflicts with existing specifier {$arg1}</target>
        </segment>
      </unit>
      <unit id="warn_conflicting_nullability_attr_overriding_ret_types">
        <segment>
          <source>conflicting nullability specifier on return types, %0 conflicts with existing specifier %1</source>
          <target>conflicting nullability specifier on return types, {$arg0} conflicts with existing specifier {$arg1}</target>
        </segment>
      </unit>
      <unit id="warn_cxx20_compat_consteval">
        <segment>
          <source>'consteval' specifier is incompatible with C++ standards before C++20</source>
          <target>'consteval' specifier is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="warn_cxx20_compat_size_t_suffix">
        <segment>
          <source>'size_t' suffix for literals is incompatible with C++ standards before C++23</source>
          <target>'size_t' suffix for literals is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="warn_cxx98_compat_longlong">
        <segment>
          <source>'long long' is incompatible with C++98</source>
          <target>'long long' is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="warn_cxx98_compat_variadic_templates">
        <segment>
          <source>variadic templates are incompatible with C++98</source>
          <target>variadic templates are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="warn_dup_category_def">
        <segment>
          <source>duplicate definition of category %1 on interface %0</source>
          <target>duplicate definition of category {$arg1} on interface {$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_duplicate_declspec">
        <segment>
          <source>%sub{duplicate_declspec}0</source>
          <target>{:format id=duplicate_declspec arg0=$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_fp_nan_inf_when_disabled">
        <segment>
          <source>use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options</source>
          <target>use of {|.match {$arg0 :integer}
0 {{infinity}}
1 {{NaN}}| :format arg0=$arg0}{|.match {$arg1 :integer}
0 {{}}
1 {{ via a macro}}| :format arg1=$arg1} is undefined behavior due to the currently enabled floating-point options</target>
        </segment>
      </unit>
      <unit id="warn_ignored_hip_only_option">
        <segment>
          <source>'%0' is ignored since it is only supported for HIP</source>
          <target>'{$arg0}' is ignored since it is only supported for HIP</target>
        </segment>
      </unit>
      <unit id="warn_incompatible_branch_protection_option">
        <segment>
          <source>'-mbranch-protection=' option is incompatible with the '%0' architecture</source>
          <target>'-mbranch-protection=' option is incompatible with the '{$arg0}' architecture</target>
        </segment>
      </unit>
      <unit id="warn_invalid_feature_combination">
        <segment>
          <source>invalid feature combination: %0</source>
          <target>invalid feature combination: {$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_method_param_declaration">
        <segment>
          <source>redeclaration of method parameter %0</source>
          <target>redeclaration of method parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_method_param_redefinition">
        <segment>
          <source>redefinition of method parameter %0</source>
          <target>redefinition of method parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_missing_type_specifier">
        <segment>
          <source>type specifier missing, defaults to 'int'</source>
          <target>type specifier missing, defaults to 'int'</target>
        </segment>
      </unit>
      <unit id="warn_nullability_duplicate">
        <segment>
          <source>duplicate nullability specifier %0</source>
          <target>duplicate nullability specifier {$arg0}</target>
        </segment>
      </unit>
      <unit id="warn_old_implicitly_unsigned_long">
        <segment>
          <source>integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards</source>
          <target>integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will {|.match {$arg0 :integer}
0 {{have type 'long long'}}
1 {{be ill-formed}}| :format arg0=$arg0} in C99 onwards</target>
        </segment>
      </unit>
      <unit id="warn_old_implicitly_unsigned_long_cxx">
        <segment>
          <source>integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards</source>
          <target>integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will {|.match {$arg0 :integer}
0 {{have type 'long long'}}
1 {{be ill-formed}}| :format arg0=$arg0} in C++11 onwards</target>
        </segment>
      </unit>
      <unit id="warn_opencl_unsupported_core_feature">
        <segment>
          <source>%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target</source>
          <target>{$arg0} is a core feature in {|.match {$arg1 :integer}
0 {{OpenCL C}}
1 {{C++ for OpenCL}}| :format arg1=$arg1} version {$arg2} but not supported on this target</target>
        </segment>
      </unit>
      <unit id="warn_poison_system_directories">
        <segment>
          <source>include location '%0' is unsafe for cross-compilation</source>
          <target>include location '{$arg0}' is unsafe for cross-compilation</target>
        </segment>
      </unit>
      <unit id="warn_pragma_debug_missing_argument">
        <segment>
          <source>missing argument to debug command '%0'</source>
          <target>missing argument to debug command '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="warn_pragma_debug_unexpected_argument">
        <segment>
          <source>unexpected argument to debug command</source>
          <target>unexpected argument to debug command</target>
        </segment>
      </unit>
      <unit id="warn_slh_does_not_support_asm_goto">
        <segment>
          <source>speculative load hardening does not protect functions with asm goto</source>
          <target>speculative load hardening does not protect functions with asm goto</target>
        </segment>
      </unit>
      <unit id="warn_stack_clash_protection_inline_asm">
        <segment>
          <source>unable to protect inline asm that clobbers stack pointer against stack clash</source>
          <target>unable to protect inline asm that clobbers stack pointer against stack clash</target>
        </segment>
      </unit>
      <unit id="warn_stack_exhausted">
        <segment>
          <source>stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely</source>
          <target>stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely</target>
        </segment>
      </unit>
      <unit id="warn_target_unrecognized_env">
        <segment>
          <source>mismatch between architecture and environment in target triple '%0'; did you mean '%1'?</source>
          <target>mismatch between architecture and environment in target triple '{$arg0}'; did you mean '{$arg1}'?</target>
        </segment>
      </unit>
      <unit id="warn_target_unsupported_branch_protection_attribute">
        <segment>
          <source>ignoring the 'branch-protection' attribute because the '%0' architecture does not support it</source>
          <target>ignoring the 'branch-protection' attribute because the '{$arg0}' architecture does not support it</target>
        </segment>
      </unit>
      <unit id="warn_throw_not_valid_on_target">
        <segment>
          <source>target '%0' does not support exception handling; 'throw' is assumed to be never reached</source>
          <target>target '{$arg0}' does not support exception handling; 'throw' is assumed to be never reached</target>
        </segment>
      </unit>
      <unit id="warn_try_not_valid_on_target">
        <segment>
          <source>target '%0' does not support exception handling; 'catch' block is ignored</source>
          <target>target '{$arg0}' does not support exception handling; 'catch' block is ignored</target>
        </segment>
      </unit>
      <unit id="warn_unknown_attribute_ignored">
        <segment>
          <source>unknown attribute %0 ignored</source>
          <target>unknown attribute {$arg0} ignored</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>