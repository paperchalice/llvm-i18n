<?xml version='1.0' encoding='UTF-8'?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:2.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.2" srcLang="en-US" xsi:schemaLocation="https://docs.oasis-open.org/xliff/xliff-core/v2.2/schemas/xliff_core_2.2.xsd" trgLang="root">
  <file id="DiagnosticSema" original="clang/Basic/DiagnosticSemaKinds.inc">
    <notes>
      <note appliesTo="source">Automatically generated file, do not edit directly!</note>
    </notes>
    <group id="Sema">
      <unit id="2821" name="compat_cxx11_nonclass_type_friend">
        <segment>
          <source>non-class friend type %0 is incompatible with C++98</source>
          <target>non-class friend type {$arg0} is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="2822" name="compat_cxx11_static_data_member_in_union">
        <segment>
          <source>static data member %0 in union is incompatible with C++98</source>
          <target>static data member {$arg0} in union is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="2823" name="compat_cxx11_templ_default_in_function_templ">
        <segment>
          <source>default template arguments for a function template are incompatible with C++98</source>
          <target>default template arguments for a function template are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="2824" name="compat_cxx11_template_arg_extra_parens">
        <segment>
          <source>parentheses around address non-type template argument are incompatible with C++98</source>
          <target>parentheses around address non-type template argument are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="2825" name="compat_cxx11_typename_outside_of_template">
        <segment>
          <source>'typename' outside of a template is incompatible with C++98</source>
          <target>'typename' outside of a template is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="2826" name="compat_cxx14_constexpr_body_multiple_return">
        <segment>
          <source>multiple return statements in constexpr function is incompatible with C++ standards before C++14</source>
          <target>multiple return statements in constexpr function is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="2827" name="compat_cxx14_constexpr_local_var">
        <segment>
          <source>variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14</source>
          <target>variable declaration in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="2828" name="compat_cxx14_constexpr_type_definition">
        <segment>
          <source>type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14</source>
          <target>type definition in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="2829" name="compat_cxx14_cxx14_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="2830" name="compat_cxx14_variable_template">
        <segment>
          <source>variable templates are incompatible with C++ standards before C++14</source>
          <target>variable templates are incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="2831" name="compat_cxx17_decomp_decl">
        <segment>
          <source>decomposition declarations are incompatible with C++ standards before C++17</source>
          <target>decomposition declarations are incompatible with C++ standards before C++17</target>
        </segment>
      </unit>
      <unit id="2832" name="compat_cxx17_inline_variable">
        <segment>
          <source>inline variables are incompatible with C++ standards before C++17</source>
          <target>inline variables are incompatible with C++ standards before C++17</target>
        </segment>
      </unit>
      <unit id="2833" name="compat_cxx20_adl_only_template_id">
        <segment>
          <source>use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20</source>
          <target>use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2834" name="compat_cxx20_constexpr_ctor_missing_init">
        <segment>
          <source>constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20</source>
          <target>constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2835" name="compat_cxx20_constexpr_function_try_block">
        <segment>
          <source>function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20</source>
          <target>function try block in constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2836" name="compat_cxx20_constexpr_local_var_no_init">
        <segment>
          <source>uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20</source>
          <target>uninitialized variable in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2837" name="compat_cxx20_constexpr_union_ctor_no_init">
        <segment>
          <source>constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20</source>
          <target>constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2838" name="compat_cxx20_ctad_for_alias_templates">
        <segment>
          <source>class template argument deduction for alias templates is incompatible with C++ standards before C++20</source>
          <target>class template argument deduction for alias templates is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2839" name="compat_cxx20_cxx20_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2840" name="compat_cxx20_decomp_decl_spec">
        <segment>
          <source>decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20</source>
          <target>decomposition declaration declared %plural{1:'{$arg1}'|:with '{$arg1}' specifiers}0 is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2841" name="compat_cxx20_implicit_typename">
        <segment>
          <source>missing 'typename' prior to dependent type name %0 is incompatible with C++ standards before C++20</source>
          <target>missing 'typename' prior to dependent type name {$arg0} is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="2842" name="compat_cxx23_constexpr_static_var">
        <segment>
          <source>definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23</source>
          <target>definition of a {$arg1 :select s0=|static| s1=|thread_local|} variable in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="2843" name="compat_cxx23_cxx23_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="2844" name="compat_cxx26_decomp_decl_cond">
        <segment>
          <source>structured binding declaration in a condition is incompatible with C++ standards before C++2c</source>
          <target>structured binding declaration in a condition is incompatible with C++ standards before C++2c</target>
        </segment>
      </unit>
      <unit id="2845" name="compat_pre_cxx11_nonclass_type_friend">
        <segment>
          <source>non-class friend type %0 is a C++11 extension</source>
          <target>non-class friend type {$arg0} is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="2846" name="compat_pre_cxx11_static_data_member_in_union">
        <segment>
          <source>static data member %0 in union is a C++11 extension</source>
          <target>static data member {$arg0} in union is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="2847" name="compat_pre_cxx11_templ_default_in_function_templ">
        <segment>
          <source>default template arguments for a function template are a C++11 extension</source>
          <target>default template arguments for a function template are a C++11 extension</target>
        </segment>
      </unit>
      <unit id="2848" name="compat_pre_cxx11_template_arg_extra_parens">
        <segment>
          <source>parentheses around address non-type template argument are a C++11 extension</source>
          <target>parentheses around address non-type template argument are a C++11 extension</target>
        </segment>
      </unit>
      <unit id="2849" name="compat_pre_cxx11_typename_outside_of_template">
        <segment>
          <source>'typename' outside of a template is a C++11 extension</source>
          <target>'typename' outside of a template is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="2850" name="compat_pre_cxx14_constexpr_body_multiple_return">
        <segment>
          <source>multiple return statements in constexpr function is a C++14 extension</source>
          <target>multiple return statements in constexpr function is a C++14 extension</target>
        </segment>
      </unit>
      <unit id="2851" name="compat_pre_cxx14_constexpr_local_var">
        <segment>
          <source>variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension</source>
          <target>variable declaration in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++14 extension</target>
        </segment>
      </unit>
      <unit id="2852" name="compat_pre_cxx14_constexpr_type_definition">
        <segment>
          <source>type definition in a constexpr %select{function|constructor}0 is a C++14 extension</source>
          <target>type definition in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++14 extension</target>
        </segment>
      </unit>
      <unit id="2853" name="compat_pre_cxx14_cxx14_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++14 extension</target>
        </segment>
      </unit>
      <unit id="2854" name="compat_pre_cxx14_variable_template">
        <segment>
          <source>variable templates are a C++14 extension</source>
          <target>variable templates are a C++14 extension</target>
        </segment>
      </unit>
      <unit id="2855" name="compat_pre_cxx17_decomp_decl">
        <segment>
          <source>decomposition declarations are a C++17 extension</source>
          <target>decomposition declarations are a C++17 extension</target>
        </segment>
      </unit>
      <unit id="2856" name="compat_pre_cxx17_inline_variable">
        <segment>
          <source>inline variables are a C++17 extension</source>
          <target>inline variables are a C++17 extension</target>
        </segment>
      </unit>
      <unit id="2857" name="compat_pre_cxx20_adl_only_template_id">
        <segment>
          <source>use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension</source>
          <target>use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2858" name="compat_pre_cxx20_constexpr_ctor_missing_init">
        <segment>
          <source>constexpr constructor that does not initialize all members is a C++20 extension</source>
          <target>constexpr constructor that does not initialize all members is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2859" name="compat_pre_cxx20_constexpr_function_try_block">
        <segment>
          <source>function try block in constexpr %select{function|constructor}0 is a C++20 extension</source>
          <target>function try block in constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2860" name="compat_pre_cxx20_constexpr_local_var_no_init">
        <segment>
          <source>uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension</source>
          <target>uninitialized variable in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2861" name="compat_pre_cxx20_constexpr_union_ctor_no_init">
        <segment>
          <source>constexpr union constructor that does not initialize any member is a C++20 extension</source>
          <target>constexpr union constructor that does not initialize any member is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2862" name="compat_pre_cxx20_ctad_for_alias_templates">
        <segment>
          <source>class template argument deduction for alias templates is a C++20 extension</source>
          <target>class template argument deduction for alias templates is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2863" name="compat_pre_cxx20_cxx20_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2864" name="compat_pre_cxx20_decomp_decl_spec">
        <segment>
          <source>decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension</source>
          <target>decomposition declaration declared %plural{1:'{$arg1}'|:with '{$arg1}' specifiers}0 is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2865" name="compat_pre_cxx20_implicit_typename">
        <segment>
          <source>missing 'typename' prior to dependent type name %0 is a C++20 extension</source>
          <target>missing 'typename' prior to dependent type name {$arg0} is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="2866" name="compat_pre_cxx23_constexpr_static_var">
        <segment>
          <source>definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension</source>
          <target>definition of a {$arg1 :select s0=|static| s1=|thread_local|} variable in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="2867" name="compat_pre_cxx23_cxx23_constexpr_body_invalid_stmt">
        <segment>
          <source>use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension</source>
          <target>use of this statement in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="2868" name="compat_pre_cxx26_decomp_decl_cond">
        <segment>
          <source>structured binding declaration in a condition is a C++2c extension</source>
          <target>structured binding declaration in a condition is a C++2c extension</target>
        </segment>
      </unit>
      <unit id="2869" name="err_32_bit_builtin_64_bit_tgt">
        <segment>
          <source>this builtin is only available on 32-bit targets</source>
          <target>this builtin is only available on 32-bit targets</target>
        </segment>
      </unit>
      <unit id="2870" name="err_64_bit_builtin_32_bit_tgt">
        <segment>
          <source>this builtin is only available on 64-bit targets</source>
          <target>this builtin is only available on 64-bit targets</target>
        </segment>
      </unit>
      <unit id="2871" name="err_abi_tag_on_redeclaration">
        <segment>
          <source>cannot add 'abi_tag' attribute in a redeclaration</source>
          <target>cannot add 'abi_tag' attribute in a redeclaration</target>
        </segment>
      </unit>
      <unit id="2872" name="err_abstract_type_in_decl">
        <segment>
          <source>%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class</source>
          <target>{$arg0 :select s0=|return| s1=|parameter| s2=|variable| s3=|field| s4=|instance variable| s5=|synthesized instance variable|} type {$arg1} is an abstract class</target>
        </segment>
      </unit>
      <unit id="2873" name="err_acc_branch_in_out_compute_construct">
        <segment>
          <source state="initial">invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct</source>
          <target>invalid {$arg0 :select s0=|branch| s1=|return| s2=|throw|} {$arg1 :select s0=|out of| s1=|into|} OpenACC Compute/Combined Construct</target>
        </segment>
      </unit>
      <unit id="2874" name="err_acc_clause_after_device_type">
        <segment>
          <source state="initial">OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct</source>
          <target>OpenACC clause '{$arg0}' may not follow a '{$arg1}' clause in a '{$arg2}' construct</target>
        </segment>
      </unit>
      <unit id="2875" name="err_acc_clause_appertainment">
        <segment>
          <source>OpenACC '%1' clause is not valid on '%0' directive</source>
          <target>OpenACC '{$arg1}' clause is not valid on '{$arg0}' directive</target>
        </segment>
      </unit>
      <unit id="2876" name="err_acc_clause_cannot_combine">
        <segment>
          <source state="initial">OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct</source>
          <target>OpenACC clause '{$arg0}' may not appear on the same construct as a '{$arg1}' clause on a '{$arg2}' construct</target>
        </segment>
      </unit>
      <unit id="2877" name="err_acc_clause_conflicts_prev_dev_type">
        <segment>
          <source>OpenACC '%0' clause applies to 'device_type' '%1', which conflicts with previous '%0' clause</source>
          <target>OpenACC '{$arg0}' clause applies to 'device_type' '{$arg1}', which conflicts with previous '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="2878" name="err_acc_clause_in_clause_region">
        <segment>
          <source>loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2</source>
          <target>loop with a '{$arg0}' clause may not exist in the region of a '{$arg1}' clause{$arg2 :select s0=|| s1=| on a '{$arg3}' construct|}</target>
        </segment>
      </unit>
      <unit id="2879" name="err_acc_clause_multiple_loops">
        <segment>
          <source>more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause</source>
          <target>more than one for-loop in a loop associated with OpenACC '{$arg0}' construct with a '{$arg1}' clause</target>
        </segment>
      </unit>
      <unit id="2880" name="err_acc_clause_routine_cannot_combine_before_device_type">
        <segment>
          <source>OpenACC clause '%0' after 'device_type' clause on a 'routine' conflicts with the '%1' clause before the first 'device_type'</source>
          <target>OpenACC clause '{$arg0}' after 'device_type' clause on a 'routine' conflicts with the '{$arg1}' clause before the first 'device_type'</target>
        </segment>
      </unit>
      <unit id="2881" name="err_acc_clause_routine_cannot_combine_same_device_type">
        <segment>
          <source>OpenACC clause '%0' on a 'routine' directive conflicts with the '%1' clause applying to the same 'device_type'</source>
          <target>OpenACC clause '{$arg0}' on a 'routine' directive conflicts with the '{$arg1}' clause applying to the same 'device_type'</target>
        </segment>
      </unit>
      <unit id="2882" name="err_acc_clause_routine_one_of_in_region">
        <segment>
          <source>OpenACC 'routine' construct must have at least one 'gang', 'seq', 'vector', or 'worker' clause that applies to each 'device_type'</source>
          <target>OpenACC 'routine' construct must have at least one 'gang', 'seq', 'vector', or 'worker' clause that applies to each 'device_type'</target>
        </segment>
      </unit>
      <unit id="2883" name="err_acc_clause_since_last_device_type">
        <segment>
          <source>OpenACC '%0' clause cannot appear more than once%select{| in a 'device_type' region}2 on a '%1' directive</source>
          <target>OpenACC '{$arg0}' clause cannot appear more than once{$arg2 :select s0=|| s1=| in a 'device_type' region|} on a '{$arg1}' directive</target>
        </segment>
      </unit>
      <unit id="2884" name="err_acc_collapse_loop_count">
        <segment>
          <source>OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0</source>
          <target>OpenACC 'collapse' clause loop count must be a {$arg0 :select s0=|constant expression| s1=|positive integer value, evaluated to {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="2885" name="err_acc_construct_appertainment">
        <segment>
          <source>OpenACC construct '%0' cannot be used here; it can only be used in a statement context</source>
          <target>OpenACC construct '{$arg0}' cannot be used here; it can only be used in a statement context</target>
        </segment>
      </unit>
      <unit id="2886" name="err_acc_construct_one_clause_of">
        <segment>
          <source>OpenACC '%0' construct must have at least one %1 clause</source>
          <target>OpenACC '{$arg0}' construct must have at least one {$arg1} clause</target>
        </segment>
      </unit>
      <unit id="2887" name="err_acc_decl_for_routine">
        <segment>
          <source>expected function or lambda declaration for 'routine' construct</source>
          <target>expected function or lambda declaration for 'routine' construct</target>
        </segment>
      </unit>
      <unit id="2888" name="err_acc_declare_clause_at_global">
        <segment>
          <source>OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope</source>
          <target>OpenACC '{$arg0}' clause on a 'declare' directive is not allowed at global or namespace scope</target>
        </segment>
      </unit>
      <unit id="2889" name="err_acc_declare_extern">
        <segment>
          <source>'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive</source>
          <target>'extern' variable may not be referenced by '{$arg0}' clause on an OpenACC 'declare' directive</target>
        </segment>
      </unit>
      <unit id="2890" name="err_acc_declare_required_clauses">
        <segment>
          <source>no valid clauses specified in OpenACC 'declare' directive</source>
          <target>no valid clauses specified in OpenACC 'declare' directive</target>
        </segment>
      </unit>
      <unit id="2891" name="err_acc_declare_same_scope">
        <segment>
          <source>variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive</source>
          <target>variable appearing in '{$arg0}' clause of OpenACC 'declare' directive must be in the same scope as the directive</target>
        </segment>
      </unit>
      <unit id="2892" name="err_acc_device_type_multiple_archs">
        <segment>
          <source>OpenACC 'device_type' clause on a 'set' construct only permits one architecture</source>
          <target>OpenACC 'device_type' clause on a 'set' construct only permits one architecture</target>
        </segment>
      </unit>
      <unit id="2893" name="err_acc_duplicate_bind">
        <segment>
          <source>multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function</source>
          <target>multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function</target>
        </segment>
      </unit>
      <unit id="2894" name="err_acc_duplicate_clause_disallowed">
        <segment>
          <source>OpenACC '%1' clause cannot appear more than once on a '%0' directive</source>
          <target>OpenACC '{$arg1}' clause cannot appear more than once on a '{$arg0}' directive</target>
        </segment>
      </unit>
      <unit id="2895" name="err_acc_duplicate_unnamed_bind">
        <segment>
          <source>OpenACC 'bind' clause on a declaration must bind to the same name as previous 'bind' clauses</source>
          <target>OpenACC 'bind' clause on a declaration must bind to the same name as previous 'bind' clauses</target>
        </segment>
      </unit>
      <unit id="2896" name="err_acc_gang_dim_value">
        <segment>
          <source>argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0</source>
          <target>argument to 'gang' clause dimension must be {$arg0 :select s0=|a constant expression| s1=|1, 2, or 3: evaluated to {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="2897" name="err_acc_gang_multiple_elt">
        <segment>
          <source>OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument</source>
          <target>OpenACC 'gang' clause may have at most one {$arg0 :select s0=|unnamed or 'num'| s1=|'dim'| s2=|'static'|} argument</target>
        </segment>
      </unit>
      <unit id="2898" name="err_acc_gang_reduction_conflict">
        <segment>
          <source>%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0</source>
          <target>{$arg0 :select s0=|OpenACC 'gang' clause with a 'dim' value greater than 1| s1=|OpenACC 'reduction' clause|} cannot appear on the same '{$arg1}' construct as a {$arg0 :select s0=|'reduction' clause| s1=|'gang' clause with a 'dim' value greater than 1|}</target>
        </segment>
      </unit>
      <unit id="2899" name="err_acc_gang_reduction_numgangs_conflict">
        <segment>
          <source>OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument</source>
          <target>OpenACC '{$arg0}' clause cannot appear on the same '{$arg2}' construct as a '{$arg1}' clause {$arg3 :select s0=|inside a compute construct with a| s1=|and a|} 'num_gangs' clause with more than one argument</target>
        </segment>
      </unit>
      <unit id="2900" name="err_acc_insufficient_loops">
        <segment>
          <source>'%0' clause specifies a loop count greater than the number of available loops</source>
          <target>'{$arg0}' clause specifies a loop count greater than the number of available loops</target>
        </segment>
      </unit>
      <unit id="2901" name="err_acc_int_arg_invalid">
        <segment>
          <source>'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4</source>
          <target>'{$arg0}' argument on '{$arg1}' clause is not permitted on a{$arg2 :select s0=|| s1=|n orphaned|} '{$arg3}' construct{$arg4 :select s0=|| s1=| associated with a '{$arg5}' compute construct|}</target>
        </segment>
      </unit>
      <unit id="2902" name="err_acc_int_expr_explicit_conversion">
        <segment>
          <source state="initial">OpenACC integer expression requires explicit conversion from %0 to %1</source>
          <target>OpenACC integer expression requires explicit conversion from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="2903" name="err_acc_int_expr_incomplete_class_type">
        <segment>
          <source>OpenACC integer expression has incomplete class type %0</source>
          <target>OpenACC integer expression has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="2904" name="err_acc_int_expr_multiple_conversions">
        <segment>
          <source>multiple conversions from expression type %0 to an integral type</source>
          <target>multiple conversions from expression type {$arg0} to an integral type</target>
        </segment>
      </unit>
      <unit id="2905" name="err_acc_int_expr_requires_integer">
        <segment>
          <source>OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)</source>
          <target>OpenACC {$arg0 :select s0=|clause '{$arg1}'| s1=|directive '{$arg2}'| s2=|sub-array bound|} requires expression of integer type ({$arg3} invalid)</target>
        </segment>
      </unit>
      <unit id="2906" name="err_acc_intervening_code">
        <segment>
          <source>inner loops must be tightly nested inside a '%0' clause on a '%1' construct</source>
          <target>inner loops must be tightly nested inside a '{$arg0}' clause on a '{$arg1}' construct</target>
        </segment>
      </unit>
      <unit id="2907" name="err_acc_invalid_atomic">
        <segment>
          <source>statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid</source>
          <target>statement associated with OpenACC 'atomic{$arg0 :select s0=|| s1=| {$arg1}|}' directive is invalid</target>
        </segment>
      </unit>
      <unit id="2908" name="err_acc_invalid_default_type">
        <segment>
          <source>invalid value %0 in '%1' clause; valid values are %2</source>
          <target>invalid value {$arg0} in '{$arg1}' clause; valid values are {$arg2}</target>
        </segment>
      </unit>
      <unit id="2909" name="err_acc_invalid_in_loop">
        <segment>
          <source>%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause</source>
          <target>{$arg0 :select s0=|OpenACC '{$arg3}' construct| s1=|while loop| s2=|do loop|} cannot appear in intervening code of a '{$arg1}' with a '{$arg2}' clause</target>
        </segment>
      </unit>
      <unit id="2910" name="err_acc_invalid_modifier">
        <segment>
          <source>OpenACC '%0' modifier not valid on '%1' clause</source>
          <target>OpenACC '{$arg0}' modifier not valid on '{$arg1}' clause</target>
        </segment>
      </unit>
      <unit id="2911" name="err_acc_link_not_extern">
        <segment>
          <source>variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'</source>
          <target>variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'</target>
        </segment>
      </unit>
      <unit id="2912" name="err_acc_loop_not_for_loop">
        <segment>
          <source state="initial">OpenACC '%0' construct can only be applied to a 'for' loop</source>
          <target>OpenACC '{$arg0}' construct can only be applied to a 'for' loop</target>
        </segment>
      </unit>
      <unit id="2913" name="err_acc_loop_not_monotonic">
        <segment>
          <source>OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)</source>
          <target>OpenACC '{$arg0}' variable must monotonically increase or decrease ('++', '--', or compound assignment)</target>
        </segment>
      </unit>
      <unit id="2914" name="err_acc_loop_terminating_condition">
        <segment>
          <source>OpenACC '%0' construct must have a terminating condition</source>
          <target>OpenACC '{$arg0}' construct must have a terminating condition</target>
        </segment>
      </unit>
      <unit id="2915" name="err_acc_loop_variable">
        <segment>
          <source>OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')</source>
          <target>OpenACC '{$arg0}' construct must have initialization clause in canonical form ('var = init' or 'T var = init')</target>
        </segment>
      </unit>
      <unit id="2916" name="err_acc_loop_variable_type">
        <segment>
          <source>loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)</source>
          <target>loop variable of loop associated with an OpenACC '{$arg0}' construct must be of integer, pointer, or random-access-iterator type (is {$arg1})</target>
        </segment>
      </unit>
      <unit id="2917" name="err_acc_magic_static_in_routine">
        <segment>
          <source>function static variables are not permitted in functions to which an OpenACC 'routine' directive applies</source>
          <target>function static variables are not permitted in functions to which an OpenACC 'routine' directive applies</target>
        </segment>
      </unit>
      <unit id="2918" name="err_acc_multiple_references">
        <segment>
          <source>variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced</source>
          <target>variable referenced in '{$arg0}' clause of OpenACC 'declare' directive was already referenced</target>
        </segment>
      </unit>
      <unit id="2919" name="err_acc_not_a_var_ref">
        <segment>
          <source>OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member</source>
          <target>OpenACC variable is not a valid variable name, sub-array, array element,{$arg0 :select s0=|| s1=| member of a composite variable,|} or composite variable member</target>
        </segment>
      </unit>
      <unit id="2920" name="err_acc_not_a_var_ref_cache">
        <segment>
          <source>OpenACC variable in cache directive is not a valid sub-array or array element</source>
          <target>OpenACC variable in cache directive is not a valid sub-array or array element</target>
        </segment>
      </unit>
      <unit id="2921" name="err_acc_not_a_var_ref_use_device_declare">
        <segment>
          <source>OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name</source>
          <target>OpenACC variable {$arg0 :select s0=|in 'use_device' clause| s1=|on 'declare' construct|} is not a valid variable name or array name</target>
        </segment>
      </unit>
      <unit id="2922" name="err_acc_num_arg_conflict">
        <segment>
          <source>'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause</source>
          <target>'{$arg0}' argument to '{$arg1}' clause not allowed on a '{$arg2}' construct{$arg3 :select s0=|| s1=| associated with a '{$arg4}' construct|} that has a '{$arg5}' clause</target>
        </segment>
      </unit>
      <unit id="2923" name="err_acc_num_arg_conflict_reverse">
        <segment>
          <source>'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument</source>
          <target>'{$arg0}' clause not allowed on a 'kernels loop' construct that has a '{$arg1}' clause with a{$arg2 :select s0=|n| s1=| 'num'|} argument</target>
        </segment>
      </unit>
      <unit id="2924" name="err_acc_num_gangs_num_args">
        <segment>
          <source>%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0</source>
          <target>{$arg0 :select s0=|no| s1=|too many|} integer expression arguments provided to OpenACC 'num_gangs' {$arg0 :select s0=|| s1=|clause: '{$arg1}' directive expects maximum of {$arg2}, {$arg3} were provided|}</target>
        </segment>
      </unit>
      <unit id="2925" name="err_acc_reduction_composite_member_type">
        <segment>
          <source>OpenACC 'reduction' composite variable must not have non-scalar field</source>
          <target>OpenACC 'reduction' composite variable must not have non-scalar field</target>
        </segment>
      </unit>
      <unit id="2926" name="err_acc_reduction_composite_type">
        <segment>
          <source>OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0</source>
          <target>OpenACC 'reduction' variable must be a composite of scalar types; {$arg1} {$arg0 :select s0=|is not a class or struct| s1=|is incomplete| s2=|is not an aggregate|}</target>
        </segment>
      </unit>
      <unit id="2927" name="err_acc_reduction_num_gangs_conflict">
        <segment>
          <source state="initial">OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0</source>
          <target>OpenACC '{$arg1}' clause {$arg0 :select s0=|| s1=|with more than 1 argument |}may not appear on a '{$arg2}' construct with a '{$arg3}' clause{$arg0 :select s0=| with more than 1 argument| s1=||}</target>
        </segment>
      </unit>
      <unit id="2928" name="err_acc_reduction_type">
        <segment>
          <source>OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0</source>
          <target>OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;{$arg1 :select s0=|| s1=| sub-array base|} type is {$arg0}</target>
        </segment>
      </unit>
      <unit id="2929" name="err_acc_routine_not_func">
        <segment>
          <source>OpenACC routine name %0 does not name a function</source>
          <target>OpenACC routine name {$arg0} does not name a function</target>
        </segment>
      </unit>
      <unit id="2930" name="err_acc_routine_overload_set">
        <segment>
          <source>OpenACC routine name %0 names a set of overloads</source>
          <target>OpenACC routine name {$arg0} names a set of overloads</target>
        </segment>
      </unit>
      <unit id="2931" name="err_acc_size_expr_value">
        <segment>
          <source>OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0</source>
          <target>OpenACC 'tile' clause size expression must be {$arg0 :select s0=|an asterisk or a constant expression| s1=|positive integer value, evaluated to {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="2932" name="err_acc_subarray_base_plus_length_out_of_range">
        <segment>
          <source>OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2</source>
          <target>OpenACC sub-array specified range [{$arg0}:{$arg1}] would be out of the range of the subscripted array size of {$arg2}</target>
        </segment>
      </unit>
      <unit id="2933" name="err_acc_subarray_function_type">
        <segment>
          <source>OpenACC sub-array cannot be of function type %0</source>
          <target>OpenACC sub-array cannot be of function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="2934" name="err_acc_subarray_incomplete_type">
        <segment>
          <source>OpenACC sub-array base is of incomplete type %0</source>
          <target>OpenACC sub-array base is of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="2935" name="err_acc_subarray_negative">
        <segment>
          <source>OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1</source>
          <target>OpenACC sub-array {$arg0 :select s0=|lower bound| s1=|length|} evaluated to negative value {$arg1}</target>
        </segment>
      </unit>
      <unit id="2936" name="err_acc_subarray_no_length">
        <segment>
          <source>OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0</source>
          <target>OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is {$arg0 :select s0=|not an array| s1=|an array of unknown bound|}</target>
        </segment>
      </unit>
      <unit id="2937" name="err_acc_subarray_out_of_range">
        <segment>
          <source>OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2</source>
          <target>OpenACC sub-array {$arg0 :select s0=|lower bound| s1=|length|} evaluated to a value ({$arg1}) that would be out of the range of the subscripted array size of {$arg2}</target>
        </segment>
      </unit>
      <unit id="2938" name="err_acc_typecheck_subarray_value">
        <segment>
          <source>OpenACC sub-array subscripted value is not an array or pointer</source>
          <target>OpenACC sub-array subscripted value is not an array or pointer</target>
        </segment>
      </unit>
      <unit id="2939" name="err_acc_update_as_body">
        <segment>
          <source>OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0</source>
          <target>OpenACC 'update' construct may not appear in place of the statement following a{$arg0 :select s0=|n if statement| s1=| while statement| s2=| do statement| s3=| switch statement| s4=| label statement|}</target>
        </segment>
      </unit>
      <unit id="2940" name="err_acc_var_not_pointer_type">
        <segment>
          <source>expected pointer in '%0' clause, type is %1</source>
          <target>expected pointer in '{$arg0}' clause, type is {$arg1}</target>
        </segment>
      </unit>
      <unit id="2941" name="err_access">
        <segment>
          <source>%1 is a %select{private|protected}0 member of %3</source>
          <target>{$arg1} is a {$arg0 :select s0=|private| s1=|protected|} member of {$arg3}</target>
        </segment>
      </unit>
      <unit id="2942" name="err_access_base_ctor">
        <segment>
          <source>%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor</source>
          <target>{$arg0 :select s0=|base class| s1=|inherited virtual base class|} {$arg1} has {$arg3 :select s0=|private| s1=|protected|} {$arg2 :select s0=|default | s1=|copy | s2=|move | s3=|*ERROR* | s4=|*ERROR* | s5=|*ERROR*| s6=||}constructor</target>
        </segment>
      </unit>
      <unit id="2943" name="err_access_ctor">
        <segment>
          <source>calling a %select{private|protected}0 constructor of class %2</source>
          <target>calling a {$arg0 :select s0=|private| s1=|protected|} constructor of class {$arg2}</target>
        </segment>
      </unit>
      <unit id="2944" name="err_access_decl">
        <segment>
          <source>ISO C++11 does not allow access declarations; use using declarations instead</source>
          <target>ISO C++11 does not allow access declarations; use using declarations instead</target>
        </segment>
      </unit>
      <unit id="2945" name="err_access_dtor">
        <segment>
          <source>calling a %select{private|protected}1 destructor of class %0</source>
          <target>calling a {$arg1 :select s0=|private| s1=|protected|} destructor of class {$arg0}</target>
        </segment>
      </unit>
      <unit id="2946" name="err_access_dtor_base">
        <segment>
          <source>base class %0 has %select{private|protected}1 destructor</source>
          <target>base class {$arg0} has {$arg1 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2947" name="err_access_dtor_exception">
        <segment>
          <source>exception object of type %0 has %select{private|protected}1 destructor</source>
          <target>exception object of type {$arg0} has {$arg1 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2948" name="err_access_dtor_field">
        <segment>
          <source>field of type %1 has %select{private|protected}2 destructor</source>
          <target>field of type {$arg1} has {$arg2 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2949" name="err_access_dtor_ivar">
        <segment>
          <source>instance variable of type %0 has %select{private|protected}1 destructor</source>
          <target>instance variable of type {$arg0} has {$arg1 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2950" name="err_access_dtor_temp">
        <segment>
          <source>temporary of type %0 has %select{private|protected}1 destructor</source>
          <target>temporary of type {$arg0} has {$arg1 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2951" name="err_access_dtor_var">
        <segment>
          <source>variable of type %1 has %select{private|protected}2 destructor</source>
          <target>variable of type {$arg1} has {$arg2 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2952" name="err_access_dtor_vbase">
        <segment>
          <source>inherited virtual base class %1 has %select{private|protected}2 destructor</source>
          <target>inherited virtual base class {$arg1} has {$arg2 :select s0=|private| s1=|protected|} destructor</target>
        </segment>
      </unit>
      <unit id="2953" name="err_access_field_ctor">
        <segment>
          <source>field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor</source>
          <target>field of type {$arg0} has {$arg2 :select s0=|private| s1=|protected|} {$arg1 :select s0=|default | s1=|copy | s2=|move | s3=|*ERROR* | s4=|*ERROR* | s5=|*ERROR* | s6=||}constructor</target>
        </segment>
      </unit>
      <unit id="2954" name="err_access_friend_function">
        <segment>
          <source>friend function %1 is a %select{private|protected}0 member of %3</source>
          <target>friend function {$arg1} is a {$arg0 :select s0=|private| s1=|protected|} member of {$arg3}</target>
        </segment>
      </unit>
      <unit id="2955" name="err_access_lambda_capture">
        <segment>
          <source>capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor</source>
          <target>capture of variable '{$arg0}' as type {$arg1} calls {$arg3 :select s0=|private| s1=|protected|} {$arg2 :select s0=|default | s1=|copy | s2=|move | s3=|*ERROR* | s4=|*ERROR* | s5=|*ERROR* | s6=||}constructor</target>
        </segment>
      </unit>
      <unit id="2956" name="err_addr_ovl_ambiguous">
        <segment>
          <source>address of overloaded function %0 is ambiguous</source>
          <target>address of overloaded function {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="2957" name="err_addr_ovl_no_qualifier">
        <segment>
          <source>cannot form member pointer of type %0 without '&amp;' and class name</source>
          <target>cannot form member pointer of type {$arg0} without '&amp;' and class name</target>
        </segment>
      </unit>
      <unit id="2958" name="err_addr_ovl_no_viable">
        <segment>
          <source>address of overloaded function %0 does not match required type %1</source>
          <target>address of overloaded function {$arg0} does not match required type {$arg1}</target>
        </segment>
      </unit>
      <unit id="2959" name="err_addr_ovl_not_func_ptrref">
        <segment>
          <source>address of overloaded function %0 cannot be converted to type %1</source>
          <target>address of overloaded function {$arg0} cannot be converted to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="2960" name="err_address_of_function_with_pass_object_size_params">
        <segment>
          <source>cannot take address of function %0 because parameter %1 has pass_object_size attribute</source>
          <target>cannot take address of function {$arg0} because parameter {$arg1} has pass_object_size attribute</target>
        </segment>
      </unit>
      <unit id="2961" name="err_address_space_mismatch_templ_inst">
        <segment>
          <source>conflicting address space qualifiers are provided between types %0 and %1</source>
          <target>conflicting address space qualifiers are provided between types {$arg0} and {$arg1}</target>
        </segment>
      </unit>
      <unit id="2962" name="err_address_space_qualified_delete">
        <segment>
          <source>'delete' cannot delete objects of type %0 in address space '%1'</source>
          <target>'delete' cannot delete objects of type {$arg0} in address space '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="2963" name="err_address_space_qualified_new">
        <segment>
          <source>'new' cannot allocate objects of type %0 in address space '%1'</source>
          <target>'new' cannot allocate objects of type {$arg0} in address space '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="2964" name="err_addrof_function_constraints_not_satisfied">
        <segment>
          <source>cannot take address of function %0 because its constraints are not satisfied</source>
          <target>cannot take address of function {$arg0} because its constraints are not satisfied</target>
        </segment>
      </unit>
      <unit id="2965" name="err_addrof_function_disabled_by_enable_if_attr">
        <segment>
          <source>cannot take address of function %0 because it has one or more non-tautological enable_if conditions</source>
          <target>cannot take address of function {$arg0} because it has one or more non-tautological enable_if conditions</target>
        </segment>
      </unit>
      <unit id="2966" name="err_aix_attr_unsupported">
        <segment>
          <source>%0 attribute is not yet supported on AIX</source>
          <target>{$arg0} attribute is not yet supported on AIX</target>
        </segment>
      </unit>
      <unit id="2967" name="err_alias_after_tentative">
        <segment>
          <source>alias definition of %0 after tentative definition</source>
          <target>alias definition of {$arg0} after tentative definition</target>
        </segment>
      </unit>
      <unit id="2968" name="err_alias_is_definition">
        <segment>
          <source>definition %0 cannot also be an %select{alias|ifunc}1</source>
          <target>definition {$arg0} cannot also be an {$arg1 :select s0=|alias| s1=|ifunc|}</target>
        </segment>
      </unit>
      <unit id="2969" name="err_alias_not_supported_on_darwin">
        <segment>
          <source>aliases are not supported on darwin</source>
          <target>aliases are not supported on darwin</target>
        </segment>
      </unit>
      <unit id="2970" name="err_alias_not_supported_on_nvptx">
        <segment>
          <source>CUDA older than 10.0 does not support .alias</source>
          <target>CUDA older than 10.0 does not support .alias</target>
        </segment>
      </unit>
      <unit id="2971" name="err_alias_template_extra_headers">
        <segment>
          <source>extraneous template parameter list in alias template declaration</source>
          <target>extraneous template parameter list in alias template declaration</target>
        </segment>
      </unit>
      <unit id="2972" name="err_align_value_attribute_argument_not_int">
        <segment>
          <source>'align_value' attribute requires integer constant</source>
          <target>'align_value' attribute requires integer constant</target>
        </segment>
      </unit>
      <unit id="2973" name="err_alignas_attribute_wrong_decl_type">
        <segment>
          <source>%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1</source>
          <target>{$arg0} attribute cannot be applied to {$arg1 :select s0=|a function parameter| s1=|a variable with 'register' storage class| s2=|a 'catch' variable| s3=|a bit-field| s4=|an enumeration|}</target>
        </segment>
      </unit>
      <unit id="2974" name="err_alignas_mismatch">
        <segment>
          <source>redeclaration has different alignment requirement (%1 vs %0)</source>
          <target>redeclaration has different alignment requirement ({$arg1} vs {$arg0})</target>
        </segment>
      </unit>
      <unit id="2975" name="err_alignas_missing_on_definition">
        <segment>
          <source>%0 must be specified on definition if it is specified on any declaration</source>
          <target>{$arg0} must be specified on definition if it is specified on any declaration</target>
        </segment>
      </unit>
      <unit id="2976" name="err_alignas_underaligned">
        <segment>
          <source>requested alignment is less than minimum alignment of %1 for type %0</source>
          <target>requested alignment is less than minimum alignment of {$arg1} for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="2977" name="err_aligned_allocation_unavailable">
        <segment>
          <source>aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4</source>
          <target>aligned {$arg0 :select s0=|allocation| s1=|deallocation|} function of type '{$arg1}' is {$arg4 :select s0=|only| s1=|not|} available on {$arg2}{$arg4 :select s0=| {$arg3} or newer| s1=||}</target>
        </segment>
      </unit>
      <unit id="2978" name="err_aligned_attribute_argument_not_int">
        <segment>
          <source>'aligned' attribute requires integer constant</source>
          <target>'aligned' attribute requires integer constant</target>
        </segment>
      </unit>
      <unit id="2979" name="err_alignment_dependent_typedef_name">
        <segment>
          <source>requested alignment is dependent but declaration is not dependent</source>
          <target>requested alignment is dependent but declaration is not dependent</target>
        </segment>
      </unit>
      <unit id="2980" name="err_alignment_not_power_of_two">
        <segment>
          <source>requested alignment is not a power of 2</source>
          <target>requested alignment is not a power of 2</target>
        </segment>
      </unit>
      <unit id="2981" name="err_alignment_too_big">
        <segment>
          <source>requested alignment must be %0 or smaller</source>
          <target>requested alignment must be {$arg0} or smaller</target>
        </segment>
      </unit>
      <unit id="2982" name="err_alignment_too_small">
        <segment>
          <source>requested alignment must be %0 or greater</source>
          <target>requested alignment must be {$arg0} or greater</target>
        </segment>
      </unit>
      <unit id="2983" name="err_alignof_member_of_incomplete_type">
        <segment>
          <source>invalid application of 'alignof' to a field of a class still being defined</source>
          <target>invalid application of 'alignof' to a field of a class still being defined</target>
        </segment>
      </unit>
      <unit id="2984" name="err_allocation_of_abstract_type">
        <segment>
          <source>allocating an object of abstract class type %0</source>
          <target>allocating an object of abstract class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="2985" name="err_altivec_empty_initializer">
        <segment>
          <source>expected initializer</source>
          <target>expected initializer</target>
        </segment>
      </unit>
      <unit id="2986" name="err_ambiguous_base_to_derived_cast">
        <segment>
          <source>ambiguous cast from base %0 to derived %1:%2</source>
          <target>ambiguous cast from base {$arg0} to derived {$arg1}:{$arg2}</target>
        </segment>
      </unit>
      <unit id="2987" name="err_ambiguous_delete_operand">
        <segment>
          <source>ambiguous conversion of delete expression of type %0 to a pointer</source>
          <target>ambiguous conversion of delete expression of type {$arg0} to a pointer</target>
        </segment>
      </unit>
      <unit id="2988" name="err_ambiguous_derived_to_base_conv">
        <segment>
          <source>ambiguous conversion from derived class %0 to base class %1:%2</source>
          <target>ambiguous conversion from derived class {$arg0} to base class {$arg1}:{$arg2}</target>
        </segment>
      </unit>
      <unit id="2989" name="err_ambiguous_destructor">
        <segment>
          <source>destructor of class %0 is ambiguous</source>
          <target>destructor of class {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="2990" name="err_ambiguous_inherited_constructor">
        <segment>
          <source>constructor of %0 inherited from multiple base class subobjects</source>
          <target>constructor of {$arg0} inherited from multiple base class subobjects</target>
        </segment>
      </unit>
      <unit id="2991" name="err_ambiguous_member_multiple_subobject_types">
        <segment>
          <source>member %0 found in multiple base classes of different types</source>
          <target>member {$arg0} found in multiple base classes of different types</target>
        </segment>
      </unit>
      <unit id="2992" name="err_ambiguous_member_multiple_subobjects">
        <segment>
          <source>non-static member %0 found in multiple base-class subobjects of type %1:%2</source>
          <target>non-static member {$arg0} found in multiple base-class subobjects of type {$arg1}:{$arg2}</target>
        </segment>
      </unit>
      <unit id="2993" name="err_ambiguous_memptr_conv">
        <segment>
          <source>ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3</source>
          <target>ambiguous conversion from pointer to member of {$arg0 :select s0=|base| s1=|derived|} class {$arg1} to pointer to member of {$arg0 :select s0=|derived| s1=|base|} class {$arg2}:{$arg3}</target>
        </segment>
      </unit>
      <unit id="2994" name="err_ambiguous_reference">
        <segment>
          <source>reference to %0 is ambiguous</source>
          <target>reference to {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="2995" name="err_ambiguous_suitable_delete_member_function_found">
        <segment>
          <source>multiple suitable %0 functions in %1</source>
          <target>multiple suitable {$arg0} functions in {$arg1}</target>
        </segment>
      </unit>
      <unit id="2996" name="err_ambiguous_tag_hiding">
        <segment>
          <source>a type named %0 is hidden by a declaration in a different namespace</source>
          <target>a type named {$arg0} is hidden by a declaration in a different namespace</target>
        </segment>
      </unit>
      <unit id="2997" name="err_amdgcn_load_lds_size_invalid_value">
        <segment>
          <source>invalid size value</source>
          <target>invalid size value</target>
        </segment>
      </unit>
      <unit id="2998" name="err_anon_bitfield_has_negative_width">
        <segment>
          <source>anonymous bit-field has negative width (%0)</source>
          <target>anonymous bit-field has negative width ({$arg0})</target>
        </segment>
      </unit>
      <unit id="2999" name="err_anon_bitfield_qualifiers">
        <segment>
          <source>anonymous bit-field cannot have qualifiers</source>
          <target>anonymous bit-field cannot have qualifiers</target>
        </segment>
      </unit>
      <unit id="3000" name="err_anonymous_property">
        <segment>
          <source>anonymous property is not supported</source>
          <target>anonymous property is not supported</target>
        </segment>
      </unit>
      <unit id="3001" name="err_anonymous_record_bad_member">
        <segment>
          <source>anonymous %select{struct|union}0 can only contain non-static data members</source>
          <target>anonymous {$arg0 :select s0=|struct| s1=|union|} can only contain non-static data members</target>
        </segment>
      </unit>
      <unit id="3002" name="err_anonymous_record_member_redecl">
        <segment>
          <source>member of anonymous %select{struct|union}0 redeclares %1</source>
          <target>member of anonymous {$arg0 :select s0=|struct| s1=|union|} redeclares {$arg1}</target>
        </segment>
      </unit>
      <unit id="3003" name="err_anonymous_record_nonpublic_member">
        <segment>
          <source>anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member</source>
          <target>anonymous {$arg0 :select s0=|struct| s1=|union|} cannot contain a {$arg1 :select s0=|private| s1=|protected|} data member</target>
        </segment>
      </unit>
      <unit id="3004" name="err_anonymous_record_with_function">
        <segment>
          <source>functions cannot be declared in an anonymous %select{struct|union}0</source>
          <target>functions cannot be declared in an anonymous {$arg0 :select s0=|struct| s1=|union|}</target>
        </segment>
      </unit>
      <unit id="3005" name="err_anonymous_record_with_static">
        <segment>
          <source>static members cannot be declared in an anonymous %select{struct|union}0</source>
          <target>static members cannot be declared in an anonymous {$arg0 :select s0=|struct| s1=|union|}</target>
        </segment>
      </unit>
      <unit id="3006" name="err_anonymous_record_with_type">
        <segment>
          <source>types cannot be declared in an anonymous %select{struct|union}0</source>
          <target>types cannot be declared in an anonymous {$arg0 :select s0=|struct| s1=|union|}</target>
        </segment>
      </unit>
      <unit id="3007" name="err_anonymous_struct_not_member">
        <segment>
          <source>anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members</source>
          <target>anonymous {$arg0 :select s0=|structs| s1=|structs and classes|} must be {$arg0 :select s0=|struct or union| s1=|class|} members</target>
        </segment>
      </unit>
      <unit id="3008" name="err_anonymous_union_not_static">
        <segment>
          <source>anonymous unions at namespace or global scope must be declared 'static'</source>
          <target>anonymous unions at namespace or global scope must be declared 'static'</target>
        </segment>
      </unit>
      <unit id="3009" name="err_anonymous_union_with_storage_spec">
        <segment>
          <source>anonymous union at class scope must not have a storage specifier</source>
          <target>anonymous union at class scope must not have a storage specifier</target>
        </segment>
      </unit>
      <unit id="3010" name="err_anyx86_interrupt_attribute">
        <segment>
          <source>%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1</source>
          <target>{$arg0 :select s0=|x86| s1=|x86-64|} 'interrupt' attribute only applies to functions that have {$arg1 :select s0=|a 'void' return type| s1=|only a pointer parameter optionally followed by an integer parameter| s2=|a pointer as the first parameter| s3=|a {$arg2} type as the second parameter|}</target>
        </segment>
      </unit>
      <unit id="3011" name="err_anyx86_interrupt_called">
        <segment>
          <source>interrupt service routine cannot be called directly</source>
          <target>interrupt service routine cannot be called directly</target>
        </segment>
      </unit>
      <unit id="3012" name="err_arc_array_param_no_ownership">
        <segment>
          <source>must explicitly describe intended ownership of an object array parameter</source>
          <target>must explicitly describe intended ownership of an object array parameter</target>
        </segment>
      </unit>
      <unit id="3013" name="err_arc_assign_property_ownership">
        <segment>
          <source>existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained</source>
          <target>existing instance variable {$arg1} for property {$arg0} with {$arg2 :select s0=|unsafe_unretained| s1=|assign|} attribute must be __unsafe_unretained</target>
        </segment>
      </unit>
      <unit id="3014" name="err_arc_atomic_ownership">
        <segment>
          <source>cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership</source>
          <target>cannot perform atomic operation on a pointer to type {$arg0}: type has non-trivial ownership</target>
        </segment>
      </unit>
      <unit id="3015" name="err_arc_autoreleasing_capture">
        <segment>
          <source>cannot capture __autoreleasing variable in a %select{block|lambda by copy}0</source>
          <target>cannot capture __autoreleasing variable in a {$arg0 :select s0=|block| s1=|lambda by copy|}</target>
        </segment>
      </unit>
      <unit id="3016" name="err_arc_autoreleasing_var">
        <segment>
          <source>%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership</source>
          <target>{$arg0 :select s0=|__block variables| s1=|global variables| s2=|fields| s3=|instance variables|} cannot have __autoreleasing ownership</target>
        </segment>
      </unit>
      <unit id="3017" name="err_arc_bridge_cast_incompatible">
        <segment>
          <source>incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast</source>
          <target>incompatible types casting {$arg0} to {$arg1} with a {$arg2 :select s0=|__bridge| s1=|__bridge_transfer| s2=|__bridge_retained|} cast</target>
        </segment>
      </unit>
      <unit id="3018" name="err_arc_bridge_cast_wrong_kind">
        <segment>
          <source>cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4</source>
          <target>cast of {$arg0 :select s0=|Objective-C| s1=|block| s2=|C|} pointer type {$arg1} to {$arg2 :select s0=|Objective-C| s1=|block| s2=|C|} pointer type {$arg3} cannot use {$arg4 :select s0=|__bridge| s1=|__bridge_transfer| s2=|__bridge_retained|}</target>
        </segment>
      </unit>
      <unit id="3019" name="err_arc_cast_requires_bridge">
        <segment>
          <source>%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast</source>
          <target>{$arg0 :select s0=|cast| s1=|implicit conversion|} of {$arg1 :select s0=|Objective-C| s1=|block| s2=|C|} pointer type {$arg2} to {$arg3 :select s0=|Objective-C| s1=|block| s2=|C|} pointer type {$arg4} requires a bridged cast</target>
        </segment>
      </unit>
      <unit id="3020" name="err_arc_collection_forward">
        <segment>
          <source>collection expression type %0 is a forward declaration</source>
          <target>collection expression type {$arg0} is a forward declaration</target>
        </segment>
      </unit>
      <unit id="3021" name="err_arc_convesion_of_weak_unavailable">
        <segment>
          <source>%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2</source>
          <target>{$arg0 :select s0=|implicit conversion| s1=|cast|} of weak-unavailable object of type {$arg1} to a __weak object of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3022" name="err_arc_gained_method_convention">
        <segment>
          <source>method implementation does not match its declaration</source>
          <target>method implementation does not match its declaration</target>
        </segment>
      </unit>
      <unit id="3023" name="err_arc_illegal_explicit_message">
        <segment>
          <source>ARC forbids explicit message send of %0</source>
          <target>ARC forbids explicit message send of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3024" name="err_arc_illegal_method_def">
        <segment>
          <source>ARC forbids %select{implementation|synthesis}0 of %1</source>
          <target>ARC forbids {$arg0 :select s0=|implementation| s1=|synthesis|} of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3025" name="err_arc_illegal_selector">
        <segment>
          <source>ARC forbids use of %0 in a @selector</source>
          <target>ARC forbids use of {$arg0} in a @selector</target>
        </segment>
      </unit>
      <unit id="3026" name="err_arc_inconsistent_property_ownership">
        <segment>
          <source>%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2</source>
          <target>{$arg1 :select s0=|| s1=|unsafe_unretained| s2=|strong| s3=|weak|} property {$arg0} may not also be declared {$arg2 :select s0=|| s1=|__unsafe_unretained| s2=|__strong| s3=|__weak| s4=|__autoreleasing|}</target>
        </segment>
      </unit>
      <unit id="3027" name="err_arc_indirect_no_ownership">
        <segment>
          <source>%select{pointer|reference}1 to non-const type %0 with no explicit ownership</source>
          <target>{$arg1 :select s0=|pointer| s1=|reference|} to non-const type {$arg0} with no explicit ownership</target>
        </segment>
      </unit>
      <unit id="3028" name="err_arc_init_method_unrelated_result_type">
        <segment>
          <source>init methods must return a type related to the receiver type</source>
          <target>init methods must return a type related to the receiver type</target>
        </segment>
      </unit>
      <unit id="3029" name="err_arc_lost_method_convention">
        <segment>
          <source>method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1</source>
          <target>method was declared as {$arg0 :select s0=|an 'alloc'| s1=|a 'copy'| s2=|an 'init'| s3=|a 'new'|} method, but its implementation doesn't match because {$arg1 :select s0=|its result type is not an object pointer| s1=|its result type is unrelated to its receiver type|}</target>
        </segment>
      </unit>
      <unit id="3030" name="err_arc_may_not_respond">
        <segment>
          <source>no visible @interface for %0 declares the selector %1</source>
          <target>no visible @interface for {$arg0} declares the selector {$arg1}</target>
        </segment>
      </unit>
      <unit id="3031" name="err_arc_method_not_found">
        <segment>
          <source>no known %select{instance|class}1 method for selector %0</source>
          <target>no known {$arg1 :select s0=|instance| s1=|class|} method for selector {$arg0}</target>
        </segment>
      </unit>
      <unit id="3032" name="err_arc_mismatched_cast">
        <segment>
          <source>%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC</source>
          <target>{$arg0 :select s0=|implicit conversion| s1=|cast|} of {$arg1 :select s0=|{$arg2}| s1=|a non-Objective-C pointer type {$arg2}| s2=|a block pointer| s3=|an Objective-C pointer| s4=|an indirect pointer to an Objective-C pointer|} to {$arg3} is disallowed with ARC</target>
        </segment>
      </unit>
      <unit id="3033" name="err_arc_multiple_method_decl">
        <segment>
          <source>multiple methods named %0 found with mismatched result, parameter type or attributes</source>
          <target>multiple methods named {$arg0} found with mismatched result, parameter type or attributes</target>
        </segment>
      </unit>
      <unit id="3034" name="err_arc_new_array_without_ownership">
        <segment>
          <source>'new' cannot allocate an array of %0 with no explicit ownership</source>
          <target>'new' cannot allocate an array of {$arg0} with no explicit ownership</target>
        </segment>
      </unit>
      <unit id="3035" name="err_arc_nolifetime_behavior">
        <segment>
          <source>explicit ownership qualifier on cast result has no effect</source>
          <target>explicit ownership qualifier on cast result has no effect</target>
        </segment>
      </unit>
      <unit id="3036" name="err_arc_nonlocal_writeback">
        <segment>
          <source>passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back</source>
          <target>passing address of {$arg0 :select s0=|non-local| s1=|non-scalar|} object to __autoreleasing parameter for write-back</target>
        </segment>
      </unit>
      <unit id="3037" name="err_arc_objc_property_default_assign_on_object">
        <segment>
          <source>ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute</source>
          <target>ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute</target>
        </segment>
      </unit>
      <unit id="3038" name="err_arc_perform_selector_retains">
        <segment>
          <source>performSelector names a selector which retains the object</source>
          <target>performSelector names a selector which retains the object</target>
        </segment>
      </unit>
      <unit id="3039" name="err_arc_pseudo_dtor_inconstant_quals">
        <segment>
          <source>pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1</source>
          <target>pseudo-destructor destroys object of type {$arg0} with inconsistently-qualified type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3040" name="err_arc_receiver_forward_class">
        <segment>
          <source>receiver %0 for class message is a forward declaration</source>
          <target>receiver {$arg0} for class message is a forward declaration</target>
        </segment>
      </unit>
      <unit id="3041" name="err_arc_receiver_forward_instance">
        <segment>
          <source>receiver type %0 for instance message is a forward declaration</source>
          <target>receiver type {$arg0} for instance message is a forward declaration</target>
        </segment>
      </unit>
      <unit id="3042" name="err_arc_strong_property_ownership">
        <segment>
          <source>existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2</source>
          <target>existing instance variable {$arg1} for strong property {$arg0} may not be {$arg2 :select s0=|| s1=|__unsafe_unretained| s2=|| s3=|__weak|}</target>
        </segment>
      </unit>
      <unit id="3043" name="err_arc_thread_ownership">
        <segment>
          <source>thread-local variable has non-trivial ownership: type is %0</source>
          <target>thread-local variable has non-trivial ownership: type is {$arg0}</target>
        </segment>
      </unit>
      <unit id="3044" name="err_arc_typecheck_convert_incompatible_pointer">
        <segment>
          <source>incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type</source>
          <target>incompatible pointer types passing retainable parameter of type {$arg0}to a CF function expecting {$arg1} type</target>
        </segment>
      </unit>
      <unit id="3045" name="err_arc_unsupported_weak_class">
        <segment>
          <source>class is incompatible with __weak references</source>
          <target>class is incompatible with __weak references</target>
        </segment>
      </unit>
      <unit id="3046" name="err_arc_unused_init_message">
        <segment>
          <source>the result of a delegate init call must be immediately returned or assigned to 'self'</source>
          <target>the result of a delegate init call must be immediately returned or assigned to 'self'</target>
        </segment>
      </unit>
      <unit id="3047" name="err_arc_weak_disabled">
        <segment>
          <source>cannot create __weak reference in file using manual reference counting</source>
          <target>cannot create __weak reference in file using manual reference counting</target>
        </segment>
      </unit>
      <unit id="3048" name="err_arc_weak_ivar_access">
        <segment>
          <source>dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first</source>
          <target>dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first</target>
        </segment>
      </unit>
      <unit id="3049" name="err_arc_weak_no_runtime">
        <segment>
          <source>cannot create __weak reference because the current deployment target does not support weak references</source>
          <target>cannot create __weak reference because the current deployment target does not support weak references</target>
        </segment>
      </unit>
      <unit id="3050" name="err_arc_weak_unavailable_assign">
        <segment>
          <source>assignment of a weak-unavailable object to a __weak object</source>
          <target>assignment of a weak-unavailable object to a __weak object</target>
        </segment>
      </unit>
      <unit id="3051" name="err_arc_weak_unavailable_property">
        <segment>
          <source>synthesizing __weak instance variable of type %0, which does not support weak references</source>
          <target>synthesizing __weak instance variable of type {$arg0}, which does not support weak references</target>
        </segment>
      </unit>
      <unit id="3052" name="err_arg_is_not_destructurable">
        <segment>
          <source>type %0 cannot be decomposed</source>
          <target>type {$arg0} cannot be decomposed</target>
        </segment>
      </unit>
      <unit id="3053" name="err_arg_with_address_space">
        <segment>
          <source>parameter may not be qualified with an address space</source>
          <target>parameter may not be qualified with an address space</target>
        </segment>
      </unit>
      <unit id="3054" name="err_argument_invalid_range">
        <segment>
          <source>argument value %0 is outside the valid range [%1, %2]</source>
          <target>argument value {$arg0} is outside the valid range [{$arg1}, {$arg2}]</target>
        </segment>
      </unit>
      <unit id="3055" name="err_argument_not_contiguous_bit_field">
        <segment>
          <source>argument %0 value should represent a contiguous bit field</source>
          <target>argument {$arg0} value should represent a contiguous bit field</target>
        </segment>
      </unit>
      <unit id="3056" name="err_argument_not_multiple">
        <segment>
          <source>argument should be a multiple of %0</source>
          <target>argument should be a multiple of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3057" name="err_argument_not_power_of_2">
        <segment>
          <source>argument should be a power of 2</source>
          <target>argument should be a power of 2</target>
        </segment>
      </unit>
      <unit id="3058" name="err_argument_not_shifted_byte">
        <segment>
          <source>argument should be an 8-bit value shifted by a multiple of 8 bits</source>
          <target>argument should be an 8-bit value shifted by a multiple of 8 bits</target>
        </segment>
      </unit>
      <unit id="3059" name="err_argument_not_shifted_byte_or_xxff">
        <segment>
          <source>argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF</source>
          <target>argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF</target>
        </segment>
      </unit>
      <unit id="3060" name="err_arith_conv_enum_float_cxx26">
        <segment>
          <source>invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3</source>
          <target>invalid {$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} {$arg1 :select s0=|floating-point| s1=|enumeration|} type {$arg2} %plural{2:with|4:from|:and}0 {$arg1 :select s0=|enumeration| s1=|floating-point|} type {$arg3}</target>
        </segment>
      </unit>
      <unit id="3061" name="err_arithmetic_nonfragile_interface">
        <segment>
          <source>arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform</source>
          <target>arithmetic on pointer to interface {$arg0}, which is not a constant size for this architecture and platform</target>
        </segment>
      </unit>
      <unit id="3062" name="err_arm_interrupt_called">
        <segment>
          <source>interrupt service routine cannot be called directly</source>
          <target>interrupt service routine cannot be called directly</target>
        </segment>
      </unit>
      <unit id="3063" name="err_arm_invalid_coproc">
        <segment>
          <source>coprocessor %0 must be configured as %select{GCP|CDE}1</source>
          <target>coprocessor {$arg0} must be configured as {$arg1 :select s0=|GCP| s1=|CDE|}</target>
        </segment>
      </unit>
      <unit id="3064" name="err_arm_invalid_specialreg">
        <segment>
          <source>invalid special register for builtin</source>
          <target>invalid special register for builtin</target>
        </segment>
      </unit>
      <unit id="3065" name="err_array_designator_empty_range">
        <segment>
          <source>array designator range [%0, %1] is empty</source>
          <target>array designator range [{$arg0}, {$arg1}] is empty</target>
        </segment>
      </unit>
      <unit id="3066" name="err_array_designator_negative">
        <segment>
          <source>array designator value '%0' is negative</source>
          <target>array designator value '{$arg0}' is negative</target>
        </segment>
      </unit>
      <unit id="3067" name="err_array_designator_non_array">
        <segment>
          <source>array designator cannot initialize non-array type %0</source>
          <target>array designator cannot initialize non-array type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3068" name="err_array_designator_too_large">
        <segment>
          <source>array designator index (%0) exceeds array bounds (%1)</source>
          <target>array designator index ({$arg0}) exceeds array bounds ({$arg1})</target>
        </segment>
      </unit>
      <unit id="3069" name="err_array_element_alignment">
        <segment>
          <source>size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)</source>
          <target>size of array element of type {$arg0} ({$arg1} bytes) isn't a multiple of its alignment ({$arg2} bytes)</target>
        </segment>
      </unit>
      <unit id="3070" name="err_array_incomplete_or_sizeless_type">
        <segment>
          <source>array has %select{incomplete|sizeless}0 element type %1</source>
          <target>array has {$arg0 :select s0=|incomplete| s1=|sizeless|} element type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3071" name="err_array_init_different_type">
        <segment>
          <source>cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1</source>
          <target>cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1</target>
        </segment>
      </unit>
      <unit id="3072" name="err_array_init_incompat_wide_string_into_wchar">
        <segment>
          <source>initializing wide char array with incompatible wide string literal</source>
          <target>initializing wide char array with incompatible wide string literal</target>
        </segment>
      </unit>
      <unit id="3073" name="err_array_init_narrow_string_into_wchar">
        <segment>
          <source>initializing wide char array with non-wide string literal</source>
          <target>initializing wide char array with non-wide string literal</target>
        </segment>
      </unit>
      <unit id="3074" name="err_array_init_non_constant_array">
        <segment>
          <source>cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1</source>
          <target>cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1</target>
        </segment>
      </unit>
      <unit id="3075" name="err_array_init_not_init_list">
        <segment>
          <source>array initializer must be an initializer list%select{| or string literal| or wide string literal}0</source>
          <target>array initializer must be an initializer list{$arg0 :select s0=|| s1=| or string literal| s2=| or wide string literal|}</target>
        </segment>
      </unit>
      <unit id="3076" name="err_array_init_plain_string_into_char8_t">
        <segment>
          <source>initializing 'char8_t' array with plain string literal</source>
          <target>initializing 'char8_t' array with plain string literal</target>
        </segment>
      </unit>
      <unit id="3077" name="err_array_init_utf8_string_into_char">
        <segment>
          <source>initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1</source>
          <target>initialization of {$arg0 :select s0=|| s1=|signed |}char array with UTF-8 string literal is not permitted by {$arg1 :select s0=|'-fchar8_t'| s1=|C++20|}</target>
        </segment>
      </unit>
      <unit id="3078" name="err_array_init_wide_string_into_char">
        <segment>
          <source>initializing char array with wide string literal</source>
          <target>initializing char array with wide string literal</target>
        </segment>
      </unit>
      <unit id="3079" name="err_array_new_needs_size">
        <segment>
          <source>array size must be specified in new expression with no initializer</source>
          <target>array size must be specified in new expression with no initializer</target>
        </segment>
      </unit>
      <unit id="3080" name="err_array_of_abstract_type">
        <segment>
          <source>array of abstract class type %0</source>
          <target>array of abstract class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3081" name="err_array_section_does_not_specify_contiguous_storage">
        <segment>
          <source>array section does not specify contiguous storage</source>
          <target>array section does not specify contiguous storage</target>
        </segment>
      </unit>
      <unit id="3082" name="err_array_section_does_not_specify_length">
        <segment>
          <source>array section does not specify length for outermost dimension</source>
          <target>array section does not specify length for outermost dimension</target>
        </segment>
      </unit>
      <unit id="3083" name="err_array_section_use">
        <segment>
          <source>%select{OpenACC sub-array|OpenMP array section}0 is not allowed here</source>
          <target>{$arg0 :select s0=|OpenACC sub-array| s1=|OpenMP array section|} is not allowed here</target>
        </segment>
      </unit>
      <unit id="3084" name="err_array_size_ambiguous_conversion">
        <segment>
          <source>ambiguous conversion of array size expression of type %0 to an integral or enumeration type</source>
          <target>ambiguous conversion of array size expression of type {$arg0} to an integral or enumeration type</target>
        </segment>
      </unit>
      <unit id="3085" name="err_array_size_explicit_conversion">
        <segment>
          <source>array size expression of type %0 requires explicit conversion to type %1</source>
          <target>array size expression of type {$arg0} requires explicit conversion to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3086" name="err_array_size_incomplete_type">
        <segment>
          <source>array size expression has incomplete class type %0</source>
          <target>array size expression has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3087" name="err_array_size_non_int">
        <segment>
          <source>size of array has non-integer type %0</source>
          <target>size of array has non-integer type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3088" name="err_array_size_not_integral">
        <segment>
          <source>array size expression must have integral or %select{|unscoped }0enumeration type, not %1</source>
          <target>array size expression must have integral or {$arg0 :select s0=|| s1=|unscoped |}enumeration type, not {$arg1}</target>
        </segment>
      </unit>
      <unit id="3089" name="err_array_star_in_function_definition">
        <segment>
          <source>variable length array must be bound in function definition</source>
          <target>variable length array must be bound in function definition</target>
        </segment>
      </unit>
      <unit id="3090" name="err_array_star_outside_prototype">
        <segment>
          <source>star modifier used outside of function prototype</source>
          <target>star modifier used outside of function prototype</target>
        </segment>
      </unit>
      <unit id="3091" name="err_array_static_not_outermost">
        <segment>
          <source>%0 used in non-outermost array type derivation</source>
          <target>{$arg0} used in non-outermost array type derivation</target>
        </segment>
      </unit>
      <unit id="3092" name="err_array_static_outside_prototype">
        <segment>
          <source>%0 used in array declarator outside of function prototype</source>
          <target>{$arg0} used in array declarator outside of function prototype</target>
        </segment>
      </unit>
      <unit id="3093" name="err_array_too_large">
        <segment>
          <source>array is too large (%0 elements)</source>
          <target>array is too large ({$arg0} elements)</target>
        </segment>
      </unit>
      <unit id="3094" name="err_as_qualified_auto_decl">
        <segment>
          <source>automatic variable qualified with an%select{| invalid}0 address space</source>
          <target>automatic variable qualified with an{$arg0 :select s0=|| s1=| invalid|} address space</target>
        </segment>
      </unit>
      <unit id="3095" name="err_asm_incomplete_type">
        <segment>
          <source>asm operand has incomplete type %0</source>
          <target>asm operand has incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3096" name="err_asm_input_duplicate_match">
        <segment>
          <source>more than one input constraint matches the same output '%0'</source>
          <target>more than one input constraint matches the same output '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3097" name="err_asm_invalid_global_var_reg">
        <segment>
          <source>register '%0' unsuitable for global register variables on this target</source>
          <target>register '{$arg0}' unsuitable for global register variables on this target</target>
        </segment>
      </unit>
      <unit id="3098" name="err_asm_invalid_input_constraint">
        <segment>
          <source>invalid input constraint '%0' in asm</source>
          <target>invalid input constraint '{$arg0}' in asm</target>
        </segment>
      </unit>
      <unit id="3099" name="err_asm_invalid_input_size">
        <segment>
          <source>invalid input size for constraint '%0'</source>
          <target>invalid input size for constraint '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3100" name="err_asm_invalid_lvalue_in_input">
        <segment>
          <source>invalid lvalue in asm input for constraint '%0'</source>
          <target>invalid lvalue in asm input for constraint '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3101" name="err_asm_invalid_lvalue_in_output">
        <segment>
          <source>invalid lvalue in asm output</source>
          <target>invalid lvalue in asm output</target>
        </segment>
      </unit>
      <unit id="3102" name="err_asm_invalid_output_constraint">
        <segment>
          <source>invalid output constraint '%0' in asm</source>
          <target>invalid output constraint '{$arg0}' in asm</target>
        </segment>
      </unit>
      <unit id="3103" name="err_asm_invalid_output_size">
        <segment>
          <source>invalid output size for constraint '%0'</source>
          <target>invalid output size for constraint '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3104" name="err_asm_naked_parm_ref">
        <segment>
          <source>parameter references not allowed in naked functions</source>
          <target>parameter references not allowed in naked functions</target>
        </segment>
      </unit>
      <unit id="3105" name="err_asm_naked_this_ref">
        <segment>
          <source>'this' pointer references not allowed in naked functions</source>
          <target>'this' pointer references not allowed in naked functions</target>
        </segment>
      </unit>
      <unit id="3106" name="err_asm_non_addr_value_in_memory_constraint">
        <segment>
          <source>reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'</source>
          <target>reference to a {$arg0 :select s0=|bit-field| s1=|vector element| s2=|global register variable|} in asm {$arg1 :select s0=|input| s1=|output|} with a memory constraint '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="3107" name="err_asm_operand_empty_string">
        <segment>
          <source>cannot use an empty string literal in 'asm'</source>
          <target>cannot use an empty string literal in 'asm'</target>
        </segment>
      </unit>
      <unit id="3108" name="err_asm_pmf_through_constraint_not_permitted">
        <segment>
          <source>cannot pass a pointer-to-member through register-constrained inline assembly parameter</source>
          <target>cannot pass a pointer-to-member through register-constrained inline assembly parameter</target>
        </segment>
      </unit>
      <unit id="3109" name="err_asm_register_size_mismatch">
        <segment>
          <source>size of register '%0' does not match variable size</source>
          <target>size of register '{$arg0}' does not match variable size</target>
        </segment>
      </unit>
      <unit id="3110" name="err_asm_tying_incompatible_types">
        <segment>
          <source>unsupported inline asm: input with type %diff{$ matching output with type $|}0,1</source>
          <target>unsupported inline asm: input with type %diff{$ matching output with type $|}0,1</target>
        </segment>
      </unit>
      <unit id="3111" name="err_asm_unexpected_constraint_alternatives">
        <segment>
          <source>asm constraint has an unexpected number of alternatives: %0 vs %1</source>
          <target>asm constraint has an unexpected number of alternatives: {$arg0} vs {$arg1}</target>
        </segment>
      </unit>
      <unit id="3112" name="err_asm_unknown_register_name">
        <segment>
          <source>unknown register name '%0' in asm</source>
          <target>unknown register name '{$arg0}' in asm</target>
        </segment>
      </unit>
      <unit id="3113" name="err_asm_unsupported_register_type">
        <segment>
          <source>unsupported type for named register variable</source>
          <target>unsupported type for named register variable</target>
        </segment>
      </unit>
      <unit id="3114" name="err_asm_unwind_and_goto">
        <segment>
          <source state="initial">unwind clobber cannot be used with asm goto</source>
          <target>unwind clobber cannot be used with asm goto</target>
        </segment>
      </unit>
      <unit id="3115" name="err_assoc_compatible_types">
        <segment>
          <source>type %0 in generic association compatible with previously specified type %1</source>
          <target>type {$arg0} in generic association compatible with previously specified type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3116" name="err_assoc_type_nonobject">
        <segment>
          <source>type %0 in generic association not an object type</source>
          <target>type {$arg0} in generic association not an object type</target>
        </segment>
      </unit>
      <unit id="3117" name="err_assoc_type_variably_modified">
        <segment>
          <source>type %0 in generic association is a variably modified type</source>
          <target>type {$arg0} in generic association is a variably modified type</target>
        </segment>
      </unit>
      <unit id="3118" name="err_atdef_nonfragile_interface">
        <segment>
          <source>use of @defs is not supported on this architecture and platform</source>
          <target>use of @defs is not supported on this architecture and platform</target>
        </segment>
      </unit>
      <unit id="3119" name="err_atomic_builtin_bit_int_prohibit">
        <segment>
          <source>argument to atomic builtin of type '_BitInt' is not supported</source>
          <target>argument to atomic builtin of type '_BitInt' is not supported</target>
        </segment>
      </unit>
      <unit id="3120" name="err_atomic_builtin_cannot_be_const">
        <segment>
          <source>address argument to atomic builtin cannot be const-qualified (%0 invalid)</source>
          <target>address argument to atomic builtin cannot be const-qualified ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3121" name="err_atomic_builtin_ext_int_size">
        <segment>
          <source>atomic memory operand must have a power-of-two size</source>
          <target>atomic memory operand must have a power-of-two size</target>
        </segment>
      </unit>
      <unit id="3122" name="err_atomic_builtin_must_be_pointer">
        <segment>
          <source>address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)</source>
          <target>address argument to atomic builtin must be a pointer {$arg1 :select s0=|| s1=|to a non-zero-sized object |}({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3123" name="err_atomic_builtin_must_be_pointer_intfltptr">
        <segment>
          <source>address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)</source>
          <target>address argument to atomic builtin must be a pointer to integer, floating-point or pointer ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3124" name="err_atomic_builtin_must_be_pointer_intptr">
        <segment>
          <source>address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)</source>
          <target>address argument to atomic builtin must be a pointer to integer or pointer ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3125" name="err_atomic_builtin_pointer_size">
        <segment>
          <source>address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)</source>
          <target>address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3126" name="err_atomic_exclusive_builtin_pointer_size">
        <segment>
          <source>address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)</source>
          <target>address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3127" name="err_atomic_load_store_uses_lib">
        <segment>
          <source>atomic %select{load|store}0 requires runtime support that is not available for this target</source>
          <target>atomic {$arg0 :select s0=|load| s1=|store|} requires runtime support that is not available for this target</target>
        </segment>
      </unit>
      <unit id="3128" name="err_atomic_op_has_invalid_sync_scope">
        <segment>
          <source>synchronization scope argument to atomic operation is invalid</source>
          <target>synchronization scope argument to atomic operation is invalid</target>
        </segment>
      </unit>
      <unit id="3129" name="err_atomic_op_needs_atomic">
        <segment>
          <source>address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)</source>
          <target>address argument to atomic operation must be a pointer to _Atomic type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3130" name="err_atomic_op_needs_atomic_int">
        <segment>
          <source>address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)</source>
          <target>address argument to atomic operation must be a pointer to {$arg0 :select s0=|| s1=|atomic |}integer ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3131" name="err_atomic_op_needs_atomic_int_or_fp">
        <segment>
          <source>address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)</source>
          <target>address argument to atomic operation must be a pointer to {$arg0 :select s0=|| s1=|atomic |}integer or supported floating point type ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3132" name="err_atomic_op_needs_atomic_int_or_ptr">
        <segment>
          <source>address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)</source>
          <target>address argument to atomic operation must be a pointer to {$arg0 :select s0=|| s1=|atomic |}integer or pointer ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3133" name="err_atomic_op_needs_atomic_int_ptr_or_fp">
        <segment>
          <source>address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)</source>
          <target>address argument to atomic operation must be a pointer to {$arg0 :select s0=|| s1=|atomic |}integer, pointer or supported floating point type ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3134" name="err_atomic_op_needs_non_address_discriminated_pointer">
        <segment>
          <source>address argument to %select{atomic|__sync}0 operation must be a pointer to a non address discriminated type (%1 invalid)</source>
          <target>address argument to {$arg0 :select s0=|atomic| s1=|__sync|} operation must be a pointer to a non address discriminated type ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3135" name="err_atomic_op_needs_non_const_atomic">
        <segment>
          <source>address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)</source>
          <target>address argument to atomic operation must be a pointer to non-{$arg0 :select s0=|const| s1=|constant|} _Atomic type ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="3136" name="err_atomic_op_needs_non_const_pointer">
        <segment>
          <source>address argument to atomic operation must be a pointer to non-const type (%0 invalid)</source>
          <target>address argument to atomic operation must be a pointer to non-const type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3137" name="err_atomic_op_needs_trivial_copy">
        <segment>
          <source>address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)</source>
          <target>address argument to atomic operation must be a pointer to a trivially-copyable type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="3138" name="err_atomic_property_nontrivial_assign_op">
        <segment>
          <source>atomic property of reference type %0 cannot have non-trivial assignment operator</source>
          <target>atomic property of reference type {$arg0} cannot have non-trivial assignment operator</target>
        </segment>
      </unit>
      <unit id="3139" name="err_atomic_specifier_bad_type">
        <segment>
          <source>_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0</source>
          <target>_Atomic cannot be applied to {$arg0 :select s0=|incomplete | s1=|array | s2=|function | s3=|reference | s4=|atomic | s5=|qualified | s6=|sizeless | s7=|| s8=|integer | s9=||}type {$arg1} {$arg0 :select s0=|| s1=|| s2=|| s3=|| s4=|| s5=|| s6=|| s7=|which is not trivially copyable| s8=|| s9=|in C23|}</target>
        </segment>
      </unit>
      <unit id="3140" name="err_atomic_unsupported">
        <segment>
          <source>atomic types are not supported in '%0'</source>
          <target>atomic types are not supported in '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3141" name="err_atprotocol_protocol">
        <segment>
          <source>@protocol is using a forward protocol declaration of %0</source>
          <target>@protocol is using a forward protocol declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3142" name="err_attr_codemodel_arg">
        <segment>
          <source>code model '%0' is not supported on this target</source>
          <target>code model '{$arg0}' is not supported on this target</target>
        </segment>
      </unit>
      <unit id="3143" name="err_attr_cond_never_constant_expr">
        <segment>
          <source>%0 attribute expression never produces a constant expression</source>
          <target>{$arg0} attribute expression never produces a constant expression</target>
        </segment>
      </unit>
      <unit id="3144" name="err_attr_objc_ownership_redundant">
        <segment>
          <source>the type %0 is already explicitly ownership-qualified</source>
          <target>the type {$arg0} is already explicitly ownership-qualified</target>
        </segment>
      </unit>
      <unit id="3145" name="err_attr_swift_error_no_error_parameter">
        <segment>
          <source>%0 attribute can only be applied to a %select{function|method}1 with an error parameter</source>
          <target>{$arg0} attribute can only be applied to a {$arg1 :select s0=|function| s1=|method|} with an error parameter</target>
        </segment>
      </unit>
      <unit id="3146" name="err_attr_swift_error_return_type">
        <segment>
          <source>%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3</source>
          <target>{$arg0} attribute with '{$arg1}' convention can only be applied to a {$arg2 :select s0=|function| s1=|method|} returning {$arg3 :select s0=|an integral type| s1=|a pointer|}</target>
        </segment>
      </unit>
      <unit id="3147" name="err_attr_tlsmodel_arg">
        <segment>
          <source>tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"</source>
          <target>tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"</target>
        </segment>
      </unit>
      <unit id="3148" name="err_attribute_address_function_type">
        <segment>
          <source>function type may not be qualified with an address space</source>
          <target>function type may not be qualified with an address space</target>
        </segment>
      </unit>
      <unit id="3149" name="err_attribute_address_multiple_qualifiers">
        <segment>
          <source>multiple address spaces specified for type</source>
          <target>multiple address spaces specified for type</target>
        </segment>
      </unit>
      <unit id="3150" name="err_attribute_address_space_negative">
        <segment>
          <source>address space is negative</source>
          <target>address space is negative</target>
        </segment>
      </unit>
      <unit id="3151" name="err_attribute_address_space_too_high">
        <segment>
          <source>address space is larger than the maximum supported (%0)</source>
          <target>address space is larger than the maximum supported ({$arg0})</target>
        </segment>
      </unit>
      <unit id="3152" name="err_attribute_aligned_too_great">
        <segment>
          <source>requested alignment must be %0 bytes or smaller</source>
          <target>requested alignment must be {$arg0} bytes or smaller</target>
        </segment>
      </unit>
      <unit id="3153" name="err_attribute_argument_invalid">
        <segment>
          <source>%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1</source>
          <target>{$arg0} attribute argument is invalid: {$arg1 :select s0=|max must be 0 since min is 0| s1=|min must not be greater than max|}</target>
        </segment>
      </unit>
      <unit id="3154" name="err_attribute_argument_is_zero">
        <segment>
          <source>%0 attribute must be greater than 0</source>
          <target>{$arg0} attribute must be greater than 0</target>
        </segment>
      </unit>
      <unit id="3155" name="err_attribute_argument_n_type">
        <segment>
          <source>%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2</source>
          <target>{$arg0} attribute requires parameter {$arg1} to be {$arg2 :select s0=|int or bool| s1=|an integer constant| s2=|a string| s3=|an identifier| s4=|a constant expression| s5=|a builtin function|}</target>
        </segment>
      </unit>
      <unit id="3156" name="err_attribute_argument_out_of_bounds">
        <segment>
          <source>%0 attribute parameter %1 is out of bounds</source>
          <target>{$arg0} attribute parameter {$arg1} is out of bounds</target>
        </segment>
      </unit>
      <unit id="3157" name="err_attribute_argument_out_of_bounds_extra_info">
        <segment>
          <source>%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2</source>
          <target>{$arg0} attribute parameter {$arg1} is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and {$arg2}}2</target>
        </segment>
      </unit>
      <unit id="3158" name="err_attribute_argument_out_of_range">
        <segment>
          <source>%0 attribute requires integer constant between %1 and %2 inclusive</source>
          <target>{$arg0} attribute requires integer constant between {$arg1} and {$arg2} inclusive</target>
        </segment>
      </unit>
      <unit id="3159" name="err_attribute_argument_type">
        <segment>
          <source>%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1</source>
          <target>{$arg0} attribute requires {$arg1 :select s0=|int or bool| s1=|an integer constant| s2=|a string| s3=|an identifier|}</target>
        </segment>
      </unit>
      <unit id="3160" name="err_attribute_arm_builtin_alias">
        <segment>
          <source>'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin</source>
          <target>'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin</target>
        </segment>
      </unit>
      <unit id="3161" name="err_attribute_arm_feature_sve_bits_unsupported">
        <segment>
          <source>%0 is only supported when '-msve-vector-bits=&lt;bits&gt;' is specified with a value of 128, 256, 512, 1024 or 2048</source>
          <target>{$arg0} is only supported when '-msve-vector-bits=&lt;bits&gt;' is specified with a value of 128, 256, 512, 1024 or 2048</target>
        </segment>
      </unit>
      <unit id="3162" name="err_attribute_arm_mve_polymorphism">
        <segment>
          <source>'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type</source>
          <target>'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type</target>
        </segment>
      </unit>
      <unit id="3163" name="err_attribute_arm_sm_incompat_builtin">
        <segment>
          <source>builtin can only be called from a %0 function</source>
          <target>builtin can only be called from a {$arg0} function</target>
        </segment>
      </unit>
      <unit id="3164" name="err_attribute_bad_neon_vector_size">
        <segment>
          <source>Neon vector size must be 64 or 128 bits</source>
          <target>Neon vector size must be 64 or 128 bits</target>
        </segment>
      </unit>
      <unit id="3165" name="err_attribute_bad_rvv_vector_size">
        <segment>
          <source>invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'</source>
          <target>invalid RVV vector size '{$arg0}', expected size is '{$arg1}' based on LMUL of type and '-mrvv-vector-bits'</target>
        </segment>
      </unit>
      <unit id="3166" name="err_attribute_bad_sve_vector_size">
        <segment>
          <source>invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')</source>
          <target>invalid SVE vector size '{$arg0}', must match value set by '-msve-vector-bits' ('{$arg1}')</target>
        </segment>
      </unit>
      <unit id="3167" name="err_attribute_bounds_for_function">
        <segment>
          <source>%0 attribute references parameter %1, but the function %2 has only %3 parameters</source>
          <target>{$arg0} attribute references parameter {$arg1}, but the function {$arg2} has only {$arg3} parameters</target>
        </segment>
      </unit>
      <unit id="3168" name="err_attribute_builtin_alias">
        <segment>
          <source>%0 attribute can only be applied to a ARM, HLSL or RISC-V builtin</source>
          <target>{$arg0} attribute can only be applied to a ARM, HLSL or RISC-V builtin</target>
        </segment>
      </unit>
      <unit id="3169" name="err_attribute_cleanup_arg_not_function">
        <segment>
          <source>'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function</source>
          <target>'cleanup' argument {$arg0 :select s0=|| s1=|{$arg1} | s2=|{$arg1} |}is not a {$arg0 :select s0=|| s1=|| s2=|single |}function</target>
        </segment>
      </unit>
      <unit id="3170" name="err_attribute_cleanup_func_arg_incompatible_type">
        <segment>
          <source>'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2</source>
          <target>'cleanup' function {$arg0} parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2</target>
        </segment>
      </unit>
      <unit id="3171" name="err_attribute_cleanup_func_must_take_one_arg">
        <segment>
          <source>'cleanup' function %0 must take 1 parameter</source>
          <target>'cleanup' function {$arg0} must take 1 parameter</target>
        </segment>
      </unit>
      <unit id="3172" name="err_attribute_dll_ambiguous_default_ctor">
        <segment>
          <source>'__declspec(dllexport)' cannot be applied to more than one default constructor in %0</source>
          <target>'__declspec(dllexport)' cannot be applied to more than one default constructor in {$arg0}</target>
        </segment>
      </unit>
      <unit id="3173" name="err_attribute_dll_deleted">
        <segment>
          <source>attribute %q0 cannot be applied to a deleted function</source>
          <target>attribute {$arg0 :q} cannot be applied to a deleted function</target>
        </segment>
      </unit>
      <unit id="3174" name="err_attribute_dll_lambda">
        <segment>
          <source>lambda cannot be declared %0</source>
          <target>lambda cannot be declared {$arg0}</target>
        </segment>
      </unit>
      <unit id="3175" name="err_attribute_dll_member_of_dll_class">
        <segment>
          <source>attribute %q0 cannot be applied to member of %q1 class</source>
          <target>attribute {$arg0 :q} cannot be applied to member of {$arg1 :q} class</target>
        </segment>
      </unit>
      <unit id="3176" name="err_attribute_dll_not_extern">
        <segment>
          <source>%q0 must have external linkage when declared %q1</source>
          <target>{$arg0 :q} must have external linkage when declared {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="3177" name="err_attribute_dll_redeclaration">
        <segment>
          <source>redeclaration of %q0 cannot add %q1 attribute</source>
          <target>redeclaration of {$arg0 :q} cannot add {$arg1 :q} attribute</target>
        </segment>
      </unit>
      <unit id="3178" name="err_attribute_dll_thread_local">
        <segment>
          <source>%q0 cannot be thread local when declared %q1</source>
          <target>{$arg0 :q} cannot be thread local when declared {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="3179" name="err_attribute_dllimport_data_definition">
        <segment>
          <source>definition of dllimport data</source>
          <target>definition of dllimport data</target>
        </segment>
      </unit>
      <unit id="3180" name="err_attribute_dllimport_function_definition">
        <segment>
          <source>dllimport cannot be applied to non-inline function definition</source>
          <target>dllimport cannot be applied to non-inline function definition</target>
        </segment>
      </unit>
      <unit id="3181" name="err_attribute_dllimport_function_specialization_definition">
        <segment>
          <source>cannot define non-inline dllimport template specialization</source>
          <target>cannot define non-inline dllimport template specialization</target>
        </segment>
      </unit>
      <unit id="3182" name="err_attribute_dllimport_static_field_definition">
        <segment>
          <source>definition of dllimport static field not allowed</source>
          <target>definition of dllimport static field not allowed</target>
        </segment>
      </unit>
      <unit id="3183" name="err_attribute_integers_only">
        <segment>
          <source>%0 attribute argument may only refer to a function parameter of integer type</source>
          <target>{$arg0} attribute argument may only refer to a function parameter of integer type</target>
        </segment>
      </unit>
      <unit id="3184" name="err_attribute_invalid_argument">
        <segment>
          <source>%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1</source>
          <target>{$arg0 :select s0=|a reference type| s1=|an array type| s2=|a non-vector or non-vectorizable scalar type|} is an invalid argument to attribute {$arg1}</target>
        </segment>
      </unit>
      <unit id="3185" name="err_attribute_invalid_atomic_argument">
        <segment>
          <source>invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')</source>
          <target>invalid argument '{$arg0}' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')</target>
        </segment>
      </unit>
      <unit id="3186" name="err_attribute_invalid_bitint_vector_type">
        <segment>
          <source state="initial">'_BitInt' %select{vector|matrix}0 element width must be a power of 2</source>
          <target>'_BitInt' {$arg0 :select s0=|vector| s1=|matrix|} element width must be a power of 2</target>
        </segment>
      </unit>
      <unit id="3187" name="err_attribute_invalid_implicit_this_argument">
        <segment>
          <source>%0 attribute is invalid for the implicit this argument</source>
          <target>{$arg0} attribute is invalid for the implicit this argument</target>
        </segment>
      </unit>
      <unit id="3188" name="err_attribute_invalid_matrix_type">
        <segment>
          <source>invalid matrix element type %0</source>
          <target>invalid matrix element type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3189" name="err_attribute_invalid_on_decl">
        <segment>
          <source>%0%select{ attribute|}1 cannot be applied to a declaration</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} cannot be applied to a declaration</target>
        </segment>
      </unit>
      <unit id="3190" name="err_attribute_invalid_rvv_type">
        <segment>
          <source>%0 attribute applied to non-RVV type %1</source>
          <target>{$arg0} attribute applied to non-RVV type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3191" name="err_attribute_invalid_size">
        <segment>
          <source>vector size not an integral multiple of component size</source>
          <target>vector size not an integral multiple of component size</target>
        </segment>
      </unit>
      <unit id="3192" name="err_attribute_invalid_sve_type">
        <segment>
          <source>%0 attribute applied to non-SVE type %1</source>
          <target>{$arg0} attribute applied to non-SVE type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3193" name="err_attribute_invalid_vector_type">
        <segment>
          <source>invalid vector element type %0</source>
          <target>invalid vector element type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3194" name="err_attribute_malloc_arg_not_function">
        <segment>
          <source>'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function</source>
          <target>'malloc' argument {$arg0 :select s0=|for deallocator | s1=|{$arg1} | s2=|{$arg1} |}is not a {$arg0 :select s0=|| s1=|| s2=|single |}function</target>
        </segment>
      </unit>
      <unit id="3195" name="err_attribute_malloc_arg_not_function_with_pointer_arg">
        <segment>
          <source>'malloc' argument %0 must take a pointer type as its first argument</source>
          <target>'malloc' argument {$arg0} must take a pointer type as its first argument</target>
        </segment>
      </unit>
      <unit id="3196" name="err_attribute_malloc_arg_refers_to_non_pointer_type">
        <segment>
          <source>'malloc' argument '%0' refers to non-pointer type %1 of %2</source>
          <target>'malloc' argument '{$arg0}' refers to non-pointer type {$arg1} of {$arg2}</target>
        </segment>
      </unit>
      <unit id="3197" name="err_attribute_missing_on_first_decl">
        <segment>
          <source>%0 attribute does not appear on the first declaration</source>
          <target>{$arg0} attribute does not appear on the first declaration</target>
        </segment>
      </unit>
      <unit id="3198" name="err_attribute_multiple_objc_gc">
        <segment>
          <source>multiple garbage collection attributes specified for type</source>
          <target>multiple garbage collection attributes specified for type</target>
        </segment>
      </unit>
      <unit id="3199" name="err_attribute_no_builtin_on_defaulted_deleted_function">
        <segment>
          <source>%0 attribute has no effect on defaulted or deleted functions</source>
          <target>{$arg0} attribute has no effect on defaulted or deleted functions</target>
        </segment>
      </unit>
      <unit id="3200" name="err_attribute_no_builtin_on_non_definition">
        <segment>
          <source>%0 attribute is permitted on definitions only</source>
          <target>{$arg0} attribute is permitted on definitions only</target>
        </segment>
      </unit>
      <unit id="3201" name="err_attribute_no_builtin_wildcard_or_builtin_name">
        <segment>
          <source>empty %0 cannot be composed with named ones</source>
          <target>empty {$arg0} cannot be composed with named ones</target>
        </segment>
      </unit>
      <unit id="3202" name="err_attribute_no_member_function">
        <segment>
          <source>%0 attribute cannot be applied to non-static member functions</source>
          <target>{$arg0} attribute cannot be applied to non-static member functions</target>
        </segment>
      </unit>
      <unit id="3203" name="err_attribute_no_member_pointers">
        <segment>
          <source>%0 attribute cannot be used with pointers to members</source>
          <target>{$arg0} attribute cannot be used with pointers to members</target>
        </segment>
      </unit>
      <unit id="3204" name="err_attribute_not_clinkage">
        <segment>
          <source>function type with %0 attribute must have C linkage</source>
          <target>function type with {$arg0} attribute must have C linkage</target>
        </segment>
      </unit>
      <unit id="3205" name="err_attribute_not_supported_in_lang">
        <segment>
          <source>%0 attribute is not supported in %select{C|C++|Objective-C}1</source>
          <target>{$arg0} attribute is not supported in {$arg1 :select s0=|C| s1=|C++| s2=|Objective-C|}</target>
        </segment>
      </unit>
      <unit id="3206" name="err_attribute_not_supported_on_arch">
        <segment>
          <source>%0 attribute is not supported on '%1'</source>
          <target>{$arg0} attribute is not supported on '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="3207" name="err_attribute_only_once_per_parameter">
        <segment>
          <source>%0 attribute can only be applied once per parameter</source>
          <target>{$arg0} attribute can only be applied once per parameter</target>
        </segment>
      </unit>
      <unit id="3208" name="err_attribute_output_parameter">
        <segment>
          <source>attribute only applies to output parameters</source>
          <target>attribute only applies to output parameters</target>
        </segment>
      </unit>
      <unit id="3209" name="err_attribute_overloadable_mismatch">
        <segment>
          <source>redeclaration of %0 must %select{not |}1have the 'overloadable' attribute</source>
          <target>redeclaration of {$arg0} must {$arg1 :select s0=|not | s1=||}have the 'overloadable' attribute</target>
        </segment>
      </unit>
      <unit id="3210" name="err_attribute_overloadable_multiple_unmarked_overloads">
        <segment>
          <source>at most one overload for a given name may lack the 'overloadable' attribute</source>
          <target>at most one overload for a given name may lack the 'overloadable' attribute</target>
        </segment>
      </unit>
      <unit id="3211" name="err_attribute_overloadable_no_prototype">
        <segment>
          <source>'overloadable' function %0 must have a prototype</source>
          <target>'overloadable' function {$arg0} must have a prototype</target>
        </segment>
      </unit>
      <unit id="3212" name="err_attribute_parameter_types">
        <segment>
          <source>%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6</source>
          <target>{$arg0} attribute parameter types do not match: parameter {$arg1} of function {$arg2} has type {$arg3}, but parameter {$arg4} of function {$arg5} has type {$arg6}</target>
        </segment>
      </unit>
      <unit id="3213" name="err_attribute_patchable_function_entry_invalid_section">
        <segment>
          <source>section argument to 'patchable_function_entry' attribute is not valid for this target: %0</source>
          <target>section argument to 'patchable_function_entry' attribute is not valid for this target: {$arg0}</target>
        </segment>
      </unit>
      <unit id="3214" name="err_attribute_pointers_only">
        <segment>
          <source>%0 attribute only applies to%select{| constant}1 pointer arguments</source>
          <target>{$arg0} attribute only applies to{$arg1 :select s0=|| s1=| constant|} pointer arguments</target>
        </segment>
      </unit>
      <unit id="3215" name="err_attribute_power_of_two_in_range">
        <segment>
          <source>%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3</source>
          <target>{$arg0} attribute requires an integer argument which is a constant power of two between {$arg1} and {$arg2} inclusive; provided argument was {$arg3}</target>
        </segment>
      </unit>
      <unit id="3216" name="err_attribute_preferred_name_arg_invalid">
        <segment>
          <source>argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1</source>
          <target>argument {$arg0} to 'preferred_name' attribute is not a typedef for a specialization of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3217" name="err_attribute_regparm_invalid_number">
        <segment>
          <source>'regparm' parameter must be between 0 and %0 inclusive</source>
          <target>'regparm' parameter must be between 0 and {$arg0} inclusive</target>
        </segment>
      </unit>
      <unit id="3218" name="err_attribute_regparm_wrong_platform">
        <segment>
          <source>'regparm' is not valid on this platform</source>
          <target>'regparm' is not valid on this platform</target>
        </segment>
      </unit>
      <unit id="3219" name="err_attribute_requires_opencl_version">
        <segment>
          <source>attribute %0 is supported in the OpenCL version %1%select{| onwards}2</source>
          <target>attribute {$arg0} is supported in the OpenCL version {$arg1}{$arg2 :select s0=|| s1=| onwards|}</target>
        </segment>
      </unit>
      <unit id="3220" name="err_attribute_requires_positive_integer">
        <segment>
          <source>%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression</source>
          <target>{$arg0} attribute requires a {$arg1 :select s0=|positive| s1=|non-negative|} integral compile time constant expression</target>
        </segment>
      </unit>
      <unit id="3221" name="err_attribute_riscv_rvv_bits_unsupported">
        <segment>
          <source>%0 is only supported when '-mrvv-vector-bits=&lt;bits&gt;' is specified with a value of "zvl" or a power 2 in the range [64,65536]</source>
          <target>{$arg0} is only supported when '-mrvv-vector-bits=&lt;bits&gt;' is specified with a value of "zvl" or a power 2 in the range [64,65536]</target>
        </segment>
      </unit>
      <unit id="3222" name="err_attribute_section_invalid_for_target">
        <segment>
          <source>argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0</source>
          <target>argument to {$arg1 :select s0=|'code_seg'| s1=|'section'|} attribute is not valid for this target: {$arg0}</target>
        </segment>
      </unit>
      <unit id="3223" name="err_attribute_selectany_non_extern_data">
        <segment>
          <source>'selectany' can only be applied to data items with external linkage</source>
          <target>'selectany' can only be applied to data items with external linkage</target>
        </segment>
      </unit>
      <unit id="3224" name="err_attribute_sentinel_less_than_zero">
        <segment>
          <source>'sentinel' parameter 1 less than zero</source>
          <target>'sentinel' parameter 1 less than zero</target>
        </segment>
      </unit>
      <unit id="3225" name="err_attribute_sentinel_not_zero_or_one">
        <segment>
          <source>'sentinel' parameter 2 not 0 or 1</source>
          <target>'sentinel' parameter 2 not 0 or 1</target>
        </segment>
      </unit>
      <unit id="3226" name="err_attribute_size_too_large">
        <segment>
          <source>%0 size too large</source>
          <target>{$arg0} size too large</target>
        </segment>
      </unit>
      <unit id="3227" name="err_attribute_sizeless_type">
        <segment>
          <source>%0 attribute cannot be applied to sizeless type %1</source>
          <target>{$arg0} attribute cannot be applied to sizeless type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3228" name="err_attribute_too_few_arguments">
        <segment>
          <source>%0 attribute takes at least %1 argument%s1</source>
          <target>{$arg0} attribute takes at least {$arg1} argument%s1</target>
        </segment>
      </unit>
      <unit id="3229" name="err_attribute_too_many_arguments">
        <segment>
          <source>%0 attribute takes no more than %1 argument%s1</source>
          <target>{$arg0} attribute takes no more than {$arg1} argument%s1</target>
        </segment>
      </unit>
      <unit id="3230" name="err_attribute_unsupported">
        <segment>
          <source>%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu=</source>
          <target>{$arg0} attribute is not supported on targets missing {$arg1}; specify an appropriate -march= or -mcpu=</target>
        </segment>
      </unit>
      <unit id="3231" name="err_attribute_unsupported_m_profile">
        <segment>
          <source>on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu=</source>
          <target>on M-profile architectures {$arg0} attribute is not supported on targets missing {$arg1}; specify an appropriate -march= or -mcpu=</target>
        </segment>
      </unit>
      <unit id="3232" name="err_attribute_vecreturn_only_pod_record">
        <segment>
          <source>the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)</source>
          <target>the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)</target>
        </segment>
      </unit>
      <unit id="3233" name="err_attribute_vecreturn_only_vector_member">
        <segment>
          <source>the vecreturn attribute can only be used on a class or structure with one member, which must be a vector</source>
          <target>the vecreturn attribute can only be used on a class or structure with one member, which must be a vector</target>
        </segment>
      </unit>
      <unit id="3234" name="err_attribute_weak_static">
        <segment>
          <source>weak declaration cannot have internal linkage</source>
          <target>weak declaration cannot have internal linkage</target>
        </segment>
      </unit>
      <unit id="3235" name="err_attribute_weakref_not_global_context">
        <segment>
          <source>weakref declaration of %0 must be in a global context</source>
          <target>weakref declaration of {$arg0} must be in a global context</target>
        </segment>
      </unit>
      <unit id="3236" name="err_attribute_weakref_not_static">
        <segment>
          <source>weakref declaration must have internal linkage</source>
          <target>weakref declaration must have internal linkage</target>
        </segment>
      </unit>
      <unit id="3237" name="err_attribute_weakref_without_alias">
        <segment>
          <source>weakref declaration of %0 must also have an alias attribute</source>
          <target>weakref declaration of {$arg0} must also have an alias attribute</target>
        </segment>
      </unit>
      <unit id="3238" name="err_attribute_webassembly_funcref">
        <segment>
          <source>'__funcref' attribute can only be applied to a function pointer type</source>
          <target>'__funcref' attribute can only be applied to a function pointer type</target>
        </segment>
      </unit>
      <unit id="3239" name="err_attribute_wrong_decl_type">
        <segment>
          <source state="initial">%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&amp;R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} only applies to {$arg2 :select s0=|functions| s1=|unions| s2=|variables and functions| s3=|functions and methods| s4=|functions, methods and blocks| s5=|functions, methods, and parameters| s6=|variables| s7=|variables and fields| s8=|variables, data members and tag types| s9=|types and namespaces| s10=|variables, functions and classes| s11=|kernel functions| s12=|non-K&amp;R-style functions| s13=|for loop statements| s14=|virtual functions| s15=|parameters and implicit object parameters| s16=|non-member functions| s17=|functions, classes, or enumerations| s18=|classes| s19=|typedefs|}</target>
        </segment>
      </unit>
      <unit id="3240" name="err_attribute_wrong_decl_type_str">
        <segment>
          <source>%0%select{ attribute|}1 only applies to %2</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} only applies to {$arg2}</target>
        </segment>
      </unit>
      <unit id="3241" name="err_attribute_wrong_number_arguments">
        <segment>
          <source>%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1</source>
          <target>{$arg0} attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly {$arg1} arguments}1</target>
        </segment>
      </unit>
      <unit id="3242" name="err_attribute_wrong_number_arguments_for">
        <segment>
          <source>%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2</source>
          <target>{$arg0} attribute references function {$arg1}, which %plural{0:takes no arguments|1:takes one argument|:takes exactly {$arg2} arguments}2</target>
        </segment>
      </unit>
      <unit id="3243" name="err_attribute_zero_size">
        <segment>
          <source>zero %0 size</source>
          <target>zero {$arg0} size</target>
        </segment>
      </unit>
      <unit id="3244" name="err_attributes_are_not_compatible">
        <segment>
          <source>%0 and %1%select{ attributes|}2 are not compatible</source>
          <target>{$arg0} and {$arg1}{$arg2 :select s0=| attributes| s1=||} are not compatible</target>
        </segment>
      </unit>
      <unit id="3245" name="err_auto_bitfield">
        <segment>
          <source>cannot pass bit-field as __auto_type initializer in C</source>
          <target>cannot pass bit-field as __auto_type initializer in C</target>
        </segment>
      </unit>
      <unit id="3246" name="err_auto_different_deductions">
        <segment>
          <source>%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4</source>
          <target>{$arg0 :select s0=|'auto'| s1=|'decltype(auto)'| s2=|'__auto_type'| s3=|template arguments|} deduced as {$arg1} in declaration of {$arg2} and deduced as {$arg3} in declaration of {$arg4}</target>
        </segment>
      </unit>
      <unit id="3247" name="err_auto_expr_deduction_failure">
        <segment>
          <source>functional-style cast to %0 has incompatible initializer of type %1</source>
          <target>functional-style cast to {$arg0} has incompatible initializer of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3248" name="err_auto_expr_init_multiple_expressions">
        <segment>
          <source>initializer for functional-style cast to %0 contains multiple expressions</source>
          <target>initializer for functional-style cast to {$arg0} contains multiple expressions</target>
        </segment>
      </unit>
      <unit id="3249" name="err_auto_expr_init_no_expression">
        <segment>
          <source>initializer for functional-style cast to %0 is empty</source>
          <target>initializer for functional-style cast to {$arg0} is empty</target>
        </segment>
      </unit>
      <unit id="3250" name="err_auto_expr_init_paren_braces">
        <segment>
          <source>cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list</source>
          <target>cannot deduce actual type for {$arg1} from {$arg0 :select s0=|parenthesized| s1=|nested|} initializer list</target>
        </segment>
      </unit>
      <unit id="3251" name="err_auto_fn_deduction_failure">
        <segment>
          <source>cannot deduce return type %0 from returned value of type %1</source>
          <target>cannot deduce return type {$arg0} from returned value of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3252" name="err_auto_fn_different_deductions">
        <segment>
          <source>'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement</source>
          <target>'{$arg0 :select s0=|auto| s1=|decltype(auto)|}' in return type deduced as {$arg1} here but deduced as {$arg2} in earlier return statement</target>
        </segment>
      </unit>
      <unit id="3253" name="err_auto_fn_no_return_but_not_auto">
        <segment>
          <source>cannot deduce return type %0 for function with no return statements</source>
          <target>cannot deduce return type {$arg0} for function with no return statements</target>
        </segment>
      </unit>
      <unit id="3254" name="err_auto_fn_return_init_list">
        <segment>
          <source>cannot deduce return type from initializer list</source>
          <target>cannot deduce return type from initializer list</target>
        </segment>
      </unit>
      <unit id="3255" name="err_auto_fn_return_void_but_not_auto">
        <segment>
          <source>cannot deduce return type %0 from omitted return expression</source>
          <target>cannot deduce return type {$arg0} from omitted return expression</target>
        </segment>
      </unit>
      <unit id="3256" name="err_auto_fn_used_before_defined">
        <segment>
          <source>function %0 with deduced return type cannot be used before it is defined</source>
          <target>function {$arg0} with deduced return type cannot be used before it is defined</target>
        </segment>
      </unit>
      <unit id="3257" name="err_auto_fn_virtual">
        <segment>
          <source>function with deduced return type cannot be virtual</source>
          <target>function with deduced return type cannot be virtual</target>
        </segment>
      </unit>
      <unit id="3258" name="err_auto_inconsistent_deduction">
        <segment>
          <source>deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type</source>
          <target>deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type</target>
        </segment>
      </unit>
      <unit id="3259" name="err_auto_init_list_from_c">
        <segment>
          <source>cannot use %select{'auto'|&lt;ERROR&gt;|'__auto_type'}0 with %select{initializer list|array}1 in C</source>
          <target>cannot use {$arg0 :select s0=|'auto'| s1=|&lt;ERROR&gt;| s2=|'__auto_type'|} with {$arg1 :select s0=|initializer list| s1=|array|} in C</target>
        </segment>
      </unit>
      <unit id="3260" name="err_auto_missing_trailing_return">
        <segment>
          <source>'auto' return without trailing return type; deduced return types are a C++14 extension</source>
          <target>'auto' return without trailing return type; deduced return types are a C++14 extension</target>
        </segment>
      </unit>
      <unit id="3261" name="err_auto_new_ctor_multiple_expressions">
        <segment>
          <source>new expression for type %0 contains multiple constructor arguments</source>
          <target>new expression for type {$arg0} contains multiple constructor arguments</target>
        </segment>
      </unit>
      <unit id="3262" name="err_auto_new_deduction_failure">
        <segment>
          <source>new expression for type %0 has incompatible constructor argument of type %1</source>
          <target>new expression for type {$arg0} has incompatible constructor argument of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3263" name="err_auto_new_requires_ctor_arg">
        <segment>
          <source>new expression for type %0 requires a constructor argument</source>
          <target>new expression for type {$arg0} requires a constructor argument</target>
        </segment>
      </unit>
      <unit id="3264" name="err_auto_non_deduced_not_alone">
        <segment>
          <source>%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group</source>
          <target>{$arg0 :select s0=|function with deduced return type| s1=|declaration with trailing return type|} must be the only declaration in its group</target>
        </segment>
      </unit>
      <unit id="3265" name="err_auto_not_allowed">
        <segment>
          <source>%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&amp;R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1</source>
          <target>%select{'auto'|'decltype(auto)'|'__auto_type'|use of {$arg0 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|concept| s6=|template}2 {$arg3} requires template arguments; argument deduction|} not allowed {$arg1 :select s0=|in function prototype| s1=|in non-static struct member| s2=|in struct member| s3=|in non-static union member| s4=|in union member| s5=|in non-static class member| s6=|in interface member| s7=|in exception declaration| s8=|in template parameter until C++17| s9=|in block literal| s10=|in template argument| s11=|in typedef| s12=|in type alias| s13=|in function return type| s14=|in conversion function type| s15=|here| s16=|in lambda parameter| s17=|in type allocated by 'new'| s18=|in K&amp;R-style function parameter| s19=|in template parameter| s20=|in friend declaration| s21=|in function prototype that is not a function declaration| s22=|in requires expression parameter| s23=|in array declaration| s24=|in declaration of conversion function template| s25=|in lambda parameter before C++14|}</target>
        </segment>
      </unit>
      <unit id="3266" name="err_auto_not_allowed_var_inst">
        <segment>
          <source>'auto' variable template instantiation is not allowed</source>
          <target>'auto' variable template instantiation is not allowed</target>
        </segment>
      </unit>
      <unit id="3267" name="err_auto_var_deduction_failure">
        <segment>
          <source>variable %0 with type %1 has incompatible initializer of type %2</source>
          <target>variable {$arg0} with type {$arg1} has incompatible initializer of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3268" name="err_auto_var_deduction_failure_from_init_list">
        <segment>
          <source>cannot deduce actual type for variable %0 with type %1 from initializer list</source>
          <target>cannot deduce actual type for variable {$arg0} with type {$arg1} from initializer list</target>
        </segment>
      </unit>
      <unit id="3269" name="err_auto_var_init_multiple_expressions">
        <segment>
          <source>initializer for variable %0 with type %1 contains multiple expressions</source>
          <target>initializer for variable {$arg0} with type {$arg1} contains multiple expressions</target>
        </segment>
      </unit>
      <unit id="3270" name="err_auto_var_init_no_expression">
        <segment>
          <source>initializer for variable %0 with type %1 is empty</source>
          <target>initializer for variable {$arg0} with type {$arg1} is empty</target>
        </segment>
      </unit>
      <unit id="3271" name="err_auto_var_init_paren_braces">
        <segment>
          <source>cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list</source>
          <target>cannot deduce type for variable {$arg1} with type {$arg2} from {$arg0 :select s0=|parenthesized| s1=|nested|} initializer list</target>
        </segment>
      </unit>
      <unit id="3272" name="err_auto_var_requires_init">
        <segment>
          <source>declaration of variable %0 with deduced type %1 requires an initializer</source>
          <target>declaration of variable {$arg0} with deduced type {$arg1} requires an initializer</target>
        </segment>
      </unit>
      <unit id="3273" name="err_auto_variable_cannot_appear_in_own_initializer">
        <segment>
          <source state="initial">%select{variable|variable template|variable template partial specialization|variable template explicit specialization}0 %1 declared with deduced type %2 cannot appear in its own initializer</source>
          <target>{$arg0 :select s0=|variable| s1=|variable template| s2=|variable template partial specialization| s3=|variable template explicit specialization|} {$arg1} declared with deduced type {$arg2} cannot appear in its own initializer</target>
        </segment>
      </unit>
      <unit id="3274" name="err_availability_unexpected_parameter">
        <segment>
          <source>unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1</source>
          <target>unexpected parameter '{$arg0}' in availability attribute, not permitted in {$arg1 :select s0=|HLSL| s1=|C/C++|}</target>
        </segment>
      </unit>
      <unit id="3275" name="err_await_suspend_invalid_return_type">
        <segment>
          <source>return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)</source>
          <target>return type of 'await_suspend' is required to be 'void' or 'bool' (have {$arg0})</target>
        </segment>
      </unit>
      <unit id="3276" name="err_bad_cast_incomplete">
        <segment>
          <source>%0 is an incomplete type</source>
          <target>{$arg0} is an incomplete type</target>
        </segment>
      </unit>
      <unit id="3277" name="err_bad_category_property_decl">
        <segment>
          <source>property implementation must have its declaration in the category %0</source>
          <target>property implementation must have its declaration in the category {$arg0}</target>
        </segment>
      </unit>
      <unit id="3278" name="err_bad_const_cast_dest">
        <segment>
          <source>%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member</source>
          <target>{$arg0 :select s0=|const_cast| s1=|| s2=|| s3=|| s4=|C-style cast| s5=|functional-style cast| s6=||} to {$arg2}, which is not a reference, pointer-to-object, or pointer-to-data-member</target>
        </segment>
      </unit>
      <unit id="3279" name="err_bad_cstyle_cast_overload">
        <segment>
          <source>address of overloaded function %0 cannot be cast to type %1</source>
          <target>address of overloaded function {$arg0} cannot be cast to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3280" name="err_bad_cxx_cast_addr_space_mismatch">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=|addrspace_cast|} from {$arg1} to {$arg2} converts between mismatching address spaces</target>
        </segment>
      </unit>
      <unit id="3281" name="err_bad_cxx_cast_bitfield">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from bit-field lvalue to reference type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3282" name="err_bad_cxx_cast_generic">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=|addrspace_cast|} from {$arg1} to {$arg2} is not allowed</target>
        </segment>
      </unit>
      <unit id="3283" name="err_bad_cxx_cast_member_pointer_size">
        <segment>
          <source>cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size</source>
          <target>cannot {$arg0 :select s0=|| s1=|| s2=|reinterpret_cast| s3=|| s4=|C-style cast| s5=|| s6=||} from member pointer type {$arg1} to member pointer type {$arg2} of different size</target>
        </segment>
      </unit>
      <unit id="3284" name="err_bad_cxx_cast_qualifiers_away">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2} casts away qualifiers</target>
        </segment>
      </unit>
      <unit id="3285" name="err_bad_cxx_cast_rvalue">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=|addrspace_cast|} from rvalue to reference type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3286" name="err_bad_cxx_cast_scalar_to_vector_different_size">
        <segment>
          <source>%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size</source>
          <target>{$arg0 :select s0=|| s1=|| s2=|reinterpret_cast| s3=|| s4=|C-style cast| s5=|| s6=||} from scalar {$arg1} to vector {$arg2} of different size</target>
        </segment>
      </unit>
      <unit id="3287" name="err_bad_cxx_cast_unrelated_class">
        <segment>
          <source>%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed</source>
          <target>{$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2}, which are not related by inheritance, is not allowed</target>
        </segment>
      </unit>
      <unit id="3288" name="err_bad_cxx_cast_vector_to_scalar_different_size">
        <segment>
          <source>%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size</source>
          <target>{$arg0 :select s0=|| s1=|| s2=|reinterpret_cast| s3=|| s4=|C-style cast| s5=|| s6=||} from vector {$arg1} to scalar {$arg2} of different size</target>
        </segment>
      </unit>
      <unit id="3289" name="err_bad_cxx_cast_vector_to_vector_different_size">
        <segment>
          <source>%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size</source>
          <target>{$arg0 :select s0=|| s1=|| s2=|reinterpret_cast| s3=|| s4=|C-style cast| s5=|| s6=||} from vector {$arg1} to vector {$arg2} of different size</target>
        </segment>
      </unit>
      <unit id="3290" name="err_bad_dynamic_cast_not_class">
        <segment>
          <source>%0 is not a class type</source>
          <target>{$arg0} is not a class type</target>
        </segment>
      </unit>
      <unit id="3291" name="err_bad_dynamic_cast_not_polymorphic">
        <segment>
          <source>%0 is not polymorphic</source>
          <target>{$arg0} is not polymorphic</target>
        </segment>
      </unit>
      <unit id="3292" name="err_bad_dynamic_cast_not_ptr">
        <segment>
          <source>cannot use dynamic_cast to convert from %0 to %1</source>
          <target>cannot use dynamic_cast to convert from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="3293" name="err_bad_dynamic_cast_not_ref_or_ptr">
        <segment>
          <source>invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class</source>
          <target>invalid target type {$arg0} for dynamic_cast; target type must be a reference or pointer type to a defined class</target>
        </segment>
      </unit>
      <unit id="3294" name="err_bad_kernel_param_type">
        <segment>
          <source>%0 cannot be used as the type of a kernel parameter</source>
          <target>{$arg0} cannot be used as the type of a kernel parameter</target>
        </segment>
      </unit>
      <unit id="3295" name="err_bad_lvalue_to_rvalue_cast">
        <segment>
          <source>cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible</source>
          <target>cannot cast from lvalue of type {$arg1} to rvalue reference type {$arg2}; types are not compatible</target>
        </segment>
      </unit>
      <unit id="3296" name="err_bad_memptr_lhs">
        <segment>
          <source>left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2</source>
          <target>left hand operand to {$arg0} must be a {$arg1 :select s0=|| s1=|pointer to |}class compatible with the right hand operand, but is {$arg2}</target>
        </segment>
      </unit>
      <unit id="3297" name="err_bad_memptr_rhs">
        <segment>
          <source>right hand operand to %0 has non-pointer-to-member type %1</source>
          <target>right hand operand to {$arg0} has non-pointer-to-member type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3298" name="err_bad_multiversion_option">
        <segment>
          <source>function multiversioning doesn't support %select{feature|architecture}0 '%1'</source>
          <target>function multiversioning doesn't support {$arg0 :select s0=|feature| s1=|architecture|} '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="3299" name="err_bad_new_type">
        <segment>
          <source>cannot allocate %select{function|reference}1 type %0 with new</source>
          <target>cannot allocate {$arg1 :select s0=|function| s1=|reference|} type {$arg0} with new</target>
        </segment>
      </unit>
      <unit id="3300" name="err_bad_parameter_name">
        <segment>
          <source>%0 cannot be the name of a parameter</source>
          <target>{$arg0} cannot be the name of a parameter</target>
        </segment>
      </unit>
      <unit id="3301" name="err_bad_parameter_name_template_id">
        <segment>
          <source>parameter name cannot have template arguments</source>
          <target>parameter name cannot have template arguments</target>
        </segment>
      </unit>
      <unit id="3302" name="err_bad_property_context">
        <segment>
          <source>property implementation must be in a class or category implementation</source>
          <target>property implementation must be in a class or category implementation</target>
        </segment>
      </unit>
      <unit id="3303" name="err_bad_property_decl">
        <segment>
          <source>property implementation must have its declaration in interface %0 or one of its extensions</source>
          <target>property implementation must have its declaration in interface {$arg0} or one of its extensions</target>
        </segment>
      </unit>
      <unit id="3304" name="err_bad_receiver_type">
        <segment>
          <source>bad receiver type %0</source>
          <target>bad receiver type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3305" name="err_bad_reinterpret_cast_overload">
        <segment>
          <source>reinterpret_cast cannot resolve overloaded function %0 to type %1</source>
          <target>reinterpret_cast cannot resolve overloaded function {$arg0} to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3306" name="err_bad_reinterpret_cast_reference">
        <segment>
          <source>reinterpret_cast of a %0 to %1 needs its address, which is not allowed</source>
          <target>reinterpret_cast of a {$arg0} to {$arg1} needs its address, which is not allowed</target>
        </segment>
      </unit>
      <unit id="3307" name="err_bad_reinterpret_cast_small_int">
        <segment>
          <source>cast from pointer to smaller type %2 loses information</source>
          <target>cast from pointer to smaller type {$arg2} loses information</target>
        </segment>
      </unit>
      <unit id="3308" name="err_bad_rvalue_to_rvalue_cast">
        <segment>
          <source>cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible</source>
          <target>cannot cast from rvalue of type {$arg1} to rvalue reference type {$arg2}; types are not compatible</target>
        </segment>
      </unit>
      <unit id="3309" name="err_bad_static_cast_member_pointer_nonmp">
        <segment>
          <source>cannot cast from type %1 to member pointer type %2</source>
          <target>cannot cast from type {$arg1} to member pointer type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3310" name="err_bad_static_cast_overload">
        <segment>
          <source>address of overloaded function %0 cannot be static_cast to type %1</source>
          <target>address of overloaded function {$arg0} cannot be static_cast to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3311" name="err_bad_static_cast_pointer_nonpointer">
        <segment>
          <source>cannot cast from type %1 to pointer type %2</source>
          <target>cannot cast from type {$arg1} to pointer type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3312" name="err_bad_variable_name">
        <segment>
          <source>%0 cannot be the name of a variable or data member</source>
          <target>{$arg0} cannot be the name of a variable or data member</target>
        </segment>
      </unit>
      <unit id="3313" name="err_base_class_has_flexible_array_member">
        <segment>
          <source>base class %0 has a flexible array member</source>
          <target>base class {$arg0} has a flexible array member</target>
        </segment>
      </unit>
      <unit id="3314" name="err_base_clause_on_union">
        <segment>
          <source>unions cannot have base classes</source>
          <target>unions cannot have base classes</target>
        </segment>
      </unit>
      <unit id="3315" name="err_base_init_direct_and_virtual">
        <segment>
          <source>base class initializer %0 names both a direct base class and an inherited virtual base class</source>
          <target>base class initializer {$arg0} names both a direct base class and an inherited virtual base class</target>
        </segment>
      </unit>
      <unit id="3316" name="err_base_init_does_not_name_class">
        <segment>
          <source>constructor initializer %0 does not name a class</source>
          <target>constructor initializer {$arg0} does not name a class</target>
        </segment>
      </unit>
      <unit id="3317" name="err_base_must_be_class">
        <segment>
          <source>base specifier must name a class</source>
          <target>base specifier must name a class</target>
        </segment>
      </unit>
      <unit id="3318" name="err_base_specifier_attribute">
        <segment>
          <source>%0%select{ attribute|}1 cannot be applied to a base specifier</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} cannot be applied to a base specifier</target>
        </segment>
      </unit>
      <unit id="3319" name="err_binding_cannot_appear_in_own_initializer">
        <segment>
          <source>binding %0 cannot appear in the initializer of its own decomposition declaration</source>
          <target>binding {$arg0} cannot appear in the initializer of its own decomposition declaration</target>
        </segment>
      </unit>
      <unit id="3320" name="err_bit_cast_non_trivially_copyable">
        <segment>
          <source state="initial">'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable</source>
          <target>'__builtin_bit_cast' {$arg0 :select s0=|source| s1=|destination|} type must be trivially copyable</target>
        </segment>
      </unit>
      <unit id="3321" name="err_bit_cast_type_size_mismatch">
        <segment>
          <source state="initial">size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)</source>
          <target>size of '__builtin_bit_cast' source type {$arg0} does not match destination type {$arg1} ({$arg2} vs {$arg3} bytes)</target>
        </segment>
      </unit>
      <unit id="3322" name="err_bit_int_bad_size">
        <segment>
          <source>%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0</source>
          <target>{$arg0 :select s0=|signed| s1=|unsigned|} _BitInt must have a bit size of at least {$arg0 :select s0=|2| s1=|1|}</target>
        </segment>
      </unit>
      <unit id="3323" name="err_bit_int_max_size">
        <segment>
          <source>%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported</source>
          <target>{$arg0 :select s0=|signed| s1=|unsigned|} _BitInt of bit sizes greater than {$arg1} not supported</target>
        </segment>
      </unit>
      <unit id="3324" name="err_bitfield_has_negative_width">
        <segment>
          <source>bit-field %0 has negative width (%1)</source>
          <target>bit-field {$arg0} has negative width ({$arg1})</target>
        </segment>
      </unit>
      <unit id="3325" name="err_bitfield_has_zero_width">
        <segment>
          <source>named bit-field %0 has zero width</source>
          <target>named bit-field {$arg0} has zero width</target>
        </segment>
      </unit>
      <unit id="3326" name="err_bitfield_too_wide">
        <segment>
          <source>%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)</source>
          <target>{$arg0 :select s0=|bit-field {$arg1}| s1=|anonymous bit-field|} is too wide ({$arg2} bits)</target>
        </segment>
      </unit>
      <unit id="3327" name="err_bitfield_width_exceeds_type_width">
        <segment>
          <source>width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)</source>
          <target>width of{$arg0 :select s0=| anonymous| s1=||} bit-field{$arg0 :select s0=|| s1=| {$arg1}|} ({$arg2} bits) exceeds the {$arg3 :select s0=|width| s1=|size|} of its type ({$arg4} bit%s4)</target>
        </segment>
      </unit>
      <unit id="3328" name="err_block_decl_ref_not_modifiable_lvalue">
        <segment>
          <source>variable is not assignable (missing __block type specifier)</source>
          <target>variable is not assignable (missing __block type specifier)</target>
        </segment>
      </unit>
      <unit id="3329" name="err_block_extern_cant_init">
        <segment>
          <source>declaration of block scope identifier with linkage cannot have an initializer</source>
          <target>declaration of block scope identifier with linkage cannot have an initializer</target>
        </segment>
      </unit>
      <unit id="3330" name="err_block_on_nonlocal">
        <segment>
          <source>__block attribute not allowed, only allowed on local variables</source>
          <target>__block attribute not allowed, only allowed on local variables</target>
        </segment>
      </unit>
      <unit id="3331" name="err_block_on_vm">
        <segment>
          <source>__block attribute not allowed on declaration with a variably modified type</source>
          <target>__block attribute not allowed on declaration with a variably modified type</target>
        </segment>
      </unit>
      <unit id="3332" name="err_block_return_missing_expr">
        <segment>
          <source>non-void block should return a value</source>
          <target>non-void block should return a value</target>
        </segment>
      </unit>
      <unit id="3333" name="err_block_returning_array_function">
        <segment>
          <source>block cannot return %select{array|function}0 type %1</source>
          <target>block cannot return {$arg0 :select s0=|array| s1=|function|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3334" name="err_blocks_disable">
        <segment>
          <source>blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0</source>
          <target>blocks support disabled - compile with -fblocks or {$arg0 :select s0=|pick a deployment target that supports them| s1=|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature|}</target>
        </segment>
      </unit>
      <unit id="3335" name="err_bound_member_function">
        <segment>
          <source>reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0</source>
          <target>reference to non-static member function must be called{$arg0 :select s0=|| s1=|; did you mean to call it with no arguments?|}</target>
        </segment>
      </unit>
      <unit id="3336" name="err_box_literal_collection">
        <segment>
          <source>%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection</source>
          <target>{$arg0 :select s0=|string| s1=|character| s2=|boolean| s3=|numeric|} literal must be prefixed by '@' in a collection</target>
        </segment>
      </unit>
      <unit id="3337" name="err_break_not_in_loop_or_switch">
        <segment>
          <source>'break' statement not in loop or switch statement</source>
          <target>'break' statement not in loop or switch statement</target>
        </segment>
      </unit>
      <unit id="3338" name="err_btf_type_id_not_const">
        <segment>
          <source>__builtin_btf_type_id argument %0 not a constant</source>
          <target>__builtin_btf_type_id argument {$arg0} not a constant</target>
        </segment>
      </unit>
      <unit id="3339" name="err_builtin_aix_os_unsupported">
        <segment>
          <source>this builtin is available only on AIX 7.2 and later operating systems</source>
          <target>this builtin is available only on AIX 7.2 and later operating systems</target>
        </segment>
      </unit>
      <unit id="3340" name="err_builtin_annotation_first_arg">
        <segment>
          <source>first argument to __builtin_annotation must be an integer</source>
          <target>first argument to __builtin_annotation must be an integer</target>
        </segment>
      </unit>
      <unit id="3341" name="err_builtin_annotation_second_arg">
        <segment>
          <source>second argument to __builtin_annotation must be a non-wide string constant</source>
          <target>second argument to __builtin_annotation must be a non-wide string constant</target>
        </segment>
      </unit>
      <unit id="3342" name="err_builtin_assume_aligned_invalid_arg">
        <segment>
          <source>non-pointer argument to '__builtin_assume_aligned' is not allowed</source>
          <target>non-pointer argument to '__builtin_assume_aligned' is not allowed</target>
        </segment>
      </unit>
      <unit id="3343" name="err_builtin_counted_by_ref_cannot_leak_reference">
        <segment>
          <source>value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0</source>
          <target>value returned by '__builtin_counted_by_ref' cannot be {$arg0 :select s0=|assigned to a variable| s1=|passed into a function| s2=|returned from a function|}</target>
        </segment>
      </unit>
      <unit id="3344" name="err_builtin_counted_by_ref_has_side_effects">
        <segment>
          <source>'__builtin_counted_by_ref' argument cannot have side-effects</source>
          <target>'__builtin_counted_by_ref' argument cannot have side-effects</target>
        </segment>
      </unit>
      <unit id="3345" name="err_builtin_counted_by_ref_invalid_use">
        <segment>
          <source>value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression</source>
          <target>value returned by '__builtin_counted_by_ref' cannot be used in {$arg0 :select s0=|an array subscript| s1=|a binary|} expression</target>
        </segment>
      </unit>
      <unit id="3346" name="err_builtin_counted_by_ref_must_be_flex_array_member">
        <segment>
          <source>'__builtin_counted_by_ref' argument must reference a flexible array member</source>
          <target>'__builtin_counted_by_ref' argument must reference a flexible array member</target>
        </segment>
      </unit>
      <unit id="3347" name="err_builtin_definition">
        <segment>
          <source>definition of builtin function %0</source>
          <target>definition of builtin function {$arg0}</target>
        </segment>
      </unit>
      <unit id="3348" name="err_builtin_fn_use">
        <segment>
          <source>builtin functions must be directly called</source>
          <target>builtin functions must be directly called</target>
        </segment>
      </unit>
      <unit id="3349" name="err_builtin_func_cast_more_than_one_arg">
        <segment>
          <source>function-style cast to a builtin type can only take one argument</source>
          <target>function-style cast to a builtin type can only take one argument</target>
        </segment>
      </unit>
      <unit id="3350" name="err_builtin_invalid_arg_type">
        <segment>
          <source state="initial">%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)</source>
          <target>%ordinal0 argument must be a {$arg1 :select s0=|| s1=|scalar| s2=|vector| s3=|matrix| s4=|vector of| s5=|scalar or vector of|}%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1{$arg2 :select s0=|| s1=|integer| s2=|signed integer| s3=|unsigned integer| s4=|'int'| s5=|pointer to a valid matrix element|}%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3{$arg3 :select s0=|| s1=|floating-point|}%plural{0:|: }3%plural{[0,3]:type|:types}1 (was {$arg4})</target>
        </segment>
      </unit>
      <unit id="3351" name="err_builtin_is_within_lifetime_invalid_arg">
        <segment>
          <source>%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed</source>
          <target>{$arg0 :select s0=|non-| s1=|function |}pointer argument to '__builtin_is_within_lifetime' is not allowed</target>
        </segment>
      </unit>
      <unit id="3352" name="err_builtin_launder_invalid_arg">
        <segment>
          <source>%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed</source>
          <target>{$arg0 :select s0=|non-pointer| s1=|function pointer| s2=|void pointer|} argument to '__builtin_launder' is not allowed</target>
        </segment>
      </unit>
      <unit id="3353" name="err_builtin_longjmp_invalid_val">
        <segment>
          <source>argument to __builtin_longjmp must be a constant 1</source>
          <target>argument to __builtin_longjmp must be a constant 1</target>
        </segment>
      </unit>
      <unit id="3354" name="err_builtin_longjmp_unsupported">
        <segment>
          <source>__builtin_longjmp is not supported for the current target</source>
          <target>__builtin_longjmp is not supported for the current target</target>
        </segment>
      </unit>
      <unit id="3355" name="err_builtin_matrix_disabled">
        <segment>
          <source>matrix types extension is disabled. Pass -fenable-matrix to enable it</source>
          <target>matrix types extension is disabled. Pass -fenable-matrix to enable it</target>
        </segment>
      </unit>
      <unit id="3356" name="err_builtin_matrix_invalid_dimension">
        <segment>
          <source>%0 dimension is outside the allowed range [1, %1]</source>
          <target>{$arg0} dimension is outside the allowed range [1, {$arg1}]</target>
        </segment>
      </unit>
      <unit id="3357" name="err_builtin_matrix_pointer_arg_mismatch">
        <segment>
          <source>the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)</source>
          <target>the pointee of the 2nd argument must match the element type of the 1st argument ({$arg0} != {$arg1})</target>
        </segment>
      </unit>
      <unit id="3358" name="err_builtin_matrix_scalar_unsigned_arg">
        <segment>
          <source>%0 argument must be a constant unsigned integer expression</source>
          <target>{$arg0} argument must be a constant unsigned integer expression</target>
        </segment>
      </unit>
      <unit id="3359" name="err_builtin_matrix_store_to_const">
        <segment>
          <source>cannot store matrix to read-only pointer</source>
          <target>cannot store matrix to read-only pointer</target>
        </segment>
      </unit>
      <unit id="3360" name="err_builtin_matrix_stride_too_small">
        <segment>
          <source>stride must be greater or equal to the number of rows</source>
          <target>stride must be greater or equal to the number of rows</target>
        </segment>
      </unit>
      <unit id="3361" name="err_builtin_move_forward_unsupported">
        <segment>
          <source>unsupported signature for %q0</source>
          <target>unsupported signature for {$arg0 :q}</target>
        </segment>
      </unit>
      <unit id="3362" name="err_builtin_non_vector_type">
        <segment>
          <source>%0 argument to %1 must be of vector type</source>
          <target>{$arg0} argument to {$arg1} must be of vector type</target>
        </segment>
      </unit>
      <unit id="3363" name="err_builtin_operator_new_delete_not_usual">
        <segment>
          <source>call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function</source>
          <target>call to '{$arg0 :select s0=|__builtin_operator_new| s1=|__builtin_operator_delete|}' selects non-usual {$arg0 :select s0=|allocation| s1=|deallocation|} function</target>
        </segment>
      </unit>
      <unit id="3364" name="err_builtin_pass_in_regs_non_class">
        <segment>
          <source>argument %0 is not an unqualified class type</source>
          <target>argument {$arg0} is not an unqualified class type</target>
        </segment>
      </unit>
      <unit id="3365" name="err_builtin_redeclare">
        <segment>
          <source>cannot redeclare builtin function %0</source>
          <target>cannot redeclare builtin function {$arg0}</target>
        </segment>
      </unit>
      <unit id="3366" name="err_builtin_requires_language">
        <segment>
          <source>'%0' is only available in %1</source>
          <target>'{$arg0}' is only available in {$arg1}</target>
        </segment>
      </unit>
      <unit id="3367" name="err_builtin_setjmp_unsupported">
        <segment>
          <source>__builtin_setjmp is not supported for the current target</source>
          <target>__builtin_setjmp is not supported for the current target</target>
        </segment>
      </unit>
      <unit id="3368" name="err_builtin_target_unsupported">
        <segment>
          <source>builtin is not supported on this target</source>
          <target>builtin is not supported on this target</target>
        </segment>
      </unit>
      <unit id="3369" name="err_builtin_trivially_relocate_invalid_arg_type">
        <segment>
          <source>first%select{||| and second}0 argument%select{|||s}0 to '__builtin_trivially_relocate' must be %select{a pointer|non-const|relocatable|of the same type}0</source>
          <target>first{$arg0 :select s0=|| s1=|| s2=|| s3=| and second|} argument{$arg0 :select s0=|| s1=|| s2=|| s3=|s|} to '__builtin_trivially_relocate' must be {$arg0 :select s0=|a pointer| s1=|non-const| s2=|relocatable| s3=|of the same type|}</target>
        </segment>
      </unit>
      <unit id="3370" name="err_builtin_verbose_trap_arg">
        <segment>
          <source>argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0</source>
          <target>argument to __builtin_verbose_trap must {$arg0 :select s0=|be a pointer to a constant string| s1=|not contain $|}</target>
        </segment>
      </unit>
      <unit id="3371" name="err_builtin_x64_aarch64_only">
        <segment>
          <source>this builtin is only available on x86-64 and aarch64 targets</source>
          <target>this builtin is only available on x86-64 and aarch64 targets</target>
        </segment>
      </unit>
      <unit id="3372" name="err_c23_constexpr_init_not_representable">
        <segment>
          <source>constexpr initializer evaluates to %0 which is not exactly representable in type %1</source>
          <target>constexpr initializer evaluates to {$arg0} which is not exactly representable in type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3373" name="err_c23_constexpr_init_type_mismatch">
        <segment>
          <source>constexpr initializer for type %0 is of type %1</source>
          <target>constexpr initializer for type {$arg0} is of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3374" name="err_c23_constexpr_invalid_type">
        <segment>
          <source>constexpr variable cannot have type %0</source>
          <target>constexpr variable cannot have type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3375" name="err_c23_constexpr_not_variable">
        <segment>
          <source>'constexpr' can only be used in variable declarations</source>
          <target>'constexpr' can only be used in variable declarations</target>
        </segment>
      </unit>
      <unit id="3376" name="err_c23_constexpr_pointer_not_null">
        <segment>
          <source>constexpr pointer initializer is not null</source>
          <target>constexpr pointer initializer is not null</target>
        </segment>
      </unit>
      <unit id="3377" name="err_c99_array_usage_cxx">
        <segment>
          <source>%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++</source>
          <target>{$arg0 :select s0=|qualifier in | s1=|static | s2=||}array size {$arg0 :select s0=|| s1=|| s2=|'[*] '|}is a C99 feature, not permitted in C++</target>
        </segment>
      </unit>
      <unit id="3378" name="err_call_function_incomplete_return">
        <segment>
          <source>calling %0 with incomplete return type %1</source>
          <target>calling {$arg0} with incomplete return type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3379" name="err_call_incomplete_argument">
        <segment>
          <source>argument type %0 is incomplete</source>
          <target>argument type {$arg0} is incomplete</target>
        </segment>
      </unit>
      <unit id="3380" name="err_call_incomplete_return">
        <segment>
          <source>calling function with incomplete return type %0</source>
          <target>calling function with incomplete return type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3381" name="err_callback_attribute_argument_unknown">
        <segment>
          <source>'callback' attribute argument %0 is not a known function parameter</source>
          <target>'callback' attribute argument {$arg0} is not a known function parameter</target>
        </segment>
      </unit>
      <unit id="3382" name="err_callback_attribute_invalid_callee">
        <segment>
          <source>'callback' attribute specifies invalid callback callee</source>
          <target>'callback' attribute specifies invalid callback callee</target>
        </segment>
      </unit>
      <unit id="3383" name="err_callback_attribute_multiple">
        <segment>
          <source>multiple 'callback' attributes specified</source>
          <target>multiple 'callback' attributes specified</target>
        </segment>
      </unit>
      <unit id="3384" name="err_callback_attribute_no_callee">
        <segment>
          <source>'callback' attribute specifies no callback callee</source>
          <target>'callback' attribute specifies no callback callee</target>
        </segment>
      </unit>
      <unit id="3385" name="err_callback_attribute_wrong_arg_count">
        <segment>
          <source>'callback' attribute references function of type %0 which expects %1 %plural{1:argument|:arguments}1 but attribute specifies %2 parameter index %plural{1:argument|:arguments}2</source>
          <target>'callback' attribute references function of type {$arg0} which expects {$arg1} %plural{1:argument|:arguments}1 but attribute specifies {$arg2} parameter index %plural{1:argument|:arguments}2</target>
        </segment>
      </unit>
      <unit id="3386" name="err_callback_callee_is_variadic">
        <segment>
          <source>'callback' attribute callee may not be variadic</source>
          <target>'callback' attribute callee may not be variadic</target>
        </segment>
      </unit>
      <unit id="3387" name="err_callback_callee_no_function_type">
        <segment>
          <source>'callback' attribute callee does not have function type</source>
          <target>'callback' attribute callee does not have function type</target>
        </segment>
      </unit>
      <unit id="3388" name="err_callback_implicit_this_not_available">
        <segment>
          <source>'callback' argument at position %0 references unavailable implicit 'this'</source>
          <target>'callback' argument at position {$arg0} references unavailable implicit 'this'</target>
        </segment>
      </unit>
      <unit id="3389" name="err_called_once_attribute_wrong_type">
        <segment>
          <source>'called_once' attribute only applies to function-like parameters</source>
          <target>'called_once' attribute only applies to function-like parameters</target>
        </segment>
      </unit>
      <unit id="3390" name="err_cannot_find_suitable_accessor">
        <segment>
          <source>cannot find suitable %select{getter|setter}0 for property %1</source>
          <target>cannot find suitable {$arg0 :select s0=|getter| s1=|setter|} for property {$arg1}</target>
        </segment>
      </unit>
      <unit id="3391" name="err_cannot_form_pointer_to_member_of_reference_type">
        <segment>
          <source>cannot form a pointer-to-member to member %0 of reference type %1</source>
          <target>cannot form a pointer-to-member to member {$arg0} of reference type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3392" name="err_cannot_pass_non_trivial_c_struct_to_vararg">
        <segment>
          <source>cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1</source>
          <target>cannot pass non-trivial C object of type {$arg0} by value to variadic {$arg1 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}</target>
        </segment>
      </unit>
      <unit id="3393" name="err_cannot_pass_objc_interface_to_vararg">
        <segment>
          <source>cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1</source>
          <target>cannot pass object with interface type {$arg0} by value through variadic {$arg1 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}</target>
        </segment>
      </unit>
      <unit id="3394" name="err_cannot_pass_objc_interface_to_vararg_format">
        <segment>
          <source>cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3</source>
          <target>cannot pass object with interface type {$arg1} by value to variadic {$arg2 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}; expected type from format string was {$arg3}</target>
        </segment>
      </unit>
      <unit id="3395" name="err_cannot_pass_to_vararg">
        <segment>
          <source>cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2</source>
          <target>cannot pass {$arg0 :select s0=|expression of type {$arg1}| s1=|initializer list|} to variadic {$arg2 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}</target>
        </segment>
      </unit>
      <unit id="3396" name="err_cannot_pass_to_vararg_format">
        <segment>
          <source>cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3</source>
          <target>cannot pass {$arg0 :select s0=|expression of type {$arg1}| s1=|initializer list|} to variadic {$arg2 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}; expected type from format string was {$arg3}</target>
        </segment>
      </unit>
      <unit id="3397" name="err_capture_bad_target">
        <segment>
          <source>capture host variable %0 by reference in device or host device lambda function</source>
          <target>capture host variable {$arg0} by reference in device or host device lambda function</target>
        </segment>
      </unit>
      <unit id="3398" name="err_capture_binding_openmp">
        <segment>
          <source>capturing a structured binding is not yet supported in OpenMP</source>
          <target>capturing a structured binding is not yet supported in OpenMP</target>
        </segment>
      </unit>
      <unit id="3399" name="err_capture_block_variable">
        <segment>
          <source>__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1</source>
          <target>__block variable {$arg0} cannot be captured in a {$arg1 :select s0=|lambda expression| s1=|captured statement|}</target>
        </segment>
      </unit>
      <unit id="3400" name="err_capture_by_attribute_argument_unknown">
        <segment>
          <source>'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'</source>
          <target>'lifetime_capture_by' attribute argument {$arg0} is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'</target>
        </segment>
      </unit>
      <unit id="3401" name="err_capture_by_attribute_multiple">
        <segment>
          <source>multiple 'lifetime_capture' attributes specified</source>
          <target>multiple 'lifetime_capture' attributes specified</target>
        </segment>
      </unit>
      <unit id="3402" name="err_capture_by_attribute_no_entity">
        <segment>
          <source>'lifetime_capture_by' attribute specifies no capturing entity</source>
          <target>'lifetime_capture_by' attribute specifies no capturing entity</target>
        </segment>
      </unit>
      <unit id="3403" name="err_capture_by_implicit_this_not_available">
        <segment>
          <source>'lifetime_capture_by' argument references unavailable implicit 'this'</source>
          <target>'lifetime_capture_by' argument references unavailable implicit 'this'</target>
        </segment>
      </unit>
      <unit id="3404" name="err_capture_by_param_uses_reserved_name">
        <segment>
          <source>parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'</source>
          <target>parameter cannot be named '{$arg0 :select s0=|global| s1=|unknown|}' while using 'lifetime_capture_by({$arg0 :select s0=|global| s1=|unknown|})'</target>
        </segment>
      </unit>
      <unit id="3405" name="err_capture_by_references_itself">
        <segment>
          <source>'lifetime_capture_by' argument references itself</source>
          <target>'lifetime_capture_by' argument references itself</target>
        </segment>
      </unit>
      <unit id="3406" name="err_capture_class_member_does_not_name_variable">
        <segment>
          <source>class member %0 cannot appear in capture list as it is not a variable</source>
          <target>class member {$arg0} cannot appear in capture list as it is not a variable</target>
        </segment>
      </unit>
      <unit id="3407" name="err_capture_default_non_local">
        <segment>
          <source>non-local lambda expression cannot have a capture-default</source>
          <target>non-local lambda expression cannot have a capture-default</target>
        </segment>
      </unit>
      <unit id="3408" name="err_capture_does_not_name_variable">
        <segment>
          <source>%0 in capture list does not name a variable</source>
          <target>{$arg0} in capture list does not name a variable</target>
        </segment>
      </unit>
      <unit id="3409" name="err_capture_more_than_once">
        <segment>
          <source>%0 can appear only once in a capture list</source>
          <target>{$arg0} can appear only once in a capture list</target>
        </segment>
      </unit>
      <unit id="3410" name="err_capture_non_automatic_variable">
        <segment>
          <source>%0 cannot be captured because it does not have automatic storage duration</source>
          <target>{$arg0} cannot be captured because it does not have automatic storage duration</target>
        </segment>
      </unit>
      <unit id="3411" name="err_capture_of_abstract_type">
        <segment>
          <source>by-copy capture of value of abstract type %0</source>
          <target>by-copy capture of value of abstract type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3412" name="err_capture_of_incomplete_or_sizeless_type">
        <segment>
          <source>by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2</source>
          <target>by-copy capture of variable {$arg0} with {$arg1 :select s0=|incomplete| s1=|sizeless|} type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3413" name="err_carries_dependency_missing_on_first_decl">
        <segment>
          <source>%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration</source>
          <target>{$arg0 :select s0=|function| s1=|parameter|} declared '[[carries_dependency]]' after its first declaration</target>
        </segment>
      </unit>
      <unit id="3414" name="err_carries_dependency_param_not_function_decl">
        <segment>
          <source>'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda</source>
          <target>'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda</target>
        </segment>
      </unit>
      <unit id="3415" name="err_case_not_in_switch">
        <segment>
          <source>'case' statement not in switch statement</source>
          <target>'case' statement not in switch statement</target>
        </segment>
      </unit>
      <unit id="3416" name="err_cast_from_randomized_struct">
        <segment>
          <source>casting from randomized structure pointer type %0 to %1</source>
          <target>casting from randomized structure pointer type {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="3417" name="err_cast_pointer_from_non_pointer_int">
        <segment>
          <source>operand of type %0 cannot be cast to a pointer type</source>
          <target>operand of type {$arg0} cannot be cast to a pointer type</target>
        </segment>
      </unit>
      <unit id="3418" name="err_cast_pointer_to_non_pointer_int">
        <segment>
          <source>pointer cannot be cast to type %0</source>
          <target>pointer cannot be cast to type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3419" name="err_cast_selector_expr">
        <segment>
          <source>cannot type cast @selector expression</source>
          <target>cannot type cast @selector expression</target>
        </segment>
      </unit>
      <unit id="3420" name="err_catch_incomplete">
        <segment>
          <source>cannot catch incomplete type %0</source>
          <target>cannot catch incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3421" name="err_catch_incomplete_ptr">
        <segment>
          <source>cannot catch pointer to incomplete type %0</source>
          <target>cannot catch pointer to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3422" name="err_catch_incomplete_ref">
        <segment>
          <source>cannot catch reference to incomplete type %0</source>
          <target>cannot catch reference to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3423" name="err_catch_param_not_objc_type">
        <segment>
          <source>@catch parameter is not a pointer to an interface type</source>
          <target>@catch parameter is not a pointer to an interface type</target>
        </segment>
      </unit>
      <unit id="3424" name="err_catch_rvalue_ref">
        <segment>
          <source>cannot catch exceptions by rvalue reference</source>
          <target>cannot catch exceptions by rvalue reference</target>
        </segment>
      </unit>
      <unit id="3425" name="err_catch_sizeless">
        <segment>
          <source>cannot catch %select{|reference to }0sizeless type %1</source>
          <target>cannot catch {$arg0 :select s0=|| s1=|reference to |}sizeless type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3426" name="err_catch_variably_modified">
        <segment>
          <source>cannot catch variably modified type %0</source>
          <target>cannot catch variably modified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3427" name="err_category_forward_interface">
        <segment>
          <source>cannot define %select{category|class extension}0 for undefined class %1</source>
          <target>cannot define {$arg0 :select s0=|category| s1=|class extension|} for undefined class {$arg1}</target>
        </segment>
      </unit>
      <unit id="3428" name="err_category_property">
        <segment>
          <source>property declared in category %0 cannot be implemented in class implementation</source>
          <target>property declared in category {$arg0} cannot be implemented in class implementation</target>
        </segment>
      </unit>
      <unit id="3429" name="err_cconv_change">
        <segment>
          <source>function declared '%0' here was previously declared %select{'%2'|without calling convention}1</source>
          <target>function declared '{$arg0}' here was previously declared {$arg1 :select s0=|'{$arg2}'| s1=|without calling convention|}</target>
        </segment>
      </unit>
      <unit id="3430" name="err_cconv_incomplete_param_type">
        <segment>
          <source>parameter %0 must have a complete type to use function %1 with the %2 calling convention</source>
          <target>parameter {$arg0} must have a complete type to use function {$arg1} with the {$arg2} calling convention</target>
        </segment>
      </unit>
      <unit id="3431" name="err_cconv_knr">
        <segment>
          <source>function with no prototype cannot use the %0 calling convention</source>
          <target>function with no prototype cannot use the {$arg0} calling convention</target>
        </segment>
      </unit>
      <unit id="3432" name="err_cconv_varargs">
        <segment>
          <source>variadic function cannot use %0 calling convention</source>
          <target>variadic function cannot use {$arg0} calling convention</target>
        </segment>
      </unit>
      <unit id="3433" name="err_cfstring_literal_not_string_constant">
        <segment>
          <source>CFString literal is not a string constant</source>
          <target>CFString literal is not a string constant</target>
        </segment>
      </unit>
      <unit id="3434" name="err_class_extension_after_impl">
        <segment>
          <source>cannot declare class extension for %0 after class implementation</source>
          <target>cannot declare class extension for {$arg0} after class implementation</target>
        </segment>
      </unit>
      <unit id="3435" name="err_class_marked_final_used_as_base">
        <segment>
          <source>base %0 is marked '%select{final|sealed}1'</source>
          <target>base {$arg0} is marked '{$arg1 :select s0=|final| s1=|sealed|}'</target>
        </segment>
      </unit>
      <unit id="3436" name="err_class_property_found">
        <segment>
          <source>property %0 is a class property; did you mean to access it with class '%1'?</source>
          <target>property {$arg0} is a class property; did you mean to access it with class '{$arg1}'?</target>
        </segment>
      </unit>
      <unit id="3437" name="err_class_redeclared_with_different_access">
        <segment>
          <source>%0 redeclared with '%1' access</source>
          <target>{$arg0} redeclared with '{$arg1}' access</target>
        </segment>
      </unit>
      <unit id="3438" name="err_class_stub_subclassing_mismatch">
        <segment>
          <source>'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute</source>
          <target>'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute</target>
        </segment>
      </unit>
      <unit id="3439" name="err_cocoa_naming_owned_rule">
        <segment>
          <source>property follows Cocoa naming convention for returning 'owned' objects</source>
          <target>property follows Cocoa naming convention for returning 'owned' objects</target>
        </segment>
      </unit>
      <unit id="3440" name="err_collection_expr_type">
        <segment>
          <source>the type %0 is not a pointer to a fast-enumerable object</source>
          <target>the type {$arg0} is not a pointer to a fast-enumerable object</target>
        </segment>
      </unit>
      <unit id="3441" name="err_complex_mode_vector_type">
        <segment>
          <source>type of machine mode does not support base vector types</source>
          <target>type of machine mode does not support base vector types</target>
        </segment>
      </unit>
      <unit id="3442" name="err_compound_literal_with_address_space">
        <segment>
          <source>compound literal in function scope may not be qualified with an address space</source>
          <target>compound literal in function scope may not be qualified with an address space</target>
        </segment>
      </unit>
      <unit id="3443" name="err_compound_literal_with_vla_type">
        <segment>
          <source>compound literal cannot be of variable-length array type</source>
          <target>compound literal cannot be of variable-length array type</target>
        </segment>
      </unit>
      <unit id="3444" name="err_compound_qualified_function_type">
        <segment>
          <source>%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier</source>
          <target>{$arg0 :select s0=|block pointer| s1=|pointer| s2=|reference|} to function type {$arg1 :select s0=|{$arg2} | s1=||}cannot have '{$arg3}' qualifier</target>
        </segment>
      </unit>
      <unit id="3445" name="err_computed_type_in_declarative_nns">
        <segment>
          <source>a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier</source>
          <target>a {$arg0 :select s0=|pack indexing| s1=|'decltype'|} specifier cannot be used in a declarative nested name specifier</target>
        </segment>
      </unit>
      <unit id="3446" name="err_concept_decls_may_only_appear_in_global_namespace_scope">
        <segment>
          <source>concept declarations may only appear in global or namespace scope</source>
          <target>concept declarations may only appear in global or namespace scope</target>
        </segment>
      </unit>
      <unit id="3447" name="err_concept_extra_headers">
        <segment>
          <source>extraneous template parameter list in concept definition</source>
          <target>extraneous template parameter list in concept definition</target>
        </segment>
      </unit>
      <unit id="3448" name="err_concept_no_associated_constraints">
        <segment>
          <source>concept cannot have associated constraints</source>
          <target>concept cannot have associated constraints</target>
        </segment>
      </unit>
      <unit id="3449" name="err_concept_no_parameters">
        <segment>
          <source>concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed</source>
          <target>concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed</target>
        </segment>
      </unit>
      <unit id="3450" name="err_cond_voidptr_arc">
        <segment>
          <source>operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode</source>
          <target>operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode</target>
        </segment>
      </unit>
      <unit id="3451" name="err_conditional_ambiguous">
        <segment>
          <source>conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1</source>
          <target>conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1</target>
        </segment>
      </unit>
      <unit id="3452" name="err_conditional_ambiguous_ovl">
        <segment>
          <source>conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types</source>
          <target>conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types</target>
        </segment>
      </unit>
      <unit id="3453" name="err_conditional_vector_cond_result_mismatch">
        <segment>
          <source>cannot mix vectors and extended vectors in a vector conditional</source>
          <target>cannot mix vectors and extended vectors in a vector conditional</target>
        </segment>
      </unit>
      <unit id="3454" name="err_conditional_vector_element_size">
        <segment>
          <source>vector condition type %0 and result type %1 do not have elements of the same size</source>
          <target>vector condition type {$arg0} and result type {$arg1} do not have elements of the same size</target>
        </segment>
      </unit>
      <unit id="3455" name="err_conditional_vector_has_void">
        <segment>
          <source>GNU vector conditional operand cannot be %select{void|a throw expression}0</source>
          <target>GNU vector conditional operand cannot be {$arg0 :select s0=|void| s1=|a throw expression|}</target>
        </segment>
      </unit>
      <unit id="3456" name="err_conditional_vector_mismatched">
        <segment>
          <source>vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}</source>
          <target>vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}</target>
        </segment>
      </unit>
      <unit id="3457" name="err_conditional_vector_operand_type">
        <segment>
          <source>enumeration type %0 is not allowed in a vector conditional</source>
          <target>enumeration type {$arg0} is not allowed in a vector conditional</target>
        </segment>
      </unit>
      <unit id="3458" name="err_conditional_vector_size">
        <segment>
          <source>vector condition type %0 and result type %1 do not have the same number of elements</source>
          <target>vector condition type {$arg0} and result type {$arg1} do not have the same number of elements</target>
        </segment>
      </unit>
      <unit id="3459" name="err_conditional_void_nonvoid">
        <segment>
          <source>%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0</source>
          <target>{$arg1 :select s0=|left| s1=|right|} operand to ? is void, but {$arg1 :select s0=|right| s1=|left|} operand is of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3460" name="err_config_scalar_return">
        <segment>
          <source>CUDA special function '%0' must have scalar return type</source>
          <target>CUDA special function '{$arg0}' must have scalar return type</target>
        </segment>
      </unit>
      <unit id="3461" name="err_conflicting_aliasing_type">
        <segment>
          <source>conflicting types for alias %0</source>
          <target>conflicting types for alias {$arg0}</target>
        </segment>
      </unit>
      <unit id="3462" name="err_conflicting_aligned_options">
        <segment>
          <source>conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'</source>
          <target>conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'</target>
        </segment>
      </unit>
      <unit id="3463" name="err_conflicting_attributes_arm_agnostic">
        <segment>
          <source>__arm_agnostic("sme_za_state") cannot share ZA state with its caller</source>
          <target>__arm_agnostic("sme_za_state") cannot share ZA state with its caller</target>
        </segment>
      </unit>
      <unit id="3464" name="err_conflicting_attributes_arm_state">
        <segment>
          <source>conflicting attributes for state '%0'</source>
          <target>conflicting attributes for state '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3465" name="err_conflicting_codeseg_attribute">
        <segment>
          <source>conflicting code segment specifiers</source>
          <target>conflicting code segment specifiers</target>
        </segment>
      </unit>
      <unit id="3466" name="err_conflicting_ivar_bitwidth">
        <segment>
          <source>instance variable %0 has conflicting bit-field width</source>
          <target>instance variable {$arg0} has conflicting bit-field width</target>
        </segment>
      </unit>
      <unit id="3467" name="err_conflicting_ivar_name">
        <segment>
          <source>conflicting instance variable names: %0 vs %1</source>
          <target>conflicting instance variable names: {$arg0} vs {$arg1}</target>
        </segment>
      </unit>
      <unit id="3468" name="err_conflicting_ivar_type">
        <segment>
          <source>instance variable %0 has conflicting type%diff{: $ vs $|}1,2</source>
          <target>instance variable {$arg0} has conflicting type%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="3469" name="err_conflicting_overriding_attributes">
        <segment>
          <source>virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2</source>
          <target>virtual function {$arg0} has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2</target>
        </segment>
      </unit>
      <unit id="3470" name="err_conflicting_overriding_cc_attributes">
        <segment>
          <source>virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2</source>
          <target>virtual function {$arg0} has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2</target>
        </segment>
      </unit>
      <unit id="3471" name="err_conflicting_super_class">
        <segment>
          <source>conflicting super class name %0</source>
          <target>conflicting super class name {$arg0}</target>
        </segment>
      </unit>
      <unit id="3472" name="err_conflicting_types">
        <segment>
          <source>conflicting types for %0</source>
          <target>conflicting types for {$arg0}</target>
        </segment>
      </unit>
      <unit id="3473" name="err_constant_integer_arg_type">
        <segment>
          <source>argument to %0 must be a constant integer</source>
          <target>argument to {$arg0} must be a constant integer</target>
        </segment>
      </unit>
      <unit id="3474" name="err_consteval_override">
        <segment>
          <source>consteval function %0 cannot override a non-consteval function</source>
          <target>consteval function {$arg0} cannot override a non-consteval function</target>
        </segment>
      </unit>
      <unit id="3475" name="err_constexpr_body_invalid_stmt">
        <segment>
          <source>statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0</source>
          <target>statement not allowed in {$arg1 :select s0=|constexpr| s1=|consteval|} {$arg0 :select s0=|function| s1=|constructor|}</target>
        </segment>
      </unit>
      <unit id="3476" name="err_constexpr_body_no_return">
        <segment>
          <source>no return statement in %select{constexpr|consteval}0 function</source>
          <target>no return statement in {$arg0 :select s0=|constexpr| s1=|consteval|} function</target>
        </segment>
      </unit>
      <unit id="3477" name="err_constexpr_dtor">
        <segment>
          <source>destructor cannot be declared %select{&lt;ERROR&gt;|constexpr|consteval|constinit}0</source>
          <target>destructor cannot be declared {$arg0 :select s0=|&lt;ERROR&gt;| s1=|constexpr| s2=|consteval| s3=|constinit|}</target>
        </segment>
      </unit>
      <unit id="3478" name="err_constexpr_dtor_subobject">
        <segment>
          <source>destructor cannot be declared %select{&lt;ERROR&gt;|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor</source>
          <target>destructor cannot be declared {$arg0 :select s0=|&lt;ERROR&gt;| s1=|constexpr| s2=|consteval| s3=|constinit|} because {$arg1 :select s0=|data member {$arg2}| s1=|base class {$arg3}|} does not have a constexpr destructor</target>
        </segment>
      </unit>
      <unit id="3479" name="err_constexpr_if_condition_expression_is_not_constant">
        <segment>
          <source>constexpr if condition is not a constant expression</source>
          <target>constexpr if condition is not a constant expression</target>
        </segment>
      </unit>
      <unit id="3480" name="err_constexpr_local_var_non_literal_type">
        <segment>
          <source>variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23</source>
          <target>variable of non-literal type {$arg1} cannot be defined in a constexpr {$arg0 :select s0=|function| s1=|constructor|} before C++23</target>
        </segment>
      </unit>
      <unit id="3481" name="err_constexpr_main">
        <segment>
          <source>'main' is not allowed to be declared %select{constexpr|consteval}0</source>
          <target>'main' is not allowed to be declared {$arg0 :select s0=|constexpr| s1=|consteval|}</target>
        </segment>
      </unit>
      <unit id="3482" name="err_constexpr_non_literal_param">
        <segment>
          <source>%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type</source>
          <target>{$arg2 :select s0=|constexpr| s1=|consteval|} {$arg1 :select s0=|function| s1=|constructor|}'s %ordinal0 parameter type {$arg3} is not a literal type</target>
        </segment>
      </unit>
      <unit id="3483" name="err_constexpr_non_literal_return">
        <segment>
          <source>%select{constexpr|consteval}0 function's return type %1 is not a literal type</source>
          <target>{$arg0 :select s0=|constexpr| s1=|consteval|} function's return type {$arg1} is not a literal type</target>
        </segment>
      </unit>
      <unit id="3484" name="err_constexpr_redecl_mismatch">
        <segment>
          <source>%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration</source>
          <target>{$arg1 :select s0=|non-constexpr| s1=|constexpr| s2=|consteval|} declaration of {$arg0} follows {$arg2 :select s0=|non-constexpr| s1=|constexpr| s2=|consteval|} declaration</target>
        </segment>
      </unit>
      <unit id="3485" name="err_constexpr_return_missing_expr">
        <segment>
          <source>non-void %select{constexpr|consteval}1 function %0 should return a value</source>
          <target>non-void {$arg1 :select s0=|constexpr| s1=|consteval|} function {$arg0} should return a value</target>
        </segment>
      </unit>
      <unit id="3486" name="err_constexpr_static_mem_var_requires_init">
        <segment>
          <source>declaration of constexpr static data member %0 requires an initializer</source>
          <target>declaration of constexpr static data member {$arg0} requires an initializer</target>
        </segment>
      </unit>
      <unit id="3487" name="err_constexpr_tag">
        <segment>
          <source>%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{&lt;ERROR&gt;|constexpr|consteval|constinit}1</source>
          <target>{$arg0 :select s0=|class| s1=|struct| s2=|interface| s3=|union| s4=|enum| s5=|enum class| s6=|enum struct|} cannot be marked {$arg1 :select s0=|&lt;ERROR&gt;| s1=|constexpr| s2=|consteval| s3=|constinit|}</target>
        </segment>
      </unit>
      <unit id="3488" name="err_constexpr_var_non_literal">
        <segment>
          <source>constexpr variable cannot have non-literal type %0</source>
          <target>constexpr variable cannot have non-literal type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3489" name="err_constexpr_var_requires_const_destruction">
        <segment>
          <source>constexpr variable %0 must have constant destruction</source>
          <target>constexpr variable {$arg0} must have constant destruction</target>
        </segment>
      </unit>
      <unit id="3490" name="err_constexpr_var_requires_const_init">
        <segment>
          <source>constexpr variable %0 must be initialized by a constant expression</source>
          <target>constexpr variable {$arg0} must be initialized by a constant expression</target>
        </segment>
      </unit>
      <unit id="3491" name="err_constexpr_virtual">
        <segment>
          <source>virtual function cannot be constexpr</source>
          <target>virtual function cannot be constexpr</target>
        </segment>
      </unit>
      <unit id="3492" name="err_constexpr_virtual_base">
        <segment>
          <source>constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2</source>
          <target>constexpr {$arg0 :select s0=|member function| s1=|constructor|} not allowed in {$arg1 :select s0=|struct| s1=|interface| s2=|class|} with virtual base %plural{1:class|:classes}2</target>
        </segment>
      </unit>
      <unit id="3493" name="err_constexpr_vla">
        <segment>
          <source>variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1</source>
          <target>variably-modified type {$arg0} cannot be used in a constexpr {$arg1 :select s0=|function| s1=|constructor|}</target>
        </segment>
      </unit>
      <unit id="3494" name="err_constexpr_wrong_decl_kind">
        <segment>
          <source>%select{&lt;ERROR&gt;|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations</source>
          <target>{$arg0 :select s0=|&lt;ERROR&gt;| s1=|constexpr| s2=|consteval| s3=|constinit|} can only be used in {$arg0 :select s0=|| s1=|variable and function| s2=|function| s3=|variable|} declarations</target>
        </segment>
      </unit>
      <unit id="3495" name="err_constinit_added_too_late">
        <segment>
          <source>'constinit' specifier added after initialization of variable</source>
          <target>'constinit' specifier added after initialization of variable</target>
        </segment>
      </unit>
      <unit id="3496" name="err_constinit_local_variable">
        <segment>
          <source>local variable cannot be declared 'constinit'</source>
          <target>local variable cannot be declared 'constinit'</target>
        </segment>
      </unit>
      <unit id="3497" name="err_constrained_non_templated_function">
        <segment>
          <source>non-templated function cannot have a requires clause</source>
          <target>non-templated function cannot have a requires clause</target>
        </segment>
      </unit>
      <unit id="3498" name="err_constrained_virtual_method">
        <segment>
          <source>virtual function cannot have a requires clause</source>
          <target>virtual function cannot have a requires clause</target>
        </segment>
      </unit>
      <unit id="3499" name="err_constraint_depends_on_self">
        <segment>
          <source state="initial">satisfaction of constraint %0 depends on itself</source>
          <target>satisfaction of constraint {$arg0} depends on itself</target>
        </segment>
      </unit>
      <unit id="3500" name="err_constructor_byvalue_arg">
        <segment>
          <source>copy constructor must pass its first argument by reference</source>
          <target>copy constructor must pass its first argument by reference</target>
        </segment>
      </unit>
      <unit id="3501" name="err_constructor_cannot_be">
        <segment>
          <source>constructor cannot be declared '%0'</source>
          <target>constructor cannot be declared '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3502" name="err_constructor_redeclared">
        <segment>
          <source>constructor cannot be redeclared</source>
          <target>constructor cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="3503" name="err_constructor_return_type">
        <segment>
          <source>constructor cannot have a return type</source>
          <target>constructor cannot have a return type</target>
        </segment>
      </unit>
      <unit id="3504" name="err_continuation_class">
        <segment>
          <source>class extension has no primary class</source>
          <target>class extension has no primary class</target>
        </segment>
      </unit>
      <unit id="3505" name="err_continue_from_cond_var_init">
        <segment>
          <source>cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable</source>
          <target>cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable</target>
        </segment>
      </unit>
      <unit id="3506" name="err_continue_not_in_loop">
        <segment>
          <source>'continue' statement not in loop statement</source>
          <target>'continue' statement not in loop statement</target>
        </segment>
      </unit>
      <unit id="3507" name="err_conv_function_not_member">
        <segment>
          <source>conversion function must be a non-static member function</source>
          <target>conversion function must be a non-static member function</target>
        </segment>
      </unit>
      <unit id="3508" name="err_conv_function_redeclared">
        <segment>
          <source>conversion function cannot be redeclared</source>
          <target>conversion function cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="3509" name="err_conv_function_return_type">
        <segment>
          <source>conversion function cannot have a return type</source>
          <target>conversion function cannot have a return type</target>
        </segment>
      </unit>
      <unit id="3510" name="err_conv_function_to_array">
        <segment>
          <source>conversion function cannot convert to an array type</source>
          <target>conversion function cannot convert to an array type</target>
        </segment>
      </unit>
      <unit id="3511" name="err_conv_function_to_function">
        <segment>
          <source>conversion function cannot convert to a function type</source>
          <target>conversion function cannot convert to a function type</target>
        </segment>
      </unit>
      <unit id="3512" name="err_conv_function_variadic">
        <segment>
          <source>conversion function cannot be variadic</source>
          <target>conversion function cannot be variadic</target>
        </segment>
      </unit>
      <unit id="3513" name="err_conv_function_with_complex_decl">
        <segment>
          <source>cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0</source>
          <target>cannot specify any part of a return type in the declaration of a conversion function{$arg0 :select s0=|; put the complete type after 'operator'| s1=|; use a typedef to declare a conversion to {$arg1}| s2=|; use an alias template to declare a conversion to {$arg1}| s3=||}</target>
        </segment>
      </unit>
      <unit id="3514" name="err_conv_function_with_params">
        <segment>
          <source>conversion function cannot have any parameters</source>
          <target>conversion function cannot have any parameters</target>
        </segment>
      </unit>
      <unit id="3515" name="err_conv_mixed_enum_types">
        <segment>
          <source>invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>invalid {$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="3516" name="err_convertvector_constexpr_unsupported_vector_cast">
        <segment>
          <source>unsupported vector cast from %0 to %1 in a constant expression</source>
          <target>unsupported vector cast from {$arg0} to {$arg1} in a constant expression</target>
        </segment>
      </unit>
      <unit id="3517" name="err_convertvector_incompatible_vector">
        <segment>
          <source>first two arguments to __builtin_convertvector must have the same number of elements</source>
          <target>first two arguments to __builtin_convertvector must have the same number of elements</target>
        </segment>
      </unit>
      <unit id="3518" name="err_convertvector_non_vector">
        <segment>
          <source>first argument to __builtin_convertvector must be a vector</source>
          <target>first argument to __builtin_convertvector must be a vector</target>
        </segment>
      </unit>
      <unit id="3519" name="err_copy_capture_with_copy_default">
        <segment>
          <source>'&amp;' must precede a capture when the capture default is '='</source>
          <target>'&amp;' must precede a capture when the capture default is '='</target>
        </segment>
      </unit>
      <unit id="3520" name="err_coro_invalid_addr_of_label">
        <segment>
          <source>the GNU address of label extension is not allowed in coroutines</source>
          <target>the GNU address of label extension is not allowed in coroutines</target>
        </segment>
      </unit>
      <unit id="3521" name="err_coroutine_handle_missing_member">
        <segment>
          <source>std::coroutine_handle must have a member named '%0'</source>
          <target>std::coroutine_handle must have a member named '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3522" name="err_coroutine_invalid_func_context">
        <segment>
          <source>'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0</source>
          <target>'{$arg1}' cannot be used in {$arg0 :select s0=|a constructor| s1=|a destructor| s2=|the 'main' function| s3=|a constexpr function| s4=|a function with a deduced return type| s5=|a varargs function| s6=|a consteval function|}</target>
        </segment>
      </unit>
      <unit id="3523" name="err_coroutine_objc_method">
        <segment>
          <source>Objective-C methods as coroutines are not yet supported</source>
          <target>Objective-C methods as coroutines are not yet supported</target>
        </segment>
      </unit>
      <unit id="3524" name="err_coroutine_outside_function">
        <segment>
          <source>'%0' cannot be used outside a function</source>
          <target>'{$arg0}' cannot be used outside a function</target>
        </segment>
      </unit>
      <unit id="3525" name="err_coroutine_promise_final_suspend_requires_nothrow">
        <segment>
          <source>the expression 'co_await __promise.final_suspend()' is required to be non-throwing</source>
          <target>the expression 'co_await __promise.final_suspend()' is required to be non-throwing</target>
        </segment>
      </unit>
      <unit id="3526" name="err_coroutine_promise_get_return_object_on_allocation_failure">
        <segment>
          <source>%0: 'get_return_object_on_allocation_failure()' must be a static member function</source>
          <target>{$arg0}: 'get_return_object_on_allocation_failure()' must be a static member function</target>
        </segment>
      </unit>
      <unit id="3527" name="err_coroutine_promise_incompatible_return_functions">
        <segment>
          <source>the coroutine promise type %0 declares both 'return_value' and 'return_void'</source>
          <target>the coroutine promise type {$arg0} declares both 'return_value' and 'return_void'</target>
        </segment>
      </unit>
      <unit id="3528" name="err_coroutine_promise_new_requires_nothrow">
        <segment>
          <source>%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'</source>
          <target>{$arg0} is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'</target>
        </segment>
      </unit>
      <unit id="3529" name="err_coroutine_promise_type_incomplete">
        <segment>
          <source>this function cannot be a coroutine: %0 is an incomplete type</source>
          <target>this function cannot be a coroutine: {$arg0} is an incomplete type</target>
        </segment>
      </unit>
      <unit id="3530" name="err_coroutine_promise_unhandled_exception_required">
        <segment>
          <source>%0 is required to declare the member 'unhandled_exception()'</source>
          <target>{$arg0} is required to declare the member 'unhandled_exception()'</target>
        </segment>
      </unit>
      <unit id="3531" name="err_coroutine_return_type">
        <segment>
          <source>function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type</source>
          <target>function returns a type {$arg0} marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type</target>
        </segment>
      </unit>
      <unit id="3532" name="err_coroutine_type_missing_specialization">
        <segment>
          <source>this function cannot be a coroutine: missing definition of specialization %0</source>
          <target>this function cannot be a coroutine: missing definition of specialization {$arg0}</target>
        </segment>
      </unit>
      <unit id="3533" name="err_coroutine_unevaluated_context">
        <segment>
          <source>'%0' cannot be used in an unevaluated context</source>
          <target>'{$arg0}' cannot be used in an unevaluated context</target>
        </segment>
      </unit>
      <unit id="3534" name="err_coroutine_unfound_nothrow_new">
        <segment>
          <source>unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0</source>
          <target>unable to find {$arg1 :select s0=|'::operator new(size_t, nothrow_t)'| s1=|'::operator new(size_t, align_val_t, nothrow_t)'|} for {$arg0}</target>
        </segment>
      </unit>
      <unit id="3535" name="err_coroutine_unusable_new">
        <segment>
          <source>'operator new' provided by %0 is not usable with the function signature of %1</source>
          <target>'operator new' provided by {$arg0} is not usable with the function signature of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3536" name="err_coroutine_within_handler">
        <segment>
          <source>'%0' cannot be used in the handler of a try block</source>
          <target>'{$arg0}' cannot be used in the handler of a try block</target>
        </segment>
      </unit>
      <unit id="3537" name="err_count_attr_argument_not_integer">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument</source>
          <target>'{$arg0 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' requires a non-boolean integer type argument</target>
        </segment>
      </unit>
      <unit id="3538" name="err_count_attr_in_union">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member</source>
          <target>'{$arg0 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' cannot be applied to a union member</target>
        </segment>
      </unit>
      <unit id="3539" name="err_count_attr_must_be_in_structure">
        <segment>
          <source>field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure</source>
          <target>field {$arg0} in '{$arg1 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' not inside structure</target>
        </segment>
      </unit>
      <unit id="3540" name="err_count_attr_not_on_ptr_or_flexible_array_member">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1</source>
          <target>'{$arg0 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' only applies to pointers{$arg0 :select s0=| or C99 flexible array members| s1=|| s2=|| s3=||}{$arg1 :select s0=|| s1=|; did you mean to use 'counted_by'?|}</target>
        </segment>
      </unit>
      <unit id="3541" name="err_count_attr_only_support_simple_decl_reference">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference</source>
          <target>'{$arg0 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' argument must be a simple declaration reference</target>
        </segment>
      </unit>
      <unit id="3542" name="err_count_attr_param_not_in_same_struct">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2</source>
          <target>'{$arg1 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' field {$arg0} isn't within the same struct as the annotated {$arg2 :select s0=|pointer| s1=|flexible array|}</target>
        </segment>
      </unit>
      <unit id="3543" name="err_count_attr_refer_to_union">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member</source>
          <target>'{$arg0 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' argument cannot refer to a union member</target>
        </segment>
      </unit>
      <unit id="3544" name="err_counted_by_attr_on_array_not_flexible_array_member">
        <segment>
          <source>'counted_by' on arrays only applies to C99 flexible array members</source>
          <target>'counted_by' on arrays only applies to C99 flexible array members</target>
        </segment>
      </unit>
      <unit id="3545" name="err_counted_by_attr_pointee_unknown_size">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2</source>
          <target>'{$arg4 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' {$arg3 :select s0=|cannot| s1=|should not|} be applied to {$arg0 :select s0=|a pointer with pointee| s1=|an array with element|} of unknown size because {$arg1} is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member{$arg2 :select s0=|| s1=|. This will be an error in a future compiler version}3|}</target>
        </segment>
      </unit>
      <unit id="3546" name="err_counted_by_attr_refer_to_itself">
        <segment>
          <source>'counted_by' cannot refer to the flexible array member %0</source>
          <target>'counted_by' cannot refer to the flexible array member {$arg0}</target>
        </segment>
      </unit>
      <unit id="3547" name="err_counted_by_on_incomplete_type_on_assign">
        <segment>
          <source>cannot %select{assign to %select{object|'%1'}2 with|pass argument to %select{parameter|parameter '%1'}2 with|return|convert to|%select{|implicitly }3initialize %select{object|'%1'}2 with|pass argument to parameter with|cast to|pass argument to parameter with}0 '%5' attributed type %4 because the pointee type %6 is incomplete</source>
          <target>cannot %select{assign to {$arg2 :select s0=|object| s1=|'{$arg1}'|} with|pass argument to {$arg2 :select s0=|parameter| s1=|parameter '{$arg1}'|} with|return|convert to|{$arg3 :select s0=|| s1=|implicitly |}initialize {$arg0 :select s0=|object| s1=|'{$arg1}'}2 with| s2=|pass argument to parameter with| s3=|cast to| s4=|pass argument to parameter with|} '{$arg5}' attributed type {$arg4} because the pointee type {$arg6} is incomplete</target>
        </segment>
      </unit>
      <unit id="3548" name="err_counted_by_on_incomplete_type_on_use">
        <segment>
          <source>cannot %select{use '%1' with '%4' attributed|call '%1' with '%4' attributed return}0 type %2 because the pointee type %3 is incomplete</source>
          <target>cannot {$arg0 :select s0=|use '{$arg1}' with '{$arg4}' attributed| s1=|call '{$arg1}' with '{$arg4}' attributed return|} type {$arg2} because the pointee type {$arg3} is incomplete</target>
        </segment>
      </unit>
      <unit id="3549" name="err_countof_arg_not_array_type">
        <segment>
          <source>'_Countof' requires an argument of array type; %0 invalid</source>
          <target>'_Countof' requires an argument of array type; {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="3550" name="err_covariant_return_ambiguous_derived_to_base_conv">
        <segment>
          <source>return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)</source>
          <target>return type of virtual function {$arg3} is not covariant with the return type of the function it overrides (ambiguous conversion from derived class {$arg0} to base class {$arg1}:{$arg2})</target>
        </segment>
      </unit>
      <unit id="3551" name="err_covariant_return_inaccessible_base">
        <segment>
          <source>invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0</source>
          <target>invalid covariant return for virtual function: {$arg1} is a {$arg2 :select s0=|private| s1=|protected|} base class of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3552" name="err_covariant_return_incomplete">
        <segment>
          <source>return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)</source>
          <target>return type of virtual function {$arg0} is not covariant with the return type of the function it overrides ({$arg1} is incomplete)</target>
        </segment>
      </unit>
      <unit id="3553" name="err_covariant_return_not_derived">
        <segment>
          <source>return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)</source>
          <target>return type of virtual function {$arg0} is not covariant with the return type of the function it overrides ({$arg1} is not derived from {$arg2})</target>
        </segment>
      </unit>
      <unit id="3554" name="err_covariant_return_type_class_type_not_same_or_less_qualified">
        <segment>
          <source>return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)</source>
          <target>return type of virtual function {$arg0} is not covariant with the return type of the function it overrides (class type {$arg1} does not have the same cv-qualification as or less cv-qualification than class type {$arg2})</target>
        </segment>
      </unit>
      <unit id="3555" name="err_covariant_return_type_different_qualifications">
        <segment>
          <source>return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)</source>
          <target>return type of virtual function {$arg0} is not covariant with the return type of the function it overrides ({$arg1} has different qualifiers than {$arg2})</target>
        </segment>
      </unit>
      <unit id="3556" name="err_cpu_dispatch_mismatch">
        <segment>
          <source>'cpu_dispatch' function redeclared with different CPUs</source>
          <target>'cpu_dispatch' function redeclared with different CPUs</target>
        </segment>
      </unit>
      <unit id="3557" name="err_cpu_specific_multiple_defs">
        <segment>
          <source>multiple 'cpu_specific' functions cannot specify the same CPU: %0</source>
          <target>multiple 'cpu_specific' functions cannot specify the same CPU: {$arg0}</target>
        </segment>
      </unit>
      <unit id="3558" name="err_ctor_dtor_returns_void">
        <segment>
          <source>%select{constructor|destructor}1 %0 must not return void expression</source>
          <target>{$arg1 :select s0=|constructor| s1=|destructor|} {$arg0} must not return void expression</target>
        </segment>
      </unit>
      <unit id="3559" name="err_cuda_ctor_dtor_attrs">
        <segment>
          <source>CUDA does not support global %0 for __device__ functions</source>
          <target>CUDA does not support global {$arg0} for __device__ functions</target>
        </segment>
      </unit>
      <unit id="3560" name="err_cuda_device_builtin_surftex_cls_template">
        <segment>
          <source>illegal device builtin %select{surface|texture}0 reference class template %1 declared here</source>
          <target>illegal device builtin {$arg0 :select s0=|surface| s1=|texture|} reference class template {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="3561" name="err_cuda_device_builtin_surftex_ref_decl">
        <segment>
          <source>illegal device builtin %select{surface|texture}0 reference type %1 declared here</source>
          <target>illegal device builtin {$arg0 :select s0=|surface| s1=|texture|} reference type {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="3562" name="err_cuda_device_exceptions">
        <segment>
          <source>cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function</source>
          <target>cannot use '{$arg0}' in {$arg1 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function</target>
        </segment>
      </unit>
      <unit id="3563" name="err_cuda_extern_shared">
        <segment>
          <source>__shared__ variable %0 cannot be 'extern'</source>
          <target>__shared__ variable {$arg0} cannot be 'extern'</target>
        </segment>
      </unit>
      <unit id="3564" name="err_cuda_grid_constant_not_allowed">
        <segment>
          <source>__grid_constant__ is only allowed on const-qualified kernel parameters</source>
          <target>__grid_constant__ is only allowed on const-qualified kernel parameters</target>
        </segment>
      </unit>
      <unit id="3565" name="err_cuda_host_shared">
        <segment>
          <source>__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions</source>
          <target>__shared__ local variables not allowed in {$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} functions</target>
        </segment>
      </unit>
      <unit id="3566" name="err_cuda_nonstatic_constdev">
        <segment>
          <source>__constant__, __device__, and __managed__ are not allowed on non-static local variables</source>
          <target>__constant__, __device__, and __managed__ are not allowed on non-static local variables</target>
        </segment>
      </unit>
      <unit id="3567" name="err_cuda_ovl_target">
        <segment>
          <source>%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3</source>
          <target>{$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function {$arg1} cannot overload {$arg2 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function {$arg3}</target>
        </segment>
      </unit>
      <unit id="3568" name="err_cuda_unattributed_constexpr_cannot_overload_device">
        <segment>
          <source>constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr</source>
          <target>constexpr function {$arg0} without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr</target>
        </segment>
      </unit>
      <unit id="3569" name="err_cuda_vla">
        <segment>
          <source>cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions</source>
          <target>cannot use variable-length arrays in {$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} functions</target>
        </segment>
      </unit>
      <unit id="3570" name="err_current_module_name_mismatch">
        <segment>
          <source>module name '%0' specified on command line does not match name of module</source>
          <target>module name '{$arg0}' specified on command line does not match name of module</target>
        </segment>
      </unit>
      <unit id="3571" name="err_cxx20_deducing_this">
        <segment>
          <source>explicit object parameters are incompatible with C++ standards before C++2b</source>
          <target>explicit object parameters are incompatible with C++ standards before C++2b</target>
        </segment>
      </unit>
      <unit id="3572" name="err_dangling_member">
        <segment>
          <source>%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object</source>
          <target>{$arg2 :select s0=|reference| s1=|backing array for 'std::initializer_list'|} {$arg1 :select s0=|| s1=|subobject of |}member {$arg0} {$arg2 :select s0=|binds to| s1=|is|} a temporary object whose lifetime would be shorter than the lifetime of the constructed object</target>
        </segment>
      </unit>
      <unit id="3573" name="err_dealloc_bad_result_type">
        <segment>
          <source>dealloc return type must be correctly specified as 'void' under ARC, instead of %0</source>
          <target>dealloc return type must be correctly specified as 'void' under ARC, instead of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3574" name="err_decimal_unsupported">
        <segment>
          <source>GNU decimal type extension not supported</source>
          <target>GNU decimal type extension not supported</target>
        </segment>
      </unit>
      <unit id="3575" name="err_decl_attribute_invalid_on_stmt">
        <segment>
          <source>%0%select{ attribute|}1 cannot be applied to a statement</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} cannot be applied to a statement</target>
        </segment>
      </unit>
      <unit id="3576" name="err_decl_negative_array_size">
        <segment>
          <source>'%0' declared as an array with a negative size</source>
          <target>'{$arg0}' declared as an array with a negative size</target>
        </segment>
      </unit>
      <unit id="3577" name="err_declarator_need_ident">
        <segment>
          <source>declarator requires an identifier</source>
          <target>declarator requires an identifier</target>
        </segment>
      </unit>
      <unit id="3578" name="err_declspec_keyword_has_no_effect">
        <segment>
          <source>%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration</source>
          <target>{$arg0} cannot appear here, place it after "{$arg1 :select s0=|class| s1=|struct| s2=|interface| s3=|union| s4=|enum|}" to apply it to the type declaration</target>
        </segment>
      </unit>
      <unit id="3579" name="err_declspec_thread_on_thread_variable">
        <segment>
          <source>'__declspec(thread)' applied to variable that already has a thread-local storage specifier</source>
          <target>'__declspec(thread)' applied to variable that already has a thread-local storage specifier</target>
        </segment>
      </unit>
      <unit id="3580" name="err_decltype_auto_cannot_be_combined">
        <segment>
          <source>'decltype(auto)' cannot be combined with other type specifiers</source>
          <target>'decltype(auto)' cannot be combined with other type specifiers</target>
        </segment>
      </unit>
      <unit id="3581" name="err_decltype_auto_compound_type">
        <segment>
          <source>cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'</source>
          <target>cannot form {$arg0 :select s0=|pointer to| s1=|reference to| s2=|array of|} 'decltype(auto)'</target>
        </segment>
      </unit>
      <unit id="3582" name="err_decltype_auto_function_declarator_not_declaration">
        <segment>
          <source>'decltype(auto)' can only be used as a return type in a function declaration</source>
          <target>'decltype(auto)' can only be used as a return type in a function declaration</target>
        </segment>
      </unit>
      <unit id="3583" name="err_decltype_auto_initializer_list">
        <segment>
          <source>cannot deduce 'decltype(auto)' from initializer list</source>
          <target>cannot deduce 'decltype(auto)' from initializer list</target>
        </segment>
      </unit>
      <unit id="3584" name="err_decltype_auto_invalid">
        <segment>
          <source>'decltype(auto)' not allowed here</source>
          <target>'decltype(auto)' not allowed here</target>
        </segment>
      </unit>
      <unit id="3585" name="err_decomp_decl_ambiguous_base">
        <segment>
          <source>cannot decompose members of ambiguous base class %1 of %0:%2</source>
          <target>cannot decompose members of ambiguous base class {$arg1} of {$arg0}:{$arg2}</target>
        </segment>
      </unit>
      <unit id="3586" name="err_decomp_decl_anon_union_member">
        <segment>
          <source>cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member</source>
          <target>cannot decompose class type {$arg0} because it has an anonymous {$arg1 :select s0=|struct| s1=|union|} member</target>
        </segment>
      </unit>
      <unit id="3587" name="err_decomp_decl_constraint">
        <segment>
          <source>decomposition declaration cannot be declared with constrained 'auto'</source>
          <target>decomposition declaration cannot be declared with constrained 'auto'</target>
        </segment>
      </unit>
      <unit id="3588" name="err_decomp_decl_context">
        <segment>
          <source>decomposition declaration not permitted in this context</source>
          <target>decomposition declaration not permitted in this context</target>
        </segment>
      </unit>
      <unit id="3589" name="err_decomp_decl_inaccessible_base">
        <segment>
          <source>cannot decompose members of inaccessible base class %1 of %0</source>
          <target>cannot decompose members of inaccessible base class {$arg1} of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3590" name="err_decomp_decl_inaccessible_field">
        <segment>
          <source>cannot decompose %select{private|protected}0 member %1 of %3</source>
          <target>cannot decompose {$arg0 :select s0=|private| s1=|protected|} member {$arg1} of {$arg3}</target>
        </segment>
      </unit>
      <unit id="3591" name="err_decomp_decl_lambda">
        <segment>
          <source>cannot decompose lambda closure type</source>
          <target>cannot decompose lambda closure type</target>
        </segment>
      </unit>
      <unit id="3592" name="err_decomp_decl_multiple_bases_with_members">
        <segment>
          <source>cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members</source>
          <target>cannot decompose class type {$arg1}: {$arg0 :select s0=|its base classes {$arg2} and| s1=|both it and its base class|} {$arg3} have non-static data members</target>
        </segment>
      </unit>
      <unit id="3593" name="err_decomp_decl_not_alone">
        <segment>
          <source>decomposition declaration must be the only declaration in its group</source>
          <target>decomposition declaration must be the only declaration in its group</target>
        </segment>
      </unit>
      <unit id="3594" name="err_decomp_decl_parens">
        <segment>
          <source>decomposition declaration cannot be declared with parentheses</source>
          <target>decomposition declaration cannot be declared with parentheses</target>
        </segment>
      </unit>
      <unit id="3595" name="err_decomp_decl_requires_init">
        <segment>
          <source>decomposition declaration %0 requires an initializer</source>
          <target>decomposition declaration {$arg0} requires an initializer</target>
        </segment>
      </unit>
      <unit id="3596" name="err_decomp_decl_spec">
        <segment>
          <source>decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0</source>
          <target>decomposition declaration cannot be declared %plural{1:'{$arg1}'|:with '{$arg1}' specifiers}0</target>
        </segment>
      </unit>
      <unit id="3597" name="err_decomp_decl_std_tuple_element_not_specialized">
        <segment>
          <source>cannot decompose this type; 'std::tuple_element&lt;%0&gt;::type' does not name a type</source>
          <target>cannot decompose this type; 'std::tuple_element&lt;{$arg0}&gt;::type' does not name a type</target>
        </segment>
      </unit>
      <unit id="3598" name="err_decomp_decl_std_tuple_size_not_constant">
        <segment>
          <source>cannot decompose this type; 'std::tuple_size&lt;%0&gt;::value' is not a valid integral constant expression</source>
          <target>cannot decompose this type; 'std::tuple_size&lt;{$arg0}&gt;::value' is not a valid integral constant expression</target>
        </segment>
      </unit>
      <unit id="3599" name="err_decomp_decl_template">
        <segment>
          <source state="initial">decomposition declaration cannot be a template</source>
          <target>decomposition declaration cannot be a template</target>
        </segment>
      </unit>
      <unit id="3600" name="err_decomp_decl_type">
        <segment>
          <source>decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'</source>
          <target>decomposition declaration cannot be declared with type {$arg0}; declared type must be 'auto' or reference to 'auto'</target>
        </segment>
      </unit>
      <unit id="3601" name="err_decomp_decl_unbindable_type">
        <segment>
          <source>cannot decompose %select{union|non-class, non-array}1 type %2</source>
          <target>cannot decompose {$arg1 :select s0=|union| s1=|non-class, non-array|} type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3602" name="err_decomp_decl_wrong_number_bindings">
        <segment>
          <source>type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided</source>
          <target>type {$arg0} decomposes into {$arg3} %plural{1:element|:elements}2, but %select{%plural{0:no|:only {$arg1}}1|{$arg1}}4 %plural{1:name was|:names were}1 provided</target>
        </segment>
      </unit>
      <unit id="3603" name="err_decrement_bool">
        <segment>
          <source>cannot decrement expression of type bool</source>
          <target>cannot decrement expression of type bool</target>
        </segment>
      </unit>
      <unit id="3604" name="err_deduced_class_template_compound_type">
        <segment>
          <source state="initial">cannot form %select{pointer to|reference to|array of|function returning}0 deduced class template specialization type</source>
          <target>cannot form {$arg0 :select s0=|pointer to| s1=|reference to| s2=|array of| s3=|function returning|} deduced class template specialization type</target>
        </segment>
      </unit>
      <unit id="3605" name="err_deduced_class_template_ctor_ambiguous">
        <segment>
          <source>ambiguous deduction for template arguments of %0</source>
          <target>ambiguous deduction for template arguments of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3606" name="err_deduced_class_template_ctor_no_viable">
        <segment>
          <source>no viable constructor or deduction guide for deduction of template arguments of %0</source>
          <target>no viable constructor or deduction guide for deduction of template arguments of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3607" name="err_deduced_class_template_deleted">
        <segment>
          <source>class template argument deduction for %0 selected a deleted constructor</source>
          <target>class template argument deduction for {$arg0} selected a deleted constructor</target>
        </segment>
      </unit>
      <unit id="3608" name="err_deduced_class_template_explicit">
        <segment>
          <source>class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization</source>
          <target>class template argument deduction for {$arg0} selected an explicit {$arg1 :select s0=|constructor| s1=|deduction guide|} for copy-list-initialization</target>
        </segment>
      </unit>
      <unit id="3609" name="err_deduced_class_template_incomplete">
        <segment>
          <source>template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments</source>
          <target>template {$arg0} has no definition and no {$arg1 :select s0=|| s1=|viable |}deduction guides for deduction of template arguments</target>
        </segment>
      </unit>
      <unit id="3610" name="err_deduced_non_class_or_alias_template_specialization_type">
        <segment>
          <source>%select{&lt;error&gt;|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates</source>
          <target>{$arg0 :select s0=|&lt;error&gt;| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|concept| s6=|template|} {$arg1} requires template arguments; argument deduction only allowed for class templates or alias templates</target>
        </segment>
      </unit>
      <unit id="3611" name="err_deduced_non_type_template_arg_type_mismatch">
        <segment>
          <source>deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1</source>
          <target>deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1</target>
        </segment>
      </unit>
      <unit id="3612" name="err_deduced_return_type">
        <segment>
          <source>deduced return types are a C++14 extension</source>
          <target>deduced return types are a C++14 extension</target>
        </segment>
      </unit>
      <unit id="3613" name="err_deduced_tst">
        <segment>
          <source>typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here</source>
          <target>typename specifier refers to {$arg0 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|template|}; argument deduction not allowed here</target>
        </segment>
      </unit>
      <unit id="3614" name="err_deduction_guide_bad_trailing_return_type">
        <segment>
          <source>deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0</source>
          <target>deduced type {$arg1} of deduction guide is not {$arg2 :select s0=|| s1=|written as |}a specialization of template {$arg0}</target>
        </segment>
      </unit>
      <unit id="3615" name="err_deduction_guide_defines_function">
        <segment>
          <source>deduction guide cannot have a function definition</source>
          <target>deduction guide cannot have a function definition</target>
        </segment>
      </unit>
      <unit id="3616" name="err_deduction_guide_invalid_specifier">
        <segment>
          <source>deduction guide cannot be declared '%0'</source>
          <target>deduction guide cannot be declared '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3617" name="err_deduction_guide_name_not_class_template">
        <segment>
          <source>cannot specify deduction guide for %select{&lt;error&gt;|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1</source>
          <target>cannot specify deduction guide for {$arg0 :select s0=|&lt;error&gt;| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|concept| s6=|dependent template name|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="3618" name="err_deduction_guide_no_trailing_return_type">
        <segment>
          <source>deduction guide declaration without trailing return type</source>
          <target>deduction guide declaration without trailing return type</target>
        </segment>
      </unit>
      <unit id="3619" name="err_deduction_guide_redeclared">
        <segment>
          <source>redeclaration of deduction guide</source>
          <target>redeclaration of deduction guide</target>
        </segment>
      </unit>
      <unit id="3620" name="err_deduction_guide_specialized">
        <segment>
          <source>deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0</source>
          <target>deduction guide cannot be {$arg0 :select s0=|explicitly instantiated| s1=|explicitly specialized|}</target>
        </segment>
      </unit>
      <unit id="3621" name="err_deduction_guide_template_not_deducible">
        <segment>
          <source>deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced</source>
          <target>deduction guide template contains {$arg0 :select s0=|a template parameter| s1=|template parameters|} that cannot be deduced</target>
        </segment>
      </unit>
      <unit id="3622" name="err_deduction_guide_with_complex_decl">
        <segment>
          <source>cannot specify any part of a return type in the declaration of a deduction guide</source>
          <target>cannot specify any part of a return type in the declaration of a deduction guide</target>
        </segment>
      </unit>
      <unit id="3623" name="err_deduction_guide_wrong_access">
        <segment>
          <source>deduction guide has different access from the corresponding member template</source>
          <target>deduction guide has different access from the corresponding member template</target>
        </segment>
      </unit>
      <unit id="3624" name="err_deduction_guide_wrong_scope">
        <segment>
          <source>deduction guide must be declared in the same scope as template %q0</source>
          <target>deduction guide must be declared in the same scope as template {$arg0 :q}</target>
        </segment>
      </unit>
      <unit id="3625" name="err_deep_exception_specs_differ">
        <segment>
          <source>exception specifications of %select{return|argument}0 types differ</source>
          <target>exception specifications of {$arg0 :select s0=|return| s1=|argument|} types differ</target>
        </segment>
      </unit>
      <unit id="3626" name="err_default_arg_in_partial_spec">
        <segment>
          <source>default template argument in a class template partial specialization</source>
          <target>default template argument in a class template partial specialization</target>
        </segment>
      </unit>
      <unit id="3627" name="err_default_arg_makes_ctor_special">
        <segment>
          <source>addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor</source>
          <target>addition of default argument on redeclaration makes this constructor a {$arg0 :select s0=|default| s1=|copy| s2=|move|} constructor</target>
        </segment>
      </unit>
      <unit id="3628" name="err_default_init_const">
        <segment>
          <source>default initialization of an object of const type %0%select{| without a user-provided default constructor}1</source>
          <target>default initialization of an object of const type {$arg0}{$arg1 :select s0=|| s1=| without a user-provided default constructor|}</target>
        </segment>
      </unit>
      <unit id="3629" name="err_default_member_initializer_cycle">
        <segment>
          <source>default member initializer for %0 uses itself</source>
          <target>default member initializer for {$arg0} uses itself</target>
        </segment>
      </unit>
      <unit id="3630" name="err_default_member_initializer_not_yet_parsed">
        <segment>
          <source>default member initializer for %1 needed within definition of enclosing class %0 outside of member functions</source>
          <target>default member initializer for {$arg1} needed within definition of enclosing class {$arg0} outside of member functions</target>
        </segment>
      </unit>
      <unit id="3631" name="err_default_not_in_switch">
        <segment>
          <source>'default' statement not in switch statement</source>
          <target>'default' statement not in switch statement</target>
        </segment>
      </unit>
      <unit id="3632" name="err_defaulted_comparison_cannot_deduce_undeduced_auto">
        <segment>
          <source>return type of defaulted 'operator&lt;=&gt;' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined</source>
          <target>return type of defaulted 'operator&lt;=&gt;' cannot be deduced because three-way comparison for {$arg0 :select s0=|| s1=|member| s2=|base class|} {$arg1} has a deduced return type and is not yet defined</target>
        </segment>
      </unit>
      <unit id="3633" name="err_defaulted_comparison_constexpr_mismatch">
        <segment>
          <source state="initial">defaulted definition of %select{%select{&lt;ERROR&gt;|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function</source>
          <target>defaulted definition of %select{{$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational}1 comparison operator| s5=|three-way comparison operator|} cannot be declared {$arg2 :select s0=|constexpr| s1=|consteval|} because {$arg0 :select s0=|it| s1=|for which the corresponding implicit 'operator==' |} invokes a non-constexpr comparison function</target>
        </segment>
      </unit>
      <unit id="3634" name="err_defaulted_comparison_deduced_return_type_not_auto">
        <segment>
          <source>deduced return type for defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1</source>
          <target>deduced return type for defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator must be 'auto', not {$arg1}</target>
        </segment>
      </unit>
      <unit id="3635" name="err_defaulted_comparison_non_const">
        <segment>
          <source>defaulted member %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator must be const-qualified</source>
          <target>defaulted member {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator must be const-qualified</target>
        </segment>
      </unit>
      <unit id="3636" name="err_defaulted_comparison_not_friend">
        <segment>
          <source>%select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2</source>
          <target>{$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator is not a friend of {$arg1 :select s0=|| s1=|incomplete class |}{$arg2}</target>
        </segment>
      </unit>
      <unit id="3637" name="err_defaulted_comparison_num_args">
        <segment>
          <source>%select{non-member|member}0 %select{&lt;ERROR&gt;|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters</source>
          <target>{$arg0 :select s0=|non-member| s1=|member|} {$arg1 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator must have {$arg0 :select s0=|2| s1=|1|} parameters</target>
        </segment>
      </unit>
      <unit id="3638" name="err_defaulted_comparison_param">
        <segment>
          <source>invalid parameter type for defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3</source>
          <target>invalid parameter type for defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator; found {$arg1}, expected {$arg2}{$arg3 :select s0=|| s1=| or {$arg4}|}</target>
        </segment>
      </unit>
      <unit id="3639" name="err_defaulted_comparison_param_mismatch">
        <segment>
          <source>parameters for defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2</source>
          <target>parameters for defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator must have the same type%diff{ (found $ vs $)|}1,2</target>
        </segment>
      </unit>
      <unit id="3640" name="err_defaulted_comparison_param_unknown">
        <segment>
          <source>invalid parameter type for non-member defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class</source>
          <target>invalid parameter type for non-member defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator; found {$arg1}, expected class or reference to a constant class</target>
        </segment>
      </unit>
      <unit id="3641" name="err_defaulted_comparison_return_type_not_bool">
        <segment>
          <source>return type for defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1</source>
          <target>return type for defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator must be 'bool', not {$arg1}</target>
        </segment>
      </unit>
      <unit id="3642" name="err_defaulted_comparison_template">
        <segment>
          <source>comparison operator template cannot be defaulted</source>
          <target>comparison operator template cannot be defaulted</target>
        </segment>
      </unit>
      <unit id="3643" name="err_defaulted_copy_assign_not_ref">
        <segment>
          <source>the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type</source>
          <target>the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type</target>
        </segment>
      </unit>
      <unit id="3644" name="err_defaulted_special_member_copy_const_param">
        <segment>
          <source>the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const</source>
          <target>the parameter for this explicitly-defaulted copy {$arg0 :select s0=|constructor| s1=|assignment operator|} is const, but a member or base requires it to be non-const</target>
        </segment>
      </unit>
      <unit id="3645" name="err_defaulted_special_member_explicit_object_mismatch">
        <segment>
          <source state="initial">the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1</source>
          <target>the type of the explicit object parameter of an explicitly-defaulted {$arg0 :select s0=|copy| s1=|move|} assignment operator should be reference to {$arg1}</target>
        </segment>
      </unit>
      <unit id="3646" name="err_defaulted_special_member_move_const_param">
        <segment>
          <source>the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const</source>
          <target>the parameter for an explicitly-defaulted move {$arg0 :select s0=|constructor| s1=|assignment operator|} may not be const</target>
        </segment>
      </unit>
      <unit id="3647" name="err_defaulted_special_member_params">
        <segment>
          <source>an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments</source>
          <target>an explicitly-defaulted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} cannot have default arguments</target>
        </segment>
      </unit>
      <unit id="3648" name="err_defaulted_special_member_quals">
        <segment>
          <source>an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers</source>
          <target>an explicitly-defaulted {$arg0 :select s0=|copy| s1=|move|} assignment operator may not have 'const'{$arg1 :select s0=|, 'constexpr'| s1=||} or 'volatile' qualifiers</target>
        </segment>
      </unit>
      <unit id="3649" name="err_defaulted_special_member_return_type">
        <segment>
          <source>explicitly-defaulted %select{copy|move}0 assignment operator must return %1</source>
          <target>explicitly-defaulted {$arg0 :select s0=|copy| s1=|move|} assignment operator must return {$arg1}</target>
        </segment>
      </unit>
      <unit id="3650" name="err_defaulted_special_member_variadic">
        <segment>
          <source>an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic</source>
          <target>an explicitly-defaulted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} cannot be variadic</target>
        </segment>
      </unit>
      <unit id="3651" name="err_defaulted_special_member_volatile_param">
        <segment>
          <source>the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile</source>
          <target>the parameter for an explicitly-defaulted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} may not be volatile</target>
        </segment>
      </unit>
      <unit id="3652" name="err_definition_of_explicitly_defaulted_member">
        <segment>
          <source>definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0</source>
          <target>definition of explicitly defaulted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor| s6=|function|}</target>
        </segment>
      </unit>
      <unit id="3653" name="err_definition_of_implicitly_declared_member">
        <segment>
          <source>definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1</source>
          <target>definition of implicitly declared {$arg1 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor| s6=|function|}</target>
        </segment>
      </unit>
      <unit id="3654" name="err_delegating_ctor">
        <segment>
          <source>delegating constructors are permitted only in C++11</source>
          <target>delegating constructors are permitted only in C++11</target>
        </segment>
      </unit>
      <unit id="3655" name="err_delegating_initializer_alone">
        <segment>
          <source>an initializer for a delegating constructor must appear alone</source>
          <target>an initializer for a delegating constructor must appear alone</target>
        </segment>
      </unit>
      <unit id="3656" name="err_delete_explicit_conversion">
        <segment>
          <source>converting delete expression from type %0 to type %1 invokes an explicit conversion function</source>
          <target>converting delete expression from type {$arg0} to type {$arg1} invokes an explicit conversion function</target>
        </segment>
      </unit>
      <unit id="3657" name="err_delete_incomplete">
        <segment>
          <source>cannot delete pointer to incomplete type %0</source>
          <target>cannot delete pointer to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3658" name="err_delete_incomplete_class_type">
        <segment>
          <source>deleting incomplete class type %0; no conversions to pointer type</source>
          <target>deleting incomplete class type {$arg0}; no conversions to pointer type</target>
        </segment>
      </unit>
      <unit id="3659" name="err_delete_operand">
        <segment>
          <source>cannot delete expression of type %0</source>
          <target>cannot delete expression of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3660" name="err_deleted_decl_not_first">
        <segment>
          <source>deleted definition must be first declaration</source>
          <target>deleted definition must be first declaration</target>
        </segment>
      </unit>
      <unit id="3661" name="err_deleted_function_use">
        <segment>
          <source>attempt to use a deleted function%select{|: %1}0</source>
          <target>attempt to use a deleted function{$arg0 :select s0=|| s1=|: {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="3662" name="err_deleted_inherited_ctor_use">
        <segment>
          <source>constructor inherited by %0 from base class %1 is implicitly deleted</source>
          <target>constructor inherited by {$arg0} from base class {$arg1} is implicitly deleted</target>
        </segment>
      </unit>
      <unit id="3663" name="err_deleted_main">
        <segment>
          <source>'main' is not allowed to be deleted</source>
          <target>'main' is not allowed to be deleted</target>
        </segment>
      </unit>
      <unit id="3664" name="err_deleted_override">
        <segment>
          <source>deleted function %0 cannot override a non-deleted function</source>
          <target>deleted function {$arg0} cannot override a non-deleted function</target>
        </segment>
      </unit>
      <unit id="3665" name="err_dependent_deduced_tst">
        <segment>
          <source>typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here</source>
          <target>typename specifier refers to {$arg0 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|template|} member in {$arg1}; argument deduction not allowed here</target>
        </segment>
      </unit>
      <unit id="3666" name="err_dependent_function_template_spec_no_match">
        <segment>
          <source>no candidate function template was found for dependent %select{member|friend}0 function template specialization</source>
          <target>no candidate function template was found for dependent {$arg0 :select s0=|member| s1=|friend|} function template specialization</target>
        </segment>
      </unit>
      <unit id="3667" name="err_dependent_nested_name_spec">
        <segment>
          <source>nested name specifier for a declaration cannot depend on a template parameter</source>
          <target>nested name specifier for a declaration cannot depend on a template parameter</target>
        </segment>
      </unit>
      <unit id="3668" name="err_dependent_non_type_arg_in_partial_spec">
        <segment>
          <source>type of specialized non-type template argument depends on a template parameter of the partial specialization</source>
          <target>type of specialized non-type template argument depends on a template parameter of the partial specialization</target>
        </segment>
      </unit>
      <unit id="3669" name="err_dependent_tag_decl">
        <segment>
          <source>%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope</source>
          <target>{$arg0 :select s0=|declaration| s1=|definition|} of {$arg1 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} in a dependent scope</target>
        </segment>
      </unit>
      <unit id="3670" name="err_dependent_typed_non_type_arg_in_partial_spec">
        <segment>
          <source>non-type template argument specializes a template parameter with dependent type %0</source>
          <target>non-type template argument specializes a template parameter with dependent type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3671" name="err_dereference_incomplete_type">
        <segment>
          <source>dereference of pointer to incomplete type %0</source>
          <target>dereference of pointer to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3672" name="err_designated_init_attr_non_init">
        <segment>
          <source>'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations</source>
          <target>'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations</target>
        </segment>
      </unit>
      <unit id="3673" name="err_designated_init_for_non_aggregate">
        <segment>
          <source>initialization of non-aggregate type %0 with a designated initializer list</source>
          <target>initialization of non-aggregate type {$arg0} with a designated initializer list</target>
        </segment>
      </unit>
      <unit id="3674" name="err_designator_for_scalar_or_sizeless_init">
        <segment>
          <source>designator in initializer for %select{scalar|indivisible sizeless}0 type %1</source>
          <target>designator in initializer for {$arg0 :select s0=|scalar| s1=|indivisible sizeless|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3675" name="err_designator_into_flexible_array_member">
        <segment>
          <source>designator into flexible array member subobject</source>
          <target>designator into flexible array member subobject</target>
        </segment>
      </unit>
      <unit id="3676" name="err_destroy_attr_on_non_static_var">
        <segment>
          <source>%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration</source>
          <target>{$arg0 :select s0=|no_destroy| s1=|always_destroy|} attribute can only be applied to a variable with static or thread storage duration</target>
        </segment>
      </unit>
      <unit id="3677" name="err_destroying_operator_delete_not_usual">
        <segment>
          <source>destroying operator delete can have only an optional size and optional alignment parameter</source>
          <target>destroying operator delete can have only an optional size and optional alignment parameter</target>
        </segment>
      </unit>
      <unit id="3678" name="err_destructor_cannot_be">
        <segment>
          <source>destructor cannot be declared '%0'</source>
          <target>destructor cannot be declared '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3679" name="err_destructor_expr_mismatch">
        <segment>
          <source>identifier %0 in object destruction expression does not name the type %1 of the object being destroyed</source>
          <target>identifier {$arg0} in object destruction expression does not name the type {$arg1} of the object being destroyed</target>
        </segment>
      </unit>
      <unit id="3680" name="err_destructor_expr_nontype">
        <segment>
          <source>identifier %0 in object destruction expression does not name a type</source>
          <target>identifier {$arg0} in object destruction expression does not name a type</target>
        </segment>
      </unit>
      <unit id="3681" name="err_destructor_expr_type_mismatch">
        <segment>
          <source>destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed</source>
          <target>destructor type {$arg0} in object destruction expression does not match the type {$arg1} of the object being destroyed</target>
        </segment>
      </unit>
      <unit id="3682" name="err_destructor_name">
        <segment>
          <source>expected the class name after '~' to name the enclosing class</source>
          <target>expected the class name after '~' to name the enclosing class</target>
        </segment>
      </unit>
      <unit id="3683" name="err_destructor_name_nontype">
        <segment>
          <source>identifier %0 after '~' in destructor name does not name a type</source>
          <target>identifier {$arg0} after '~' in destructor name does not name a type</target>
        </segment>
      </unit>
      <unit id="3684" name="err_destructor_not_member">
        <segment>
          <source>destructor must be a non-static member function</source>
          <target>destructor must be a non-static member function</target>
        </segment>
      </unit>
      <unit id="3685" name="err_destructor_redeclared">
        <segment>
          <source>destructor cannot be redeclared</source>
          <target>destructor cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="3686" name="err_destructor_return_type">
        <segment>
          <source>destructor cannot have a return type</source>
          <target>destructor cannot have a return type</target>
        </segment>
      </unit>
      <unit id="3687" name="err_destructor_template">
        <segment>
          <source>destructor cannot be declared as a template</source>
          <target>destructor cannot be declared as a template</target>
        </segment>
      </unit>
      <unit id="3688" name="err_destructor_variadic">
        <segment>
          <source>destructor cannot be variadic</source>
          <target>destructor cannot be variadic</target>
        </segment>
      </unit>
      <unit id="3689" name="err_destructor_with_params">
        <segment>
          <source>destructor cannot have any parameters</source>
          <target>destructor cannot have any parameters</target>
        </segment>
      </unit>
      <unit id="3690" name="err_diagnose_if_expected_equals">
        <segment>
          <source>expected '=' after diagnostic option</source>
          <target>expected '=' after diagnostic option</target>
        </segment>
      </unit>
      <unit id="3691" name="err_diagnose_if_invalid_diagnostic_type">
        <segment>
          <source>invalid diagnostic type for 'diagnose_if'; use "error" or "warning" instead</source>
          <target>invalid diagnostic type for 'diagnose_if'; use "error" or "warning" instead</target>
        </segment>
      </unit>
      <unit id="3692" name="err_diagnose_if_succeeded">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="3693" name="err_diagnose_if_unexpected_value">
        <segment>
          <source>unexpected value; use 'true' or 'false'</source>
          <target>unexpected value; use 'true' or 'false'</target>
        </segment>
      </unit>
      <unit id="3694" name="err_diagnose_if_unknown_option">
        <segment>
          <source>unknown diagnostic option</source>
          <target>unknown diagnostic option</target>
        </segment>
      </unit>
      <unit id="3695" name="err_diagnose_if_unknown_warning">
        <segment>
          <source>unknown warning group '%0'</source>
          <target>unknown warning group '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3696" name="err_different_asm_label">
        <segment>
          <source>conflicting asm label</source>
          <target>conflicting asm label</target>
        </segment>
      </unit>
      <unit id="3697" name="err_different_language_linkage">
        <segment>
          <source>declaration of %0 has a different language linkage</source>
          <target>declaration of {$arg0} has a different language linkage</target>
        </segment>
      </unit>
      <unit id="3698" name="err_different_pass_object_size_params">
        <segment>
          <source>conflicting pass_object_size attributes on parameters</source>
          <target>conflicting pass_object_size attributes on parameters</target>
        </segment>
      </unit>
      <unit id="3699" name="err_different_return_type_for_overriding_virtual_function">
        <segment>
          <source>virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2</source>
          <target>virtual function {$arg0} has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2</target>
        </segment>
      </unit>
      <unit id="3700" name="err_dimension_expr_not_constant_integer">
        <segment>
          <source>dimension expression does not evaluate to a constant unsigned int</source>
          <target>dimension expression does not evaluate to a constant unsigned int</target>
        </segment>
      </unit>
      <unit id="3701" name="err_direct_selector_expression">
        <segment>
          <source>@selector expression formed with direct selector %0</source>
          <target>@selector expression formed with direct selector {$arg0}</target>
        </segment>
      </unit>
      <unit id="3702" name="err_disallowed_duplicate_attribute">
        <segment>
          <source>attribute %0 cannot appear more than once on a declaration</source>
          <target>attribute {$arg0} cannot appear more than once on a declaration</target>
        </segment>
      </unit>
      <unit id="3703" name="err_distant_exception_spec">
        <segment>
          <source>exception specifications are not allowed beyond a single level of indirection</source>
          <target>exception specifications are not allowed beyond a single level of indirection</target>
        </segment>
      </unit>
      <unit id="3704" name="err_downcast_from_inaccessible_base">
        <segment>
          <source>cannot cast %select{private|protected}2 base class %1 to %0</source>
          <target>cannot cast {$arg2 :select s0=|private| s1=|protected|} base class {$arg1} to {$arg0}</target>
        </segment>
      </unit>
      <unit id="3705" name="err_dtor_expr_without_call">
        <segment>
          <source>reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1</source>
          <target>reference to {$arg0 :select s0=|destructor| s1=|pseudo-destructor|} must be called{$arg1 :select s0=|| s1=|; did you mean to call it with no arguments?|}</target>
        </segment>
      </unit>
      <unit id="3706" name="err_dup_implementation_category">
        <segment>
          <source>reimplementation of category %1 for class %0</source>
          <target>reimplementation of category {$arg1} for class {$arg0}</target>
        </segment>
      </unit>
      <unit id="3707" name="err_dup_implementation_class">
        <segment>
          <source>reimplementation of class %0</source>
          <target>reimplementation of class {$arg0}</target>
        </segment>
      </unit>
      <unit id="3708" name="err_duplicate_base_class">
        <segment>
          <source>base class %0 specified more than once as a direct base class</source>
          <target>base class {$arg0} specified more than once as a direct base class</target>
        </segment>
      </unit>
      <unit id="3709" name="err_duplicate_case">
        <segment>
          <source>duplicate case value '%0'</source>
          <target>duplicate case value '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="3710" name="err_duplicate_case_differing_expr">
        <segment>
          <source>duplicate case value: '%0' and '%1' both equal '%2'</source>
          <target>duplicate case value: '{$arg0}' and '{$arg1}' both equal '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="3711" name="err_duplicate_class_def">
        <segment>
          <source>duplicate interface definition for class %0</source>
          <target>duplicate interface definition for class {$arg0}</target>
        </segment>
      </unit>
      <unit id="3712" name="err_duplicate_ivar_declaration">
        <segment>
          <source>instance variable is already declared</source>
          <target>instance variable is already declared</target>
        </segment>
      </unit>
      <unit id="3713" name="err_duplicate_ivar_use">
        <segment>
          <source>synthesized properties %0 and %1 both claim instance variable %2</source>
          <target>synthesized properties {$arg0} and {$arg1} both claim instance variable {$arg2}</target>
        </segment>
      </unit>
      <unit id="3714" name="err_duplicate_member">
        <segment>
          <source>duplicate member %0</source>
          <target>duplicate member {$arg0}</target>
        </segment>
      </unit>
      <unit id="3715" name="err_duplicate_method_decl">
        <segment>
          <source>duplicate declaration of method %0</source>
          <target>duplicate declaration of method {$arg0}</target>
        </segment>
      </unit>
      <unit id="3716" name="err_duplicate_property">
        <segment>
          <source>property has a previous declaration</source>
          <target>property has a previous declaration</target>
        </segment>
      </unit>
      <unit id="3717" name="err_duplicate_target_attribute">
        <segment>
          <source state="initial">%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;</source>
          <target>{$arg0 :select s0=|unsupported| s1=|duplicate| s2=|unknown|}{$arg1 :select s0=|| s1=| CPU| s2=| tune CPU|} '{$arg2}' in the '{$arg3 :select s0=|target| s1=|target_clones| s2=|target_version|}' attribute string;</target>
        </segment>
      </unit>
      <unit id="3718" name="err_duplicated_vtable_pointer_auth">
        <segment>
          <source>multiple vtable pointer authentication policies on %0</source>
          <target>multiple vtable pointer authentication policies on {$arg0}</target>
        </segment>
      </unit>
      <unit id="3719" name="err_dynamic_property_ivar_decl">
        <segment>
          <source>dynamic property cannot have instance variable specification</source>
          <target>dynamic property cannot have instance variable specification</target>
        </segment>
      </unit>
      <unit id="3720" name="err_dynamic_var_init">
        <segment>
          <source>dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables</source>
          <target>dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables</target>
        </segment>
      </unit>
      <unit id="3721" name="err_early_catch_all">
        <segment>
          <source>catch-all handler must come last</source>
          <target>catch-all handler must come last</target>
        </segment>
      </unit>
      <unit id="3722" name="err_ellipsis_first_param">
        <segment>
          <source>ISO C requires a named parameter before '...'</source>
          <target>ISO C requires a named parameter before '...'</target>
        </segment>
      </unit>
      <unit id="3723" name="err_ellipsis_in_declarator_not_parameter">
        <segment>
          <source>only function and template parameters can be parameter packs</source>
          <target>only function and template parameters can be parameter packs</target>
        </segment>
      </unit>
      <unit id="3724" name="err_empty_scalar_initializer">
        <segment>
          <source>scalar initializer cannot be empty</source>
          <target>scalar initializer cannot be empty</target>
        </segment>
      </unit>
      <unit id="3725" name="err_empty_sizeless_initializer">
        <segment>
          <source>initializer for sizeless type %0 cannot be empty</source>
          <target>initializer for sizeless type {$arg0} cannot be empty</target>
        </segment>
      </unit>
      <unit id="3726" name="err_enum_invalid_underlying">
        <segment>
          <source>%select{non-integral type %0|%0}1 is an invalid underlying type</source>
          <target>{$arg1 :select s0=|non-integral type {$arg0}| s1=|{$arg0}|} is an invalid underlying type</target>
        </segment>
      </unit>
      <unit id="3727" name="err_enum_mode_vector_type">
        <segment>
          <source>mode %0 is not supported for enumeration types</source>
          <target>mode {$arg0} is not supported for enumeration types</target>
        </segment>
      </unit>
      <unit id="3728" name="err_enum_redeclare_fixed_mismatch">
        <segment>
          <source>enumeration previously declared with %select{non|}0fixed underlying type</source>
          <target>enumeration previously declared with {$arg0 :select s0=|non| s1=||}fixed underlying type</target>
        </segment>
      </unit>
      <unit id="3729" name="err_enum_redeclare_scoped_mismatch">
        <segment>
          <source>enumeration previously declared as %select{un|}0scoped</source>
          <target>enumeration previously declared as {$arg0 :select s0=|un| s1=||}scoped</target>
        </segment>
      </unit>
      <unit id="3730" name="err_enum_redeclare_type_mismatch">
        <segment>
          <source>enumeration redeclared with different underlying type %0 (was %1)</source>
          <target>enumeration redeclared with different underlying type {$arg0} (was {$arg1})</target>
        </segment>
      </unit>
      <unit id="3731" name="err_enumerator_does_not_exist">
        <segment>
          <source>enumerator %0 does not exist in instantiation of %1</source>
          <target>enumerator {$arg0} does not exist in instantiation of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3732" name="err_enumerator_too_large">
        <segment>
          <source>enumerator value is not representable in the underlying type %0</source>
          <target>enumerator value is not representable in the underlying type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3733" name="err_enumerator_wrapped">
        <segment>
          <source>enumerator value %0 is not representable in the underlying type %1</source>
          <target>enumerator value {$arg0} is not representable in the underlying type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3734" name="err_event_t_addr_space_qual">
        <segment>
          <source>the event_t type can only be used with __private address space qualifier</source>
          <target>the event_t type can only be used with __private address space qualifier</target>
        </segment>
      </unit>
      <unit id="3735" name="err_exception_spec_cycle">
        <segment>
          <source>exception specification of %0 uses itself</source>
          <target>exception specification of {$arg0} uses itself</target>
        </segment>
      </unit>
      <unit id="3736" name="err_exception_spec_in_typedef">
        <segment>
          <source>exception specifications are not allowed in %select{typedefs|type aliases}0</source>
          <target>exception specifications are not allowed in {$arg0 :select s0=|typedefs| s1=|type aliases|}</target>
        </segment>
      </unit>
      <unit id="3737" name="err_exception_spec_incomplete_type">
        <segment>
          <source>exception specification needed for member of incomplete class %0</source>
          <target>exception specification needed for member of incomplete class {$arg0}</target>
        </segment>
      </unit>
      <unit id="3738" name="err_exception_spec_not_parsed">
        <segment>
          <source>exception specification is not available until end of class definition</source>
          <target>exception specification is not available until end of class definition</target>
        </segment>
      </unit>
      <unit id="3739" name="err_exceptions_disabled">
        <segment>
          <source>cannot use '%0' with exceptions disabled</source>
          <target>cannot use '{$arg0}' with exceptions disabled</target>
        </segment>
      </unit>
      <unit id="3740" name="err_excess_initializers">
        <segment>
          <source>excess elements in %select{array|vector|scalar|union|struct}0 initializer</source>
          <target>excess elements in {$arg0 :select s0=|array| s1=|vector| s2=|scalar| s3=|union| s4=|struct|} initializer</target>
        </segment>
      </unit>
      <unit id="3741" name="err_excess_initializers_for_sizeless_type">
        <segment>
          <source>excess elements in initializer for indivisible sizeless type %0</source>
          <target>excess elements in initializer for indivisible sizeless type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3742" name="err_excess_initializers_in_char_array_initializer">
        <segment>
          <source>excess elements in char array initializer</source>
          <target>excess elements in char array initializer</target>
        </segment>
      </unit>
      <unit id="3743" name="err_expected_allocator_clause">
        <segment>
          <source>expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause</source>
          <target>expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause</target>
        </segment>
      </unit>
      <unit id="3744" name="err_expected_allocator_expression">
        <segment>
          <source>expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause</source>
          <target>expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause</target>
        </segment>
      </unit>
      <unit id="3745" name="err_expected_callable_argument">
        <segment>
          <source>expected a callable expression as %ordinal0 argument to %1, found %2</source>
          <target>expected a callable expression as %ordinal0 argument to {$arg1}, found {$arg2}</target>
        </segment>
      </unit>
      <unit id="3746" name="err_expected_class_or_namespace">
        <segment>
          <source>%0 is not a class%select{ or namespace|, namespace, or enumeration}1</source>
          <target>{$arg0} is not a class{$arg1 :select s0=| or namespace| s1=|, namespace, or enumeration|}</target>
        </segment>
      </unit>
      <unit id="3747" name="err_expected_kernel_void_return_type">
        <segment>
          <source>kernel must have void return type</source>
          <target>kernel must have void return type</target>
        </segment>
      </unit>
      <unit id="3748" name="err_expected_name_of_pack">
        <segment>
          <source>%0 does not refer to the name of a parameter pack</source>
          <target>{$arg0} does not refer to the name of a parameter pack</target>
        </segment>
      </unit>
      <unit id="3749" name="err_expected_struct_pointer_argument">
        <segment>
          <source>expected pointer to struct as %ordinal0 argument to %1, found %2</source>
          <target>expected pointer to struct as %ordinal0 argument to {$arg1}, found {$arg2}</target>
        </segment>
      </unit>
      <unit id="3750" name="err_explicit_instantiation_ambiguous">
        <segment>
          <source>partial ordering for explicit instantiation of %0 is ambiguous</source>
          <target>partial ordering for explicit instantiation of {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="3751" name="err_explicit_instantiation_constexpr">
        <segment>
          <source>explicit instantiation cannot be 'constexpr'</source>
          <target>explicit instantiation cannot be 'constexpr'</target>
        </segment>
      </unit>
      <unit id="3752" name="err_explicit_instantiation_data_member_not_instantiated">
        <segment>
          <source>explicit instantiation refers to static data member %q0 that is not an instantiation</source>
          <target>explicit instantiation refers to static data member {$arg0 :q} that is not an instantiation</target>
        </segment>
      </unit>
      <unit id="3753" name="err_explicit_instantiation_declaration_after_definition">
        <segment>
          <source>explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')</source>
          <target>explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')</target>
        </segment>
      </unit>
      <unit id="3754" name="err_explicit_instantiation_dependent">
        <segment>
          <source>explicit instantiation has dependent template arguments</source>
          <target>explicit instantiation has dependent template arguments</target>
        </segment>
      </unit>
      <unit id="3755" name="err_explicit_instantiation_duplicate">
        <segment>
          <source>duplicate explicit instantiation of %0</source>
          <target>duplicate explicit instantiation of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3756" name="err_explicit_instantiation_in_class">
        <segment>
          <source>explicit instantiation of %0 in class scope</source>
          <target>explicit instantiation of {$arg0} in class scope</target>
        </segment>
      </unit>
      <unit id="3757" name="err_explicit_instantiation_inline">
        <segment>
          <source>explicit instantiation cannot be 'inline'</source>
          <target>explicit instantiation cannot be 'inline'</target>
        </segment>
      </unit>
      <unit id="3758" name="err_explicit_instantiation_internal_linkage">
        <segment>
          <source>explicit instantiation declaration of %0 with internal linkage</source>
          <target>explicit instantiation declaration of {$arg0} with internal linkage</target>
        </segment>
      </unit>
      <unit id="3759" name="err_explicit_instantiation_member_function_not_instantiated">
        <segment>
          <source>explicit instantiation refers to member function %q0 that is not an instantiation</source>
          <target>explicit instantiation refers to member function {$arg0 :q} that is not an instantiation</target>
        </segment>
      </unit>
      <unit id="3760" name="err_explicit_instantiation_must_be_global">
        <segment>
          <source>explicit instantiation of %0 must occur at global scope</source>
          <target>explicit instantiation of {$arg0} must occur at global scope</target>
        </segment>
      </unit>
      <unit id="3761" name="err_explicit_instantiation_no_candidate">
        <segment>
          <source>no viable candidate for explicit instantiation of %0</source>
          <target>no viable candidate for explicit instantiation of {$arg0}</target>
        </segment>
      </unit>
      <unit id="3762" name="err_explicit_instantiation_nontemplate_type">
        <segment>
          <source>explicit instantiation of non-templated type %0</source>
          <target>explicit instantiation of non-templated type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3763" name="err_explicit_instantiation_not_known">
        <segment>
          <source>explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member</source>
          <target>explicit instantiation of {$arg0} does not refer to a function template, variable template, member function, member class, or static data member</target>
        </segment>
      </unit>
      <unit id="3764" name="err_explicit_instantiation_of_typedef">
        <segment>
          <source>explicit instantiation of typedef %0</source>
          <target>explicit instantiation of typedef {$arg0}</target>
        </segment>
      </unit>
      <unit id="3765" name="err_explicit_instantiation_out_of_scope">
        <segment>
          <source>explicit instantiation of %0 not in a namespace enclosing %1</source>
          <target>explicit instantiation of {$arg0} not in a namespace enclosing {$arg1}</target>
        </segment>
      </unit>
      <unit id="3766" name="err_explicit_instantiation_requires_name">
        <segment>
          <source>explicit instantiation declaration requires a name</source>
          <target>explicit instantiation declaration requires a name</target>
        </segment>
      </unit>
      <unit id="3767" name="err_explicit_instantiation_storage_class">
        <segment>
          <source>explicit instantiation cannot have a storage class</source>
          <target>explicit instantiation cannot have a storage class</target>
        </segment>
      </unit>
      <unit id="3768" name="err_explicit_instantiation_undefined_func_template">
        <segment>
          <source>explicit instantiation of undefined function template %0</source>
          <target>explicit instantiation of undefined function template {$arg0}</target>
        </segment>
      </unit>
      <unit id="3769" name="err_explicit_instantiation_undefined_member">
        <segment>
          <source>explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2</source>
          <target>explicit instantiation of undefined {$arg0 :select s0=|member class| s1=|member function| s2=|static data member|} {$arg1} of class template {$arg2}</target>
        </segment>
      </unit>
      <unit id="3770" name="err_explicit_instantiation_undefined_var_template">
        <segment>
          <source>explicit instantiation of undefined variable template %q0</source>
          <target>explicit instantiation of undefined variable template {$arg0 :q}</target>
        </segment>
      </unit>
      <unit id="3771" name="err_explicit_instantiation_unqualified_wrong_namespace">
        <segment>
          <source>explicit instantiation of %q0 must occur in namespace %1</source>
          <target>explicit instantiation of {$arg0 :q} must occur in namespace {$arg1}</target>
        </segment>
      </unit>
      <unit id="3772" name="err_explicit_instantiation_without_template_id">
        <segment>
          <source>explicit instantiation of %q0 must specify a template argument list</source>
          <target>explicit instantiation of {$arg0 :q} must specify a template argument list</target>
        </segment>
      </unit>
      <unit id="3773" name="err_explicit_non_ctor_or_conv_function">
        <segment>
          <source>'explicit' can only be applied to a constructor or conversion function</source>
          <target>'explicit' can only be applied to a constructor or conversion function</target>
        </segment>
      </unit>
      <unit id="3774" name="err_explicit_non_function">
        <segment>
          <source>'explicit' can only appear on non-static member functions</source>
          <target>'explicit' can only appear on non-static member functions</target>
        </segment>
      </unit>
      <unit id="3775" name="err_explicit_object_default_arg">
        <segment>
          <source>the explicit object parameter cannot have a default argument</source>
          <target>the explicit object parameter cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="3776" name="err_explicit_object_lambda_ambiguous_base">
        <segment>
          <source>lambda %0 is inaccessible due to ambiguity:%1</source>
          <target>lambda {$arg0} is inaccessible due to ambiguity:{$arg1}</target>
        </segment>
      </unit>
      <unit id="3777" name="err_explicit_object_lambda_inaccessible_base">
        <segment>
          <source>invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda</source>
          <target>invalid explicit object parameter type {$arg0} in lambda with capture; the type must derive publicly from the lambda</target>
        </segment>
      </unit>
      <unit id="3778" name="err_explicit_object_parameter_constructor">
        <segment>
          <source>an explicit object parameter cannot appear in a %select{constructor|destructor}0</source>
          <target>an explicit object parameter cannot appear in a {$arg0 :select s0=|constructor| s1=|destructor|}</target>
        </segment>
      </unit>
      <unit id="3779" name="err_explicit_object_parameter_invalid">
        <segment>
          <source>an explicit object parameter can only appear as the first parameter of a member function</source>
          <target>an explicit object parameter can only appear as the first parameter of a member function</target>
        </segment>
      </unit>
      <unit id="3780" name="err_explicit_object_parameter_must_be_first">
        <segment>
          <source>an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0</source>
          <target>an explicit object parameter can only appear as the first parameter of the {$arg0 :select s0=|function| s1=|lambda|}</target>
        </segment>
      </unit>
      <unit id="3781" name="err_explicit_object_parameter_mutable">
        <segment>
          <source>a lambda with an explicit object parameter cannot be mutable</source>
          <target>a lambda with an explicit object parameter cannot be mutable</target>
        </segment>
      </unit>
      <unit id="3782" name="err_explicit_object_parameter_nonmember">
        <segment>
          <source>an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1</source>
          <target>an explicit object parameter cannot appear in a {$arg0 :select s0=|static| s1=|virtual| s2=|non-member|} {$arg1 :select s0=|function| s1=|lambda|}</target>
        </segment>
      </unit>
      <unit id="3783" name="err_explicit_object_parameter_pack">
        <segment>
          <source>the explicit object parameter cannot be a function parameter pack</source>
          <target>the explicit object parameter cannot be a function parameter pack</target>
        </segment>
      </unit>
      <unit id="3784" name="err_explicit_out_of_class">
        <segment>
          <source>'explicit' can only be specified inside the class definition</source>
          <target>'explicit' can only be specified inside the class definition</target>
        </segment>
      </unit>
      <unit id="3785" name="err_export_anon_ns_internal">
        <segment>
          <source>anonymous namespaces cannot be exported</source>
          <target>anonymous namespaces cannot be exported</target>
        </segment>
      </unit>
      <unit id="3786" name="err_export_in_private_module_fragment">
        <segment>
          <source>export declaration cannot be used in a private module fragment</source>
          <target>export declaration cannot be used in a private module fragment</target>
        </segment>
      </unit>
      <unit id="3787" name="err_export_inline_not_defined">
        <segment>
          <source>inline function not defined%select{| before the private module fragment}0</source>
          <target>inline function not defined{$arg0 :select s0=|| s1=| before the private module fragment|}</target>
        </segment>
      </unit>
      <unit id="3788" name="err_export_internal">
        <segment>
          <source>declaration of %0 with internal linkage cannot be exported</source>
          <target>declaration of {$arg0} with internal linkage cannot be exported</target>
        </segment>
      </unit>
      <unit id="3789" name="err_export_non_namespace_scope_name">
        <segment>
          <source>cannot export %0 as it is not at namespace scope</source>
          <target>cannot export {$arg0} as it is not at namespace scope</target>
        </segment>
      </unit>
      <unit id="3790" name="err_export_not_in_module_interface">
        <segment>
          <source>export declaration can only be used within a module purview</source>
          <target>export declaration can only be used within a module purview</target>
        </segment>
      </unit>
      <unit id="3791" name="err_export_partition_impl">
        <segment>
          <source>module partition implementations cannot be exported</source>
          <target>module partition implementations cannot be exported</target>
        </segment>
      </unit>
      <unit id="3792" name="err_export_using_internal">
        <segment>
          <source>using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported</source>
          <target>using declaration referring to {$arg1} with {$arg0 :select s0=|internal| s1=|module| s2=|unknown|} linkage cannot be exported</target>
        </segment>
      </unit>
      <unit id="3793" name="err_export_within_anonymous_namespace">
        <segment>
          <source>export declaration appears within anonymous namespace</source>
          <target>export declaration appears within anonymous namespace</target>
        </segment>
      </unit>
      <unit id="3794" name="err_export_within_export">
        <segment>
          <source>export declaration appears within another export declaration</source>
          <target>export declaration appears within another export declaration</target>
        </segment>
      </unit>
      <unit id="3795" name="err_expr_not_cce">
        <segment>
          <source state="initial">%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression</source>
          <target>{$arg0 :select s0=|case value| s1=|enumerator value| s2=|non-type template argument| s3=|non-type parameter of template template parameter| s4=|array size| s5=|explicit specifier argument| s6=|noexcept specifier argument| s7=|call to 'size()'| s8=|call to 'data()'|} is not a constant expression</target>
        </segment>
      </unit>
      <unit id="3796" name="err_expr_not_ice">
        <segment>
          <source>expression is not an %select{integer|integral}0 constant expression</source>
          <target>expression is not an {$arg0 :select s0=|integer| s1=|integral|} constant expression</target>
        </segment>
      </unit>
      <unit id="3797" name="err_expr_not_string_literal">
        <segment>
          <source>expression is not a string literal</source>
          <target>expression is not a string literal</target>
        </segment>
      </unit>
      <unit id="3798" name="err_ext_vector_component_exceeds_length">
        <segment>
          <source>vector component access exceeds type %0</source>
          <target>vector component access exceeds type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3799" name="err_ext_vector_component_name_illegal">
        <segment>
          <source state="initial">illegal vector component name %0</source>
          <target>illegal vector component name {$arg0}</target>
        </segment>
      </unit>
      <unit id="3800" name="err_extern_c_global_conflict">
        <segment>
          <source>declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0</source>
          <target>declaration of {$arg1} {$arg0 :select s0=|with C language linkage| s1=|in global scope|} conflicts with declaration {$arg0 :select s0=|in global scope| s1=|with C language linkage|}</target>
        </segment>
      </unit>
      <unit id="3801" name="err_extern_def_in_header_unit">
        <segment>
          <source>non-inline external definitions are not permitted in C++ header units</source>
          <target>non-inline external definitions are not permitted in C++ header units</target>
        </segment>
      </unit>
      <unit id="3802" name="err_extern_non_extern">
        <segment>
          <source>extern declaration of %0 follows non-extern declaration</source>
          <target>extern declaration of {$arg0} follows non-extern declaration</target>
        </segment>
      </unit>
      <unit id="3803" name="err_falloff_nonvoid">
        <segment>
          <source>non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1</source>
          <target>non-void {$arg0 :select s0=|function| s1=|block| s2=|lambda| s3=|coroutine|} does not return a value{$arg1 :select s0=|| s1=| in all control paths|}</target>
        </segment>
      </unit>
      <unit id="3804" name="err_fallthrough_attr_invalid_placement">
        <segment>
          <source>fallthrough annotation does not directly precede switch label</source>
          <target>fallthrough annotation does not directly precede switch label</target>
        </segment>
      </unit>
      <unit id="3805" name="err_fallthrough_attr_outside_switch">
        <segment>
          <source>fallthrough annotation is outside switch statement</source>
          <target>fallthrough annotation is outside switch statement</target>
        </segment>
      </unit>
      <unit id="3806" name="err_fallthrough_attr_wrong_target">
        <segment>
          <source>%0 attribute is only allowed on empty statements</source>
          <target>{$arg0} attribute is only allowed on empty statements</target>
        </segment>
      </unit>
      <unit id="3807" name="err_field_declared_as_function">
        <segment>
          <source>field %0 declared as a function</source>
          <target>field {$arg0} declared as a function</target>
        </segment>
      </unit>
      <unit id="3808" name="err_field_designator_non_aggr">
        <segment>
          <source>field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1</source>
          <target>field designator cannot initialize a {$arg0 :select s0=|non-struct, non-union| s1=|non-class|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3809" name="err_field_designator_nonfield">
        <segment>
          <source>field designator %0 does not refer to a non-static data member</source>
          <target>field designator {$arg0} does not refer to a non-static data member</target>
        </segment>
      </unit>
      <unit id="3810" name="err_field_designator_unknown">
        <segment>
          <source>field designator %0 does not refer to any field in type %1</source>
          <target>field designator {$arg0} does not refer to any field in type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3811" name="err_field_designator_unknown_suggest">
        <segment>
          <source>field designator %0 does not refer to any field in type %1; did you mean %2?</source>
          <target>field designator {$arg0} does not refer to any field in type {$arg1}; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="3812" name="err_field_incomplete_or_sizeless">
        <segment>
          <source>field has %select{incomplete|sizeless}0 type %1</source>
          <target>field has {$arg0 :select s0=|incomplete| s1=|sizeless|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3813" name="err_field_instantiates_to_function">
        <segment>
          <source>data member instantiated with function type %0</source>
          <target>data member instantiated with function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3814" name="err_field_with_address_space">
        <segment>
          <source>field may not be qualified with an address space</source>
          <target>field may not be qualified with an address space</target>
        </segment>
      </unit>
      <unit id="3815" name="err_filter_expression_integral">
        <segment>
          <source>filter expression has non-integral type %0</source>
          <target>filter expression has non-integral type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3816" name="err_final_function_overridden">
        <segment>
          <source>declaration of %0 overrides a '%select{final|sealed}1' function</source>
          <target>declaration of {$arg0} overrides a '{$arg1 :select s0=|final| s1=|sealed|}' function</target>
        </segment>
      </unit>
      <unit id="3817" name="err_first_argument_to_cwsc_block_call">
        <segment>
          <source>first argument to __builtin_call_with_static_chain must not be a block call</source>
          <target>first argument to __builtin_call_with_static_chain must not be a block call</target>
        </segment>
      </unit>
      <unit id="3818" name="err_first_argument_to_cwsc_builtin_call">
        <segment>
          <source>first argument to __builtin_call_with_static_chain must not be a builtin call</source>
          <target>first argument to __builtin_call_with_static_chain must not be a builtin call</target>
        </segment>
      </unit>
      <unit id="3819" name="err_first_argument_to_cwsc_not_call">
        <segment>
          <source>first argument to __builtin_call_with_static_chain must be a non-member call expression</source>
          <target>first argument to __builtin_call_with_static_chain must be a non-member call expression</target>
        </segment>
      </unit>
      <unit id="3820" name="err_first_argument_to_cwsc_pdtor_call">
        <segment>
          <source>first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call</source>
          <target>first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call</target>
        </segment>
      </unit>
      <unit id="3821" name="err_first_argument_to_va_arg_not_of_type_va_list">
        <segment>
          <source>first argument to 'va_arg' is of type %0 and not 'va_list'</source>
          <target>first argument to 'va_arg' is of type {$arg0} and not 'va_list'</target>
        </segment>
      </unit>
      <unit id="3822" name="err_flexible_array_arc_retainable">
        <segment>
          <source>ARC forbids flexible array members with retainable object type</source>
          <target>ARC forbids flexible array members with retainable object type</target>
        </segment>
      </unit>
      <unit id="3823" name="err_flexible_array_has_nontrivial_dtor">
        <segment>
          <source>flexible array member %0 of type %1 with non-trivial destruction</source>
          <target>flexible array member {$arg0} of type {$arg1} with non-trivial destruction</target>
        </segment>
      </unit>
      <unit id="3824" name="err_flexible_array_init">
        <segment>
          <source>initialization of flexible array member is not allowed</source>
          <target>initialization of flexible array member is not allowed</target>
        </segment>
      </unit>
      <unit id="3825" name="err_flexible_array_init_needs_braces">
        <segment>
          <source>flexible array requires brace-enclosed initializer</source>
          <target>flexible array requires brace-enclosed initializer</target>
        </segment>
      </unit>
      <unit id="3826" name="err_flexible_array_not_at_end">
        <segment>
          <source>flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2</source>
          <target>flexible array member {$arg0} with type {$arg1} is not at the end of {$arg2 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|}</target>
        </segment>
      </unit>
      <unit id="3827" name="err_flexible_array_virtual_base">
        <segment>
          <source>flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class</source>
          <target>flexible array member {$arg0} not allowed in {$arg1 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} which has a virtual base class</target>
        </segment>
      </unit>
      <unit id="3828" name="err_fold_expression_bad_operand">
        <segment>
          <source>expression not permitted as operand of fold expression</source>
          <target>expression not permitted as operand of fold expression</target>
        </segment>
      </unit>
      <unit id="3829" name="err_fold_expression_empty">
        <segment>
          <source>unary fold expression has empty expansion for operator '%0' with no fallback value</source>
          <target>unary fold expression has empty expansion for operator '{$arg0}' with no fallback value</target>
        </segment>
      </unit>
      <unit id="3830" name="err_fold_expression_limit_exceeded">
        <segment>
          <source>instantiating fold expression with %0 arguments exceeded expression nesting limit of %1</source>
          <target>instantiating fold expression with {$arg0} arguments exceeded expression nesting limit of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3831" name="err_fold_expression_packs_both_sides">
        <segment>
          <source>binary fold expression has unexpanded parameter packs in both operands</source>
          <target>binary fold expression has unexpanded parameter packs in both operands</target>
        </segment>
      </unit>
      <unit id="3832" name="err_for_range_decl_must_be_var">
        <segment>
          <source>for range declaration must declare a variable</source>
          <target>for range declaration must declare a variable</target>
        </segment>
      </unit>
      <unit id="3833" name="err_for_range_deduction_failure">
        <segment>
          <source>cannot use type %0 as a range</source>
          <target>cannot use type {$arg0} as a range</target>
        </segment>
      </unit>
      <unit id="3834" name="err_for_range_dereference">
        <segment>
          <source>invalid range expression of type %0; did you mean to dereference it with '*'?</source>
          <target>invalid range expression of type {$arg0}; did you mean to dereference it with '*'?</target>
        </segment>
      </unit>
      <unit id="3835" name="err_for_range_incomplete_type">
        <segment>
          <source>cannot use incomplete type %0 as a range</source>
          <target>cannot use incomplete type {$arg0} as a range</target>
        </segment>
      </unit>
      <unit id="3836" name="err_for_range_invalid">
        <segment>
          <source>invalid range expression of type %0; no viable '%select{begin|end}1' function available</source>
          <target>invalid range expression of type {$arg0}; no viable '{$arg1 :select s0=|begin| s1=|end|}' function available</target>
        </segment>
      </unit>
      <unit id="3837" name="err_for_range_iter_deduction_failure">
        <segment>
          <source>cannot use type %0 as an iterator</source>
          <target>cannot use type {$arg0} as an iterator</target>
        </segment>
      </unit>
      <unit id="3838" name="err_for_range_storage_class">
        <segment>
          <source>loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1</source>
          <target>loop variable {$arg0} may not be declared {$arg1 :select s0=|'extern'| s1=|'static'| s2=|'__private_extern__'| s3=|'auto'| s4=|'register'| s5=|'constexpr'| s6=|'thread_local'|}</target>
        </segment>
      </unit>
      <unit id="3839" name="err_format_attribute_implicit_this_format_string">
        <segment>
          <source>format attribute cannot specify the implicit this argument as the format string</source>
          <target>format attribute cannot specify the implicit this argument as the format string</target>
        </segment>
      </unit>
      <unit id="3840" name="err_format_attribute_not">
        <segment>
          <source>format argument not a string type</source>
          <target>format argument not a string type</target>
        </segment>
      </unit>
      <unit id="3841" name="err_format_attribute_result_not">
        <segment>
          <source>function does not return %0</source>
          <target>function does not return {$arg0}</target>
        </segment>
      </unit>
      <unit id="3842" name="err_format_nonliteral">
        <segment>
          <source>format string is not a string literal</source>
          <target>format string is not a string literal</target>
        </segment>
      </unit>
      <unit id="3843" name="err_format_strftime_third_parameter">
        <segment>
          <source>strftime format attribute requires 3rd parameter to be 0</source>
          <target>strftime format attribute requires 3rd parameter to be 0</target>
        </segment>
      </unit>
      <unit id="3844" name="err_forward_ref_enum">
        <segment>
          <source>ISO C++ forbids forward references to 'enum' types</source>
          <target>ISO C++ forbids forward references to 'enum' types</target>
        </segment>
      </unit>
      <unit id="3845" name="err_forward_superclass">
        <segment>
          <source>attempting to use the forward class %0 as superclass of %1</source>
          <target>attempting to use the forward class {$arg0} as superclass of {$arg1}</target>
        </segment>
      </unit>
      <unit id="3846" name="err_found_in_dependent_base">
        <segment>
          <source>explicit qualification required to use member %0 from dependent base class</source>
          <target>explicit qualification required to use member {$arg0} from dependent base class</target>
        </segment>
      </unit>
      <unit id="3847" name="err_found_later_in_class">
        <segment>
          <source>member %0 used before its declaration</source>
          <target>member {$arg0} used before its declaration</target>
        </segment>
      </unit>
      <unit id="3848" name="err_friend_decl_does_not_match">
        <segment>
          <source>friend declaration of %0 does not match any declaration in %1</source>
          <target>friend declaration of {$arg0} does not match any declaration in {$arg1}</target>
        </segment>
      </unit>
      <unit id="3849" name="err_friend_decl_with_def_arg_must_be_def">
        <segment>
          <source>friend declaration specifying a default argument must be a definition</source>
          <target>friend declaration specifying a default argument must be a definition</target>
        </segment>
      </unit>
      <unit id="3850" name="err_friend_decl_with_def_arg_redeclared">
        <segment>
          <source>friend declaration specifying a default argument must be the only declaration</source>
          <target>friend declaration specifying a default argument must be the only declaration</target>
        </segment>
      </unit>
      <unit id="3851" name="err_friend_decl_with_enclosing_temp_constraint_must_be_def">
        <segment>
          <source>friend declaration with a constraint that depends on an enclosing template parameter must be a definition</source>
          <target>friend declaration with a constraint that depends on an enclosing template parameter must be a definition</target>
        </segment>
      </unit>
      <unit id="3852" name="err_friend_def_in_local_class">
        <segment>
          <source>friend function cannot be defined in a local class</source>
          <target>friend function cannot be defined in a local class</target>
        </segment>
      </unit>
      <unit id="3853" name="err_friend_is_member">
        <segment>
          <source>friends cannot be members of the declaring class</source>
          <target>friends cannot be members of the declaring class</target>
        </segment>
      </unit>
      <unit id="3854" name="err_friend_not_first_in_declaration">
        <segment>
          <source>'friend' must appear first in a non-function declaration</source>
          <target>'friend' must appear first in a non-function declaration</target>
        </segment>
      </unit>
      <unit id="3855" name="err_friend_specialization_def">
        <segment>
          <source>friend function specialization cannot be defined</source>
          <target>friend function specialization cannot be defined</target>
        </segment>
      </unit>
      <unit id="3856" name="err_friend_template_decl_multiple_specifiers">
        <segment>
          <source>a friend declaration that befriends a template must contain exactly one type-specifier</source>
          <target>a friend declaration that befriends a template must contain exactly one type-specifier</target>
        </segment>
      </unit>
      <unit id="3857" name="err_func_def_incomplete_result">
        <segment>
          <source>incomplete result type %0 in function definition</source>
          <target>incomplete result type {$arg0} in function definition</target>
        </segment>
      </unit>
      <unit id="3858" name="err_func_returning_array_function">
        <segment>
          <source>function cannot return %select{array|function}0 type %1</source>
          <target>function cannot return {$arg0 :select s0=|array| s1=|function|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3859" name="err_func_returning_qualified_void">
        <segment>
          <source>function cannot return qualified void type %0</source>
          <target>function cannot return qualified void type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3860" name="err_func_with_effects_no_prototype">
        <segment>
          <source>'%0' function must have a prototype</source>
          <target>'{$arg0}' function must have a prototype</target>
        </segment>
      </unit>
      <unit id="3861" name="err_function_attribute_mismatch">
        <segment>
          <source>function declared with %0 attribute was previously declared without the %0 attribute</source>
          <target>function declared with {$arg0} attribute was previously declared without the {$arg0} attribute</target>
        </segment>
      </unit>
      <unit id="3862" name="err_function_decl_cmse_ns_call">
        <segment>
          <source>functions may not be declared with 'cmse_nonsecure_call' attribute</source>
          <target>functions may not be declared with 'cmse_nonsecure_call' attribute</target>
        </segment>
      </unit>
      <unit id="3863" name="err_function_marked_override_not_overriding">
        <segment>
          <source>%0 marked 'override' but does not override any member functions</source>
          <target>{$arg0} marked 'override' but does not override any member functions</target>
        </segment>
      </unit>
      <unit id="3864" name="err_function_member_spec_ambiguous">
        <segment>
          <source>ambiguous member function specialization %q0 of %q1</source>
          <target>ambiguous member function specialization {$arg0 :q} of {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="3865" name="err_function_parameter_pack_without_parameter_packs">
        <segment>
          <source>type %0 of function parameter pack does not contain any unexpanded parameter packs</source>
          <target>type {$arg0} of function parameter pack does not contain any unexpanded parameter packs</target>
        </segment>
      </unit>
      <unit id="3866" name="err_function_start_invalid_type">
        <segment>
          <source>argument must be a function</source>
          <target>argument must be a function</target>
        </segment>
      </unit>
      <unit id="3867" name="err_function_template_partial_spec">
        <segment>
          <source>function template partial specialization is not allowed</source>
          <target>function template partial specialization is not allowed</target>
        </segment>
      </unit>
      <unit id="3868" name="err_function_template_spec_ambiguous">
        <segment>
          <source>function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template</source>
          <target>function template specialization {$arg0} ambiguously refers to more than one function template; explicitly specify{$arg1 :select s0=|| s1=| additional|} template arguments to identify a particular function template</target>
        </segment>
      </unit>
      <unit id="3869" name="err_function_template_spec_no_match">
        <segment>
          <source>no function template matches function template specialization %0</source>
          <target>no function template matches function template specialization {$arg0}</target>
        </segment>
      </unit>
      <unit id="3870" name="err_gc_weak_property_strong_type">
        <segment>
          <source>weak attribute declared on a __strong type property in GC mode</source>
          <target>weak attribute declared on a __strong type property in GC mode</target>
        </segment>
      </unit>
      <unit id="3871" name="err_generic_sel_multi_match">
        <segment>
          <source>controlling expression type %0 compatible with %1 generic association types</source>
          <target>controlling expression type {$arg0} compatible with {$arg1} generic association types</target>
        </segment>
      </unit>
      <unit id="3872" name="err_generic_sel_no_match">
        <segment>
          <source>controlling expression type %0 not compatible with any generic association type</source>
          <target>controlling expression type {$arg0} not compatible with any generic association type</target>
        </segment>
      </unit>
      <unit id="3873" name="err_getter_not_found">
        <segment>
          <source>no getter method for read from property</source>
          <target>no getter method for read from property</target>
        </segment>
      </unit>
      <unit id="3874" name="err_global_call_not_config">
        <segment>
          <source>call to global function %0 not configured</source>
          <target>call to global function {$arg0} not configured</target>
        </segment>
      </unit>
      <unit id="3875" name="err_goto_into_protected_scope">
        <segment>
          <source>cannot jump from this goto statement to its label</source>
          <target>cannot jump from this goto statement to its label</target>
        </segment>
      </unit>
      <unit id="3876" name="err_goto_ms_asm_label">
        <segment>
          <source>cannot jump from this goto statement to label %0 inside an inline assembly block</source>
          <target>cannot jump from this goto statement to label {$arg0} inside an inline assembly block</target>
        </segment>
      </unit>
      <unit id="3877" name="err_half_const_requires_fp16">
        <segment>
          <source>half precision constant requires cl_khr_fp16</source>
          <target>half precision constant requires cl_khr_fp16</target>
        </segment>
      </unit>
      <unit id="3878" name="err_hip_invalid_args_builtin_mangled_name">
        <segment>
          <source>invalid argument: symbol must be a device-side function or global variable</source>
          <target>invalid argument: symbol must be a device-side function or global variable</target>
        </segment>
      </unit>
      <unit id="3879" name="err_hlsl_attr_invalid_ast_node">
        <segment>
          <source>attribute %0 only applies to %1</source>
          <target>attribute {$arg0} only applies to {$arg1}</target>
        </segment>
      </unit>
      <unit id="3880" name="err_hlsl_attr_invalid_type">
        <segment>
          <source>attribute %0 only applies to a field or parameter of type '%1'</source>
          <target>attribute {$arg0} only applies to a field or parameter of type '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="3881" name="err_hlsl_attr_unsupported_in_stage">
        <segment>
          <source>attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3</source>
          <target>attribute {$arg0} is unsupported in '{$arg1}' shaders, requires {$arg2 :select s0=|| s1=|one of the following: |}{$arg3}</target>
        </segment>
      </unit>
      <unit id="3882" name="err_hlsl_attribute_in_wrong_shader_model">
        <segment>
          <source>attribute %0 requires shader model %1 or greater</source>
          <target>attribute {$arg0} requires shader model {$arg1} or greater</target>
        </segment>
      </unit>
      <unit id="3883" name="err_hlsl_attribute_needs_intangible_type">
        <segment>
          <source>attribute %0 can be used only on HLSL intangible type %1</source>
          <target>attribute {$arg0} can be used only on HLSL intangible type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3884" name="err_hlsl_attribute_number_arguments_insufficient_shader_model">
        <segment>
          <source>attribute %0 with %1 arguments requires shader model %2 or greater</source>
          <target>attribute {$arg0} with {$arg1} arguments requires shader model {$arg2} or greater</target>
        </segment>
      </unit>
      <unit id="3885" name="err_hlsl_attribute_param_mismatch">
        <segment>
          <source>%0 attribute parameters do not match the previous declaration</source>
          <target>{$arg0} attribute parameters do not match the previous declaration</target>
        </segment>
      </unit>
      <unit id="3886" name="err_hlsl_binding_type_invalid">
        <segment>
          <source>binding type '%0' is invalid</source>
          <target>binding type '{$arg0}' is invalid</target>
        </segment>
      </unit>
      <unit id="3887" name="err_hlsl_binding_type_mismatch">
        <segment>
          <source>binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0</source>
          <target>binding type '{$arg0 :select s0=|t| s1=|u| s2=|b| s3=|s| s4=|c|}' only applies to {$arg0 :select s0=|SRV resources| s1=|UAV resources| s2=|constant buffer resources| s3=|sampler state| s4=|numeric variables in the global scope|}</target>
        </segment>
      </unit>
      <unit id="3888" name="err_hlsl_builtin_scalar_vector_mismatch">
        <segment>
          <source>%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3</source>
          <target>{$arg0 :select s0=|all| s1=|second and third|} arguments to {$arg1} must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3</target>
        </segment>
      </unit>
      <unit id="3889" name="err_hlsl_duplicate_parameter_modifier">
        <segment>
          <source>duplicate parameter modifier %0</source>
          <target>duplicate parameter modifier {$arg0}</target>
        </segment>
      </unit>
      <unit id="3890" name="err_hlsl_duplicate_register_annotation">
        <segment>
          <source>binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once</source>
          <target>binding type '{$arg0 :select s0=|t| s1=|u| s2=|b| s3=|s| s4=|c| s5=|i|}' cannot be applied more than once</target>
        </segment>
      </unit>
      <unit id="3891" name="err_hlsl_entry_shader_attr_mismatch">
        <segment>
          <source>%0 attribute on entry function does not match the target profile</source>
          <target>{$arg0} attribute on entry function does not match the target profile</target>
        </segment>
      </unit>
      <unit id="3892" name="err_hlsl_expect_arg_const_int_one_or_neg_one">
        <segment>
          <source>argument %0 must be constant integer 1 or -1</source>
          <target>argument {$arg0} must be constant integer 1 or -1</target>
        </segment>
      </unit>
      <unit id="3893" name="err_hlsl_expected_space">
        <segment>
          <source>invalid space specifier '%0' used; expected 'space' followed by an integer, like space1</source>
          <target>invalid space specifier '{$arg0}' used; expected 'space' followed by an integer, like space1</target>
        </segment>
      </unit>
      <unit id="3894" name="err_hlsl_export_not_on_function">
        <segment>
          <source>export declaration can only be used on functions</source>
          <target>export declaration can only be used on functions</target>
        </segment>
      </unit>
      <unit id="3895" name="err_hlsl_incorrect_num_initializers">
        <segment>
          <source>too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)</source>
          <target>too {$arg0 :select s0=|few| s1=|many|} initializers in list for type {$arg1} (expected {$arg2} but found {$arg3})</target>
        </segment>
      </unit>
      <unit id="3896" name="err_hlsl_init_priority_unsupported">
        <segment>
          <source>initializer priorities are not supported in HLSL</source>
          <target>initializer priorities are not supported in HLSL</target>
        </segment>
      </unit>
      <unit id="3897" name="err_hlsl_missing_numthreads">
        <segment>
          <source>missing numthreads attribute for %0 shader entry</source>
          <target>missing numthreads attribute for {$arg0} shader entry</target>
        </segment>
      </unit>
      <unit id="3898" name="err_hlsl_missing_resource_class">
        <segment>
          <source>HLSL resource needs to have [[hlsl::resource_class()]] attribute</source>
          <target>HLSL resource needs to have [[hlsl::resource_class()]] attribute</target>
        </segment>
      </unit>
      <unit id="3899" name="err_hlsl_missing_semantic_annotation">
        <segment>
          <source>semantic annotations must be present for all parameters of an entry function or patch constant function</source>
          <target>semantic annotations must be present for all parameters of an entry function or patch constant function</target>
        </segment>
      </unit>
      <unit id="3900" name="err_hlsl_numthreads_argument_oor">
        <segment>
          <source>argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1</source>
          <target>argument '{$arg0 :select s0=|X| s1=|Y| s2=|Z|}' to numthreads attribute cannot exceed {$arg1}</target>
        </segment>
      </unit>
      <unit id="3901" name="err_hlsl_numthreads_invalid">
        <segment>
          <source>total number of threads cannot exceed %0</source>
          <target>total number of threads cannot exceed {$arg0}</target>
        </segment>
      </unit>
      <unit id="3902" name="err_hlsl_operator_unsupported">
        <segment>
          <source>the '%select{&amp;|*|-&gt;}0' operator is unsupported in HLSL</source>
          <target>the '{$arg0 :select s0=|&amp;| s1=|*| s2=|-&gt;|}' operator is unsupported in HLSL</target>
        </segment>
      </unit>
      <unit id="3903" name="err_hlsl_packoffset_alignment_mismatch">
        <segment>
          <source>packoffset at 'y' not match alignment %0 required by %1</source>
          <target>packoffset at 'y' not match alignment {$arg0} required by {$arg1}</target>
        </segment>
      </unit>
      <unit id="3904" name="err_hlsl_packoffset_cross_reg_boundary">
        <segment>
          <source>packoffset cannot cross register boundary</source>
          <target>packoffset cannot cross register boundary</target>
        </segment>
      </unit>
      <unit id="3905" name="err_hlsl_packoffset_overlap">
        <segment>
          <source>packoffset overlap between %0, %1</source>
          <target>packoffset overlap between {$arg0}, {$arg1}</target>
        </segment>
      </unit>
      <unit id="3906" name="err_hlsl_param_qualifier_mismatch">
        <segment>
          <source>conflicting parameter qualifier %0 on parameter %1</source>
          <target>conflicting parameter qualifier {$arg0} on parameter {$arg1}</target>
        </segment>
      </unit>
      <unit id="3907" name="err_hlsl_pointers_unsupported">
        <segment>
          <source>%select{pointers|references}0 are unsupported in HLSL</source>
          <target>{$arg0 :select s0=|pointers| s1=|references|} are unsupported in HLSL</target>
        </segment>
      </unit>
      <unit id="3908" name="err_hlsl_space_on_global_constant">
        <segment>
          <source>register space cannot be specified on global constants</source>
          <target>register space cannot be specified on global constants</target>
        </segment>
      </unit>
      <unit id="3909" name="err_hlsl_unsupported_register_number">
        <segment>
          <source>register number should be an integer</source>
          <target>register number should be an integer</target>
        </segment>
      </unit>
      <unit id="3910" name="err_hlsl_vector_compound_assignment_truncation">
        <segment>
          <source>left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1</source>
          <target>left hand operand of type {$arg0} to compound assignment cannot be truncated when used with right hand operand of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3911" name="err_iboutletcollection_builtintype">
        <segment>
          <source>type argument of iboutletcollection attribute cannot be a builtin type</source>
          <target>type argument of iboutletcollection attribute cannot be a builtin type</target>
        </segment>
      </unit>
      <unit id="3912" name="err_iboutletcollection_type">
        <segment>
          <source>invalid type %0 as argument of iboutletcollection attribute</source>
          <target>invalid type {$arg0} as argument of iboutletcollection attribute</target>
        </segment>
      </unit>
      <unit id="3913" name="err_ice_ambiguous_conversion">
        <segment>
          <source>ambiguous conversion from type %0 to an integral or unscoped enumeration type</source>
          <target>ambiguous conversion from type {$arg0} to an integral or unscoped enumeration type</target>
        </segment>
      </unit>
      <unit id="3914" name="err_ice_explicit_conversion">
        <segment>
          <source>integral constant expression requires explicit conversion from %0 to %1</source>
          <target>integral constant expression requires explicit conversion from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="3915" name="err_ice_incomplete_type">
        <segment>
          <source>integral constant expression has incomplete class type %0</source>
          <target>integral constant expression has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3916" name="err_ice_not_integral">
        <segment>
          <source>%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0</source>
          <target>{$arg1 :select s0=|integer| s1=|integral|} constant expression must have {$arg1 :select s0=|integer| s1=|integral or unscoped enumeration|} type, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="3917" name="err_ice_too_large">
        <segment>
          <source>integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type</source>
          <target>integer constant expression evaluates to value {$arg0} that cannot be represented in a {$arg1}-bit {$arg2 :select s0=|signed| s1=|unsigned|} integer type</target>
        </segment>
      </unit>
      <unit id="3918" name="err_ident_list_in_fn_declaration">
        <segment>
          <source>a parameter list without types is only allowed in a function definition</source>
          <target>a parameter list without types is only allowed in a function definition</target>
        </segment>
      </unit>
      <unit id="3919" name="err_illegal_container_subscripting_op">
        <segment>
          <source>illegal operation on Objective-C container subscripting</source>
          <target>illegal operation on Objective-C container subscripting</target>
        </segment>
      </unit>
      <unit id="3920" name="err_illegal_decl_array_of_functions">
        <segment>
          <source>'%0' declared as array of functions of type %1</source>
          <target>'{$arg0}' declared as array of functions of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3921" name="err_illegal_decl_array_of_references">
        <segment>
          <source>'%0' declared as array of references of type %1</source>
          <target>'{$arg0}' declared as array of references of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3922" name="err_illegal_decl_mempointer_in_nonclass">
        <segment>
          <source state="initial">%0 does not point into a class</source>
          <target>{$arg0} does not point into a class</target>
        </segment>
      </unit>
      <unit id="3923" name="err_illegal_decl_mempointer_to_reference">
        <segment>
          <source>'%0' declared as a member pointer to a reference of type %1</source>
          <target>'{$arg0}' declared as a member pointer to a reference of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3924" name="err_illegal_decl_mempointer_to_void">
        <segment>
          <source>'%0' declared as a member pointer to void</source>
          <target>'{$arg0}' declared as a member pointer to void</target>
        </segment>
      </unit>
      <unit id="3925" name="err_illegal_decl_pointer_to_reference">
        <segment>
          <source>'%0' declared as a pointer to a reference of type %1</source>
          <target>'{$arg0}' declared as a pointer to a reference of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3926" name="err_illegal_initializer">
        <segment>
          <source>illegal initializer (only variables can be initialized)</source>
          <target>illegal initializer (only variables can be initialized)</target>
        </segment>
      </unit>
      <unit id="3927" name="err_illegal_initializer_type">
        <segment>
          <source>illegal initializer type %0</source>
          <target>illegal initializer type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3928" name="err_illegal_message_expr_incomplete_type">
        <segment>
          <source>Objective-C message has incomplete result type %0</source>
          <target>Objective-C message has incomplete result type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3929" name="err_illegal_qualifiers_on_catch_parm">
        <segment>
          <source>illegal qualifiers on @catch parameter</source>
          <target>illegal qualifiers on @catch parameter</target>
        </segment>
      </unit>
      <unit id="3930" name="err_illegal_union_or_anon_struct_member">
        <segment>
          <source>%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2</source>
          <target>{$arg0 :select s0=|anonymous struct| s1=|union|} member {$arg1} has a non-trivial {$arg2 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|}</target>
        </segment>
      </unit>
      <unit id="3931" name="err_imaginary_not_supported">
        <segment>
          <source>imaginary types are not supported</source>
          <target>imaginary types are not supported</target>
        </segment>
      </unit>
      <unit id="3932" name="err_immediate_function_used_before_definition">
        <segment>
          <source>immediate function %0 used before it is defined</source>
          <target>immediate function {$arg0} used before it is defined</target>
        </segment>
      </unit>
      <unit id="3933" name="err_impcast_complex_scalar">
        <segment>
          <source>implicit conversion from %0 to %1 is not permitted in C++</source>
          <target>implicit conversion from {$arg0} to {$arg1} is not permitted in C++</target>
        </segment>
      </unit>
      <unit id="3934" name="err_implementation_of_class_stub">
        <segment>
          <source>cannot declare implementation of a class declared with the 'objc_class_stub' attribute</source>
          <target>cannot declare implementation of a class declared with the 'objc_class_stub' attribute</target>
        </segment>
      </unit>
      <unit id="3935" name="err_implicit_coroutine_std_nothrow_type_not_found">
        <segment>
          <source>std::nothrow was not found; include &lt;new&gt; before defining a coroutine which uses get_return_object_on_allocation_failure()</source>
          <target>std::nothrow was not found; include &lt;new&gt; before defining a coroutine which uses get_return_object_on_allocation_failure()</target>
        </segment>
      </unit>
      <unit id="3936" name="err_implicit_empty_initializer">
        <segment>
          <source>initializer for aggregate with no elements requires explicit braces</source>
          <target>initializer for aggregate with no elements requires explicit braces</target>
        </segment>
      </unit>
      <unit id="3937" name="err_implicit_instantiate_member_undefined">
        <segment>
          <source>implicit instantiation of undefined member %0</source>
          <target>implicit instantiation of undefined member {$arg0}</target>
        </segment>
      </unit>
      <unit id="3938" name="err_implied_comparison_category_type_not_found">
        <segment>
          <source>cannot %select{use builtin operator '&lt;=&gt;'|default 'operator&lt;=&gt;'}1 because type '%0' was not found; include &lt;compare&gt;</source>
          <target>cannot {$arg1 :select s0=|use builtin operator '&lt;=&gt;'| s1=|default 'operator&lt;=&gt;'|} because type '{$arg0}' was not found; include &lt;compare&gt;</target>
        </segment>
      </unit>
      <unit id="3939" name="err_implied_coroutine_type_not_found">
        <segment>
          <source>%0 type was not found; include &lt;coroutine&gt; before defining a coroutine</source>
          <target>{$arg0} type was not found; include &lt;coroutine&gt; before defining a coroutine</target>
        </segment>
      </unit>
      <unit id="3940" name="err_implied_std_coroutine_traits_promise_type_not_class">
        <segment>
          <source>this function cannot be a coroutine: %0 is not a class</source>
          <target>this function cannot be a coroutine: {$arg0} is not a class</target>
        </segment>
      </unit>
      <unit id="3941" name="err_implied_std_coroutine_traits_promise_type_not_found">
        <segment>
          <source>this function cannot be a coroutine: %q0 has no member named 'promise_type'</source>
          <target>this function cannot be a coroutine: {$arg0 :q} has no member named 'promise_type'</target>
        </segment>
      </unit>
      <unit id="3942" name="err_implied_std_initializer_list_not_found">
        <segment>
          <source>cannot deduce type of initializer list because std::initializer_list was not found; include &lt;initializer_list&gt;</source>
          <target>cannot deduce type of initializer list because std::initializer_list was not found; include &lt;initializer_list&gt;</target>
        </segment>
      </unit>
      <unit id="3943" name="err_in_class_initializer_bad_type">
        <segment>
          <source>static data member of type %0 must be initialized out of line</source>
          <target>static data member of type {$arg0} must be initialized out of line</target>
        </segment>
      </unit>
      <unit id="3944" name="err_in_class_initializer_literal_type">
        <segment>
          <source>in-class initializer for static data member of type %0 requires 'constexpr' specifier</source>
          <target>in-class initializer for static data member of type {$arg0} requires 'constexpr' specifier</target>
        </segment>
      </unit>
      <unit id="3945" name="err_in_class_initializer_non_const">
        <segment>
          <source>non-const static data member must be initialized out of line</source>
          <target>non-const static data member must be initialized out of line</target>
        </segment>
      </unit>
      <unit id="3946" name="err_in_class_initializer_non_constant">
        <segment>
          <source>in-class initializer for static data member is not a constant expression</source>
          <target>in-class initializer for static data member is not a constant expression</target>
        </segment>
      </unit>
      <unit id="3947" name="err_in_class_initializer_volatile">
        <segment>
          <source>static const volatile data member must be initialized out of line</source>
          <target>static const volatile data member must be initialized out of line</target>
        </segment>
      </unit>
      <unit id="3948" name="err_incompatible_exception_specs">
        <segment>
          <source>target exception specification is not superset of source</source>
          <target>target exception specification is not superset of source</target>
        </segment>
      </unit>
      <unit id="3949" name="err_incompatible_qualified_id">
        <segment>
          <source>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2</source>
          <target>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2</target>
        </segment>
      </unit>
      <unit id="3950" name="err_incompatible_replacement_type">
        <segment>
          <source>API notes replacement type %0 has a different size from original type %1</source>
          <target>API notes replacement type {$arg0} has a different size from original type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3951" name="err_incompatible_vectors">
        <segment>
          <source>incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</source>
          <target>incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</target>
        </segment>
      </unit>
      <unit id="3952" name="err_incomplete_base_class">
        <segment>
          <source>base class has incomplete type</source>
          <target>base class has incomplete type</target>
        </segment>
      </unit>
      <unit id="3953" name="err_incomplete_enum">
        <segment>
          <source>enumeration %0 is incomplete</source>
          <target>enumeration {$arg0} is incomplete</target>
        </segment>
      </unit>
      <unit id="3954" name="err_incomplete_in_exception_spec">
        <segment>
          <source>%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification</source>
          <target>{$arg0 :select s0=|| s1=|pointer to | s2=|reference to |}incomplete type {$arg1} is not allowed in exception specification</target>
        </segment>
      </unit>
      <unit id="3955" name="err_incomplete_member_access">
        <segment>
          <source>member access into incomplete type %0</source>
          <target>member access into incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3956" name="err_incomplete_nested_name_spec">
        <segment>
          <source>incomplete type %0 named in nested name specifier</source>
          <target>incomplete type {$arg0} named in nested name specifier</target>
        </segment>
      </unit>
      <unit id="3957" name="err_incomplete_object_call">
        <segment>
          <source>incomplete type in call to object of type %0</source>
          <target>incomplete type in call to object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3958" name="err_incomplete_receiver_type">
        <segment>
          <source>incomplete receiver type %0</source>
          <target>incomplete receiver type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3959" name="err_incomplete_synthesized_property">
        <segment>
          <source>cannot synthesize property %0 with incomplete type %1</source>
          <target>cannot synthesize property {$arg0} with incomplete type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3960" name="err_incomplete_type">
        <segment>
          <source>incomplete type %0 where a complete type is required</source>
          <target>incomplete type {$arg0} where a complete type is required</target>
        </segment>
      </unit>
      <unit id="3961" name="err_incomplete_type_objc_at_encode">
        <segment>
          <source>'@encode' of incomplete type %0</source>
          <target>'@encode' of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3962" name="err_incomplete_type_used_in_type_trait_expr">
        <segment>
          <source>incomplete type %0 used in type trait expression</source>
          <target>incomplete type {$arg0} used in type trait expression</target>
        </segment>
      </unit>
      <unit id="3963" name="err_incomplete_type_vtable_pointer_auth">
        <segment>
          <source>cannot set vtable pointer authentication on an incomplete type %0</source>
          <target>cannot set vtable pointer authentication on an incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3964" name="err_incomplete_typeid">
        <segment>
          <source>'typeid' of incomplete type %0</source>
          <target>'typeid' of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3965" name="err_inconsistent_deduction">
        <segment>
          <source>conflicting deduction %diff{$ against $|types}0,1 for parameter</source>
          <target>conflicting deduction %diff{$ against $|types}0,1 for parameter</target>
        </segment>
      </unit>
      <unit id="3966" name="err_inconsistent_ivar_count">
        <segment>
          <source>inconsistent number of instance variables specified</source>
          <target>inconsistent number of instance variables specified</target>
        </segment>
      </unit>
      <unit id="3967" name="err_incorrect_defaulted_constexpr">
        <segment>
          <source>defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23</source>
          <target>defaulted definition of {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} cannot be marked {$arg1 :select s0=|constexpr| s1=|consteval|} before C++23</target>
        </segment>
      </unit>
      <unit id="3968" name="err_incorrect_defaulted_constexpr_with_vb">
        <segment>
          <source>%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class</source>
          <target>{$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} cannot be 'constexpr' in a class with virtual base class</target>
        </segment>
      </unit>
      <unit id="3969" name="err_incorrect_number_of_vector_initializers">
        <segment>
          <source>number of elements must be either one or match the size of the vector</source>
          <target>number of elements must be either one or match the size of the vector</target>
        </segment>
      </unit>
      <unit id="3970" name="err_increment_decrement_enum">
        <segment>
          <source>cannot %select{decrement|increment}0 expression of enum type %1</source>
          <target>cannot {$arg0 :select s0=|decrement| s1=|increment|} expression of enum type {$arg1}</target>
        </segment>
      </unit>
      <unit id="3971" name="err_indirect_goto_in_protected_scope">
        <segment>
          <source>cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets</source>
          <target>cannot jump from this {$arg0 :select s0=|indirect| s1=|asm|} goto statement to one of its possible targets</target>
        </segment>
      </unit>
      <unit id="3972" name="err_indirect_goto_without_addrlabel">
        <segment>
          <source>indirect goto in function with no address-of-label expressions</source>
          <target>indirect goto in function with no address-of-label expressions</target>
        </segment>
      </unit>
      <unit id="3973" name="err_init_capture_deduction_failure">
        <segment>
          <source>cannot deduce type for lambda capture %0 from initializer of type %2</source>
          <target>cannot deduce type for lambda capture {$arg0} from initializer of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="3974" name="err_init_capture_deduction_failure_from_init_list">
        <segment>
          <source>cannot deduce type for lambda capture %0 from initializer list</source>
          <target>cannot deduce type for lambda capture {$arg0} from initializer list</target>
        </segment>
      </unit>
      <unit id="3975" name="err_init_capture_multiple_expressions">
        <segment>
          <source>initializer for lambda capture %0 contains multiple expressions</source>
          <target>initializer for lambda capture {$arg0} contains multiple expressions</target>
        </segment>
      </unit>
      <unit id="3976" name="err_init_capture_no_expression">
        <segment>
          <source>initializer missing for lambda capture %0</source>
          <target>initializer missing for lambda capture {$arg0}</target>
        </segment>
      </unit>
      <unit id="3977" name="err_init_capture_paren_braces">
        <segment>
          <source>cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list</source>
          <target>cannot deduce type for lambda capture {$arg1} from {$arg0 :select s0=|parenthesized| s1=|nested|} initializer list</target>
        </segment>
      </unit>
      <unit id="3978" name="err_init_conversion_failed">
        <segment>
          <source>cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4</source>
          <target>cannot initialize {$arg0 :select s0=|a variable| s1=|a parameter| s2=|template parameter| s3=|return object| s4=|statement expression result| s5=|an exception object| s6=|a member subobject| s7=|an array element| s8=|a new value| s9=|a value| s10=|a base class| s11=|a constructor delegation| s12=|a vector element| s13=|a block element| s14=|a block element| s15=|a complex element| s16=|a lambda capture| s17=|a compound literal initializer| s18=|a related result| s19=|a parameter of CF audited function| s20=|a structured binding| s21=|a member subobject|} %diff{of type $ with an {$arg2 :select s0=|rvalue| s1=|lvalue|} of type $|with an {$arg1 :select s0=|rvalue| s1=|lvalue}2 of incompatible type|},3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters ({$arg5} vs {$arg6})|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers ({$arg5} vs {$arg6})|: different exception specifications}4</target>
        </segment>
      </unit>
      <unit id="3979" name="err_init_element_not_constant">
        <segment>
          <source>initializer element is not a compile-time constant</source>
          <target>initializer element is not a compile-time constant</target>
        </segment>
      </unit>
      <unit id="3980" name="err_init_for_function_type">
        <segment>
          <source>cannot create object of function type %0</source>
          <target>cannot create object of function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3981" name="err_init_incomplete_type">
        <segment>
          <source>initialization of incomplete type %0</source>
          <target>initialization of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3982" name="err_init_list_bad_dest_type">
        <segment>
          <source>%select{|non-aggregate }0type %1 cannot be initialized with an initializer list</source>
          <target>{$arg0 :select s0=|| s1=|non-aggregate |}type {$arg1} cannot be initialized with an initializer list</target>
        </segment>
      </unit>
      <unit id="3983" name="err_init_method_bad_return_type">
        <segment>
          <source>init methods must return an object pointer type, not %0</source>
          <target>init methods must return an object pointer type, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="3984" name="err_init_non_aggr_init_list">
        <segment>
          <source>initialization of non-aggregate type %0 with an initializer list</source>
          <target>initialization of non-aggregate type {$arg0} with an initializer list</target>
        </segment>
      </unit>
      <unit id="3985" name="err_init_objc_class">
        <segment>
          <source>cannot initialize Objective-C class type %0</source>
          <target>cannot initialize Objective-C class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="3986" name="err_init_priority_object_attr">
        <segment>
          <source>can only use 'init_priority' attribute on file-scope definitions of objects of class type</source>
          <target>can only use 'init_priority' attribute on file-scope definitions of objects of class type</target>
        </segment>
      </unit>
      <unit id="3987" name="err_init_reference_member_uninitialized">
        <segment>
          <source>reference member of type %0 uninitialized</source>
          <target>reference member of type {$arg0} uninitialized</target>
        </segment>
      </unit>
      <unit id="3988" name="err_initializer_overrides_destructed">
        <segment>
          <source>initializer would partially override prior initialization of object of type %1 with non-trivial destruction</source>
          <target>initializer would partially override prior initialization of object of type {$arg1} with non-trivial destruction</target>
        </segment>
      </unit>
      <unit id="3989" name="err_initializer_string_for_char_array_too_long">
        <segment>
          <source>initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)</source>
          <target>initializer-string for char array is too long, array size is {$arg0} but initializer has size {$arg1} (including the null terminating character)</target>
        </segment>
      </unit>
      <unit id="3990" name="err_inline_decl_follows_def">
        <segment>
          <source>inline declaration of %0 follows non-inline definition</source>
          <target>inline declaration of {$arg0} follows non-inline definition</target>
        </segment>
      </unit>
      <unit id="3991" name="err_inline_declaration_block_scope">
        <segment>
          <source>inline declaration of %0 not allowed in block scope</source>
          <target>inline declaration of {$arg0} not allowed in block scope</target>
        </segment>
      </unit>
      <unit id="3992" name="err_inline_main">
        <segment>
          <source>'main' is not allowed to be declared inline</source>
          <target>'main' is not allowed to be declared inline</target>
        </segment>
      </unit>
      <unit id="3993" name="err_inline_namespace_mismatch">
        <segment>
          <source>non-inline namespace cannot be reopened as inline</source>
          <target>non-inline namespace cannot be reopened as inline</target>
        </segment>
      </unit>
      <unit id="3994" name="err_inline_namespace_std">
        <segment>
          <source>cannot declare the namespace 'std' to be inline</source>
          <target>cannot declare the namespace 'std' to be inline</target>
        </segment>
      </unit>
      <unit id="3995" name="err_inline_non_function">
        <segment>
          <source>'inline' can only appear on functions%select{| and non-local variables}0</source>
          <target>'inline' can only appear on functions{$arg0 :select s0=|| s1=| and non-local variables|}</target>
        </segment>
      </unit>
      <unit id="3996" name="err_int_to_block_pointer">
        <segment>
          <source>invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</source>
          <target>invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</target>
        </segment>
      </unit>
      <unit id="3997" name="err_integer_incorrect_bit_count">
        <segment>
          <source>incorrect number of bits in integer (expected %0 bits, have %1)</source>
          <target>incorrect number of bits in integer (expected {$arg0} bits, have {$arg1})</target>
        </segment>
      </unit>
      <unit id="3998" name="err_integer_sequence_integral_element_type">
        <segment>
          <source>integer sequences must have integral element type</source>
          <target>integer sequences must have integral element type</target>
        </segment>
      </unit>
      <unit id="3999" name="err_integer_sequence_negative_length">
        <segment>
          <source>integer sequences must have non-negative sequence length</source>
          <target>integer sequences must have non-negative sequence length</target>
        </segment>
      </unit>
      <unit id="4000" name="err_introducing_special_friend">
        <segment>
          <source>%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend</source>
          <target>%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a {$arg0 :select s0=|constructor| s1=|destructor| s2=|conversion operator| s3=|deduction guide|} as a friend</target>
        </segment>
      </unit>
      <unit id="4001" name="err_invalid_address_discrimination">
        <segment>
          <source>invalid address discrimination mode %0</source>
          <target>invalid address discrimination mode {$arg0}</target>
        </segment>
      </unit>
      <unit id="4002" name="err_invalid_asm_value_for_constraint">
        <segment>
          <source>value '%0' out of range for constraint '%1'</source>
          <target>value '{$arg0}' out of range for constraint '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4003" name="err_invalid_astype_of_different_size">
        <segment>
          <source>invalid reinterpretation: sizes of %0 and %1 must match</source>
          <target>invalid reinterpretation: sizes of {$arg0} and {$arg1} must match</target>
        </segment>
      </unit>
      <unit id="4004" name="err_invalid_authentication_key">
        <segment>
          <source>invalid authentication key %0</source>
          <target>invalid authentication key {$arg0}</target>
        </segment>
      </unit>
      <unit id="4005" name="err_invalid_base_in_interface">
        <segment>
          <source>interface type cannot inherit from %select{struct|non-public interface|class}0 %1</source>
          <target>interface type cannot inherit from {$arg0 :select s0=|struct| s1=|non-public interface| s2=|class|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="4006" name="err_invalid_branch_protection_spec">
        <segment>
          <source>invalid or misplaced branch protection specification '%0'</source>
          <target>invalid or misplaced branch protection specification '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4007" name="err_invalid_collection_element">
        <segment>
          <source>collection element of type %0 is not an Objective-C object</source>
          <target>collection element of type {$arg0} is not an Objective-C object</target>
        </segment>
      </unit>
      <unit id="4008" name="err_invalid_complex_spec">
        <segment>
          <source>'_Complex %0' is invalid</source>
          <target>'_Complex {$arg0}' is invalid</target>
        </segment>
      </unit>
      <unit id="4009" name="err_invalid_consteval_call">
        <segment>
          <source>call to %select{immediate|consteval}1 function %q0 is not a constant expression</source>
          <target>call to {$arg1 :select s0=|immediate| s1=|consteval|} function {$arg0 :q} is not a constant expression</target>
        </segment>
      </unit>
      <unit id="4010" name="err_invalid_consteval_decl_kind">
        <segment>
          <source>%0 cannot be declared consteval</source>
          <target>{$arg0} cannot be declared consteval</target>
        </segment>
      </unit>
      <unit id="4011" name="err_invalid_consteval_take_address">
        <segment>
          <source>cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation</source>
          <target>cannot take address of {$arg2 :select s0=|immediate| s1=|consteval|} {$arg1 :select s0=|function| s1=|call operator of|} {$arg0} outside of an immediate invocation</target>
        </segment>
      </unit>
      <unit id="4012" name="err_invalid_constexpr">
        <segment>
          <source>%select{function parameter|typedef}0 cannot be %select{&lt;ERROR&gt;|constexpr|consteval|constinit}1</source>
          <target>{$arg0 :select s0=|function parameter| s1=|typedef|} cannot be {$arg1 :select s0=|&lt;ERROR&gt;| s1=|constexpr| s2=|consteval| s3=|constinit|}</target>
        </segment>
      </unit>
      <unit id="4013" name="err_invalid_constexpr_member">
        <segment>
          <source>non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1</source>
          <target>non-static data member cannot be constexpr%select{; did you intend to make it {$arg1 :select s0=|const| s1=|static}0?| s2=||}</target>
        </segment>
      </unit>
      <unit id="4014" name="err_invalid_constexpr_var_decl">
        <segment>
          <source>constexpr variable declaration must be a definition</source>
          <target>constexpr variable declaration must be a definition</target>
        </segment>
      </unit>
      <unit id="4015" name="err_invalid_conversion_between_ext_vectors">
        <segment>
          <source>invalid conversion between ext-vector type %0 and %1</source>
          <target>invalid conversion between ext-vector type {$arg0} and {$arg1}</target>
        </segment>
      </unit>
      <unit id="4016" name="err_invalid_conversion_between_matrix_and_type">
        <segment>
          <source>conversion between matrix type %0 and incompatible type %1 is not allowed</source>
          <target>conversion between matrix type {$arg0} and incompatible type {$arg1} is not allowed</target>
        </segment>
      </unit>
      <unit id="4017" name="err_invalid_conversion_between_matrixes">
        <segment>
          <source>conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed</source>
          <target>conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed</target>
        </segment>
      </unit>
      <unit id="4018" name="err_invalid_conversion_between_vector_and_integer">
        <segment>
          <source>invalid conversion between vector type %0 and integer type %1 of different size</source>
          <target>invalid conversion between vector type {$arg0} and integer type {$arg1} of different size</target>
        </segment>
      </unit>
      <unit id="4019" name="err_invalid_conversion_between_vector_and_scalar">
        <segment>
          <source>invalid conversion between vector type %0 and scalar type %1</source>
          <target>invalid conversion between vector type {$arg0} and scalar type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4020" name="err_invalid_conversion_between_vectors">
        <segment>
          <source>invalid conversion between vector type%diff{ $ and $|}0,1 of different size</source>
          <target>invalid conversion between vector type%diff{ $ and $|}0,1 of different size</target>
        </segment>
      </unit>
      <unit id="4021" name="err_invalid_cpu_is">
        <segment>
          <source>invalid cpu name for builtin</source>
          <target>invalid cpu name for builtin</target>
        </segment>
      </unit>
      <unit id="4022" name="err_invalid_cpu_specific_dispatch_value">
        <segment>
          <source>invalid option '%0' for %select{cpu_specific|cpu_dispatch}1</source>
          <target>invalid option '{$arg0}' for {$arg1 :select s0=|cpu_specific| s1=|cpu_dispatch|}</target>
        </segment>
      </unit>
      <unit id="4023" name="err_invalid_ctor_dtor_decl">
        <segment>
          <source>invalid %select{constructor|destructor}0 declaration</source>
          <target>invalid {$arg0 :select s0=|constructor| s1=|destructor|} declaration</target>
        </segment>
      </unit>
      <unit id="4024" name="err_invalid_custom_discrimination">
        <segment>
          <source>invalid custom discrimination</source>
          <target>invalid custom discrimination</target>
        </segment>
      </unit>
      <unit id="4025" name="err_invalid_decl_spec_combination">
        <segment>
          <source>cannot combine with previous '%0' declaration specifier</source>
          <target>cannot combine with previous '{$arg0}' declaration specifier</target>
        </segment>
      </unit>
      <unit id="4026" name="err_invalid_decl_specifier_in_nontype_parm">
        <segment>
          <source>invalid declaration specifier in template non-type parameter</source>
          <target>invalid declaration specifier in template non-type parameter</target>
        </segment>
      </unit>
      <unit id="4027" name="err_invalid_declarator_global_scope">
        <segment>
          <source>definition or redeclaration of %0 cannot name the global scope</source>
          <target>definition or redeclaration of {$arg0} cannot name the global scope</target>
        </segment>
      </unit>
      <unit id="4028" name="err_invalid_declarator_in_block">
        <segment>
          <source>definition or redeclaration of %0 not allowed inside a block</source>
          <target>definition or redeclaration of {$arg0} not allowed inside a block</target>
        </segment>
      </unit>
      <unit id="4029" name="err_invalid_declarator_in_function">
        <segment>
          <source>definition or redeclaration of %0 not allowed inside a function</source>
          <target>definition or redeclaration of {$arg0} not allowed inside a function</target>
        </segment>
      </unit>
      <unit id="4030" name="err_invalid_declarator_scope">
        <segment>
          <source>cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2</source>
          <target>cannot define or redeclare {$arg0} here because namespace {$arg1} does not enclose namespace {$arg2}</target>
        </segment>
      </unit>
      <unit id="4031" name="err_invalid_explicit_object_type_in_lambda">
        <segment>
          <source>invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda</source>
          <target>invalid explicit object parameter type {$arg0} in lambda with capture; the type must be the same as, or derived from, the lambda</target>
        </segment>
      </unit>
      <unit id="4032" name="err_invalid_extra_discrimination">
        <segment>
          <source>invalid extra discrimination selection %0</source>
          <target>invalid extra discrimination selection {$arg0}</target>
        </segment>
      </unit>
      <unit id="4033" name="err_invalid_form_pointer_member_function">
        <segment>
          <source>cannot create a non-constant pointer to member function</source>
          <target>cannot create a non-constant pointer to member function</target>
        </segment>
      </unit>
      <unit id="4034" name="err_invalid_hlsl_resource_type">
        <segment>
          <source>invalid __hlsl_resource_t type attributes</source>
          <target>invalid __hlsl_resource_t type attributes</target>
        </segment>
      </unit>
      <unit id="4035" name="err_invalid_incomplete_type_use">
        <segment>
          <source>invalid use of incomplete type %0</source>
          <target>invalid use of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4036" name="err_invalid_mask_type_size">
        <segment>
          <source>mask type size must be between 1-byte and 8-bytes</source>
          <target>mask type size must be between 1-byte and 8-bytes</target>
        </segment>
      </unit>
      <unit id="4037" name="err_invalid_member_use_in_method">
        <segment>
          <source>invalid use of member %0 in %select{static|explicit object}1 member function</source>
          <target>invalid use of member {$arg0} in {$arg1 :select s0=|static| s1=|explicit object|} member function</target>
        </segment>
      </unit>
      <unit id="4038" name="err_invalid_module_name">
        <segment>
          <source>%0 is an invalid name for a module</source>
          <target>{$arg0} is an invalid name for a module</target>
        </segment>
      </unit>
      <unit id="4039" name="err_invalid_neon_type_code">
        <segment>
          <source>incompatible constant for this __builtin_neon function</source>
          <target>incompatible constant for this __builtin_neon function</target>
        </segment>
      </unit>
      <unit id="4040" name="err_invalid_non_static_member_use">
        <segment>
          <source>invalid use of non-static data member %0</source>
          <target>invalid use of non-static data member {$arg0}</target>
        </segment>
      </unit>
      <unit id="4041" name="err_invalid_nsnumber_type">
        <segment>
          <source>%0 is not a valid literal type for NSNumber</source>
          <target>{$arg0} is not a valid literal type for NSNumber</target>
        </segment>
      </unit>
      <unit id="4042" name="err_invalid_pcs">
        <segment>
          <source>invalid PCS type</source>
          <target>invalid PCS type</target>
        </segment>
      </unit>
      <unit id="4043" name="err_invalid_pixel_decl_spec_combination">
        <segment>
          <source>'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here</source>
          <target>'__pixel' must be preceded by '__vector'.  '{$arg0}' declaration specifier not allowed here</target>
        </segment>
      </unit>
      <unit id="4044" name="err_invalid_property_name">
        <segment>
          <source>%0 is not a valid property name (accessing an object of type %1)</source>
          <target>{$arg0} is not a valid property name (accessing an object of type {$arg1})</target>
        </segment>
      </unit>
      <unit id="4045" name="err_invalid_protocol_qualifiers">
        <segment>
          <source>invalid protocol qualifiers on non-ObjC type</source>
          <target>invalid protocol qualifiers on non-ObjC type</target>
        </segment>
      </unit>
      <unit id="4046" name="err_invalid_qualified_constructor">
        <segment>
          <source>'%0' qualifier is not allowed on a constructor</source>
          <target>'{$arg0}' qualifier is not allowed on a constructor</target>
        </segment>
      </unit>
      <unit id="4047" name="err_invalid_qualified_destructor">
        <segment>
          <source>'%0' qualifier is not allowed on a destructor</source>
          <target>'{$arg0}' qualifier is not allowed on a destructor</target>
        </segment>
      </unit>
      <unit id="4048" name="err_invalid_qualified_function_type">
        <segment>
          <source>%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier</source>
          <target>{$arg0 :select s0=|non-member function| s1=|static member function| s2=|explicit object member function| s3=|deduction guide|} {$arg1 :select s0=|of type {$arg2} | s1=||}cannot have '{$arg3}' qualifier</target>
        </segment>
      </unit>
      <unit id="4049" name="err_invalid_receiver_class_message">
        <segment>
          <source>receiver type %0 is not an Objective-C class</source>
          <target>receiver type {$arg0} is not an Objective-C class</target>
        </segment>
      </unit>
      <unit id="4050" name="err_invalid_receiver_to_message_super">
        <segment>
          <source>'super' is only valid in a method body</source>
          <target>'super' is only valid in a method body</target>
        </segment>
      </unit>
      <unit id="4051" name="err_invalid_saturation_spec">
        <segment>
          <source>'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'</source>
          <target>'_Sat' specifier is only valid on '_Fract' or '_Accum', not '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4052" name="err_invalid_sign_spec">
        <segment>
          <source>'%0' cannot be signed or unsigned</source>
          <target>'{$arg0}' cannot be signed or unsigned</target>
        </segment>
      </unit>
      <unit id="4053" name="err_invalid_super_scope">
        <segment>
          <source>invalid use of '__super', this keyword can only be used inside class or member function scope</source>
          <target>invalid use of '__super', this keyword can only be used inside class or member function scope</target>
        </segment>
      </unit>
      <unit id="4054" name="err_invalid_this_use">
        <segment>
          <source>invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0</source>
          <target>invalid use of 'this' {$arg0 :select s0=|outside of a non-static member function| s1=|in a function with an explicit object parameter|}</target>
        </segment>
      </unit>
      <unit id="4055" name="err_invalid_thread">
        <segment>
          <source>'%0' is only allowed on variable declarations</source>
          <target>'{$arg0}' is only allowed on variable declarations</target>
        </segment>
      </unit>
      <unit id="4056" name="err_invalid_type_for_program_scope_var">
        <segment>
          <source>the %0 type cannot be used to declare a program scope variable</source>
          <target>the {$arg0} type cannot be used to declare a program scope variable</target>
        </segment>
      </unit>
      <unit id="4057" name="err_invalid_use_of_array_type">
        <segment>
          <source>an array type is not allowed here</source>
          <target>an array type is not allowed here</target>
        </segment>
      </unit>
      <unit id="4058" name="err_invalid_use_of_function_type">
        <segment>
          <source>a function type is not allowed here</source>
          <target>a function type is not allowed here</target>
        </segment>
      </unit>
      <unit id="4059" name="err_invalid_var_template_spec_type">
        <segment>
          <source>type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3</source>
          <target>type {$arg2} of {$arg0 :select s0=|explicit instantiation| s1=|explicit specialization| s2=|partial specialization| s3=|redeclaration|} of {$arg1} does not match expected type {$arg3}</target>
        </segment>
      </unit>
      <unit id="4060" name="err_invalid_vector_bool_decl_spec">
        <segment>
          <source>cannot use '%0' with '__vector bool'</source>
          <target>cannot use '{$arg0}' with '__vector bool'</target>
        </segment>
      </unit>
      <unit id="4061" name="err_invalid_vector_bool_int128_decl_spec">
        <segment>
          <source>use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)</source>
          <target>use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)</target>
        </segment>
      </unit>
      <unit id="4062" name="err_invalid_vector_complex_decl_spec">
        <segment>
          <source>cannot use '_Complex' with '__vector'</source>
          <target>cannot use '_Complex' with '__vector'</target>
        </segment>
      </unit>
      <unit id="4063" name="err_invalid_vector_decl_spec_combination">
        <segment>
          <source>cannot combine with previous '%0' declaration specifier. '__vector' must be first</source>
          <target>cannot combine with previous '{$arg0}' declaration specifier. '__vector' must be first</target>
        </segment>
      </unit>
      <unit id="4064" name="err_invalid_vector_double_decl_spec">
        <segment>
          <source>use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)</source>
          <target>use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)</target>
        </segment>
      </unit>
      <unit id="4065" name="err_invalid_vector_float_decl_spec">
        <segment>
          <source>cannot use 'float' with '__vector'</source>
          <target>cannot use 'float' with '__vector'</target>
        </segment>
      </unit>
      <unit id="4066" name="err_invalid_vector_int128_decl_spec">
        <segment>
          <source>use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)</source>
          <target>use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)</target>
        </segment>
      </unit>
      <unit id="4067" name="err_invalid_vector_long_decl_spec">
        <segment>
          <source>cannot use 'long' with '__vector'</source>
          <target>cannot use 'long' with '__vector'</target>
        </segment>
      </unit>
      <unit id="4068" name="err_invalid_vector_long_double_decl_spec">
        <segment>
          <source>cannot use 'long double' with '__vector'</source>
          <target>cannot use 'long double' with '__vector'</target>
        </segment>
      </unit>
      <unit id="4069" name="err_invalid_vector_long_long_decl_spec">
        <segment>
          <source>use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled</source>
          <target>use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled</target>
        </segment>
      </unit>
      <unit id="4070" name="err_invalid_width_spec">
        <segment>
          <source>'%select{|short|long|long long}0 %1' is invalid</source>
          <target>'{$arg0 :select s0=|| s1=|short| s2=|long| s3=|long long|} {$arg1}' is invalid</target>
        </segment>
      </unit>
      <unit id="4071" name="err_ivar_access_using_property_syntax_suggest">
        <segment>
          <source>property %0 not found on object of type %1; did you mean to access instance variable %2?</source>
          <target>property {$arg0} not found on object of type {$arg1}; did you mean to access instance variable {$arg2}?</target>
        </segment>
      </unit>
      <unit id="4072" name="err_ivar_in_superclass_use">
        <segment>
          <source>property %0 attempting to use instance variable %1 declared in super class %2</source>
          <target>property {$arg0} attempting to use instance variable {$arg1} declared in super class {$arg2}</target>
        </segment>
      </unit>
      <unit id="4073" name="err_ivar_reference_type">
        <segment>
          <source>instance variables cannot be of reference type</source>
          <target>instance variables cannot be of reference type</target>
        </segment>
      </unit>
      <unit id="4074" name="err_ivar_use_in_class_method">
        <segment>
          <source>instance variable %0 accessed in class method</source>
          <target>instance variable {$arg0} accessed in class method</target>
        </segment>
      </unit>
      <unit id="4075" name="err_kern_call_not_global_function">
        <segment>
          <source>kernel call to non-global function %0</source>
          <target>kernel call to non-global function {$arg0}</target>
        </segment>
      </unit>
      <unit id="4076" name="err_kern_is_nonstatic_method">
        <segment>
          <source>kernel function %0 must be a free function or static member function</source>
          <target>kernel function {$arg0} must be a free function or static member function</target>
        </segment>
      </unit>
      <unit id="4077" name="err_kern_type_not_void_return">
        <segment>
          <source>kernel function type %0 must have void return type</source>
          <target>kernel function type {$arg0} must have void return type</target>
        </segment>
      </unit>
      <unit id="4078" name="err_kernel_arg_address_space">
        <segment>
          <source>pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space</source>
          <target>pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space</target>
        </segment>
      </unit>
      <unit id="4079" name="err_lambda_capture_anonymous_var">
        <segment>
          <source>unnamed variable cannot be implicitly captured in a lambda expression</source>
          <target>unnamed variable cannot be implicitly captured in a lambda expression</target>
        </segment>
      </unit>
      <unit id="4080" name="err_lambda_capture_default_arg">
        <segment>
          <source>lambda expression in default argument cannot capture any entity</source>
          <target>lambda expression in default argument cannot capture any entity</target>
        </segment>
      </unit>
      <unit id="4081" name="err_lambda_capture_flexarray_type">
        <segment>
          <source>variable %0 with flexible array member cannot be captured in a lambda expression</source>
          <target>variable {$arg0} with flexible array member cannot be captured in a lambda expression</target>
        </segment>
      </unit>
      <unit id="4082" name="err_lambda_decl_ref_not_modifiable_lvalue">
        <segment>
          <source>cannot assign to a variable captured by copy in a non-mutable lambda</source>
          <target>cannot assign to a variable captured by copy in a non-mutable lambda</target>
        </segment>
      </unit>
      <unit id="4083" name="err_lambda_explicit_spec">
        <segment>
          <source>lambda call operator should not be explicitly specialized or instantiated</source>
          <target>lambda call operator should not be explicitly specialized or instantiated</target>
        </segment>
      </unit>
      <unit id="4084" name="err_lambda_impcap">
        <segment>
          <source>variable %0 cannot be implicitly captured in a lambda with no capture-default specified</source>
          <target>variable {$arg0} cannot be implicitly captured in a lambda with no capture-default specified</target>
        </segment>
      </unit>
      <unit id="4085" name="err_lambda_in_constant_expression">
        <segment>
          <source>a lambda expression may not appear inside of a constant expression</source>
          <target>a lambda expression may not appear inside of a constant expression</target>
        </segment>
      </unit>
      <unit id="4086" name="err_lambda_in_invalid_context">
        <segment>
          <source>a lambda expression cannot appear in this context</source>
          <target>a lambda expression cannot appear in this context</target>
        </segment>
      </unit>
      <unit id="4087" name="err_lambda_incomplete_result">
        <segment>
          <source>incomplete result type %0 in lambda expression</source>
          <target>incomplete result type {$arg0} in lambda expression</target>
        </segment>
      </unit>
      <unit id="4088" name="err_lambda_return_init_list">
        <segment>
          <source>cannot deduce lambda return type from initializer list</source>
          <target>cannot deduce lambda return type from initializer list</target>
        </segment>
      </unit>
      <unit id="4089" name="err_lambda_unevaluated_operand">
        <segment>
          <source>lambda expression in an unevaluated operand</source>
          <target>lambda expression in an unevaluated operand</target>
        </segment>
      </unit>
      <unit id="4090" name="err_language_linkage_spec_unknown">
        <segment>
          <source>unknown linkage language</source>
          <target>unknown linkage language</target>
        </segment>
      </unit>
      <unit id="4091" name="err_late_asm_label_name">
        <segment>
          <source>cannot apply asm label to %select{variable|function}0 after its first use</source>
          <target>cannot apply asm label to {$arg0 :select s0=|variable| s1=|function|} after its first use</target>
        </segment>
      </unit>
      <unit id="4092" name="err_lifetimebound_ctor_dtor">
        <segment>
          <source>'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0</source>
          <target>'lifetimebound' attribute cannot be applied to a {$arg0 :select s0=|constructor| s1=|destructor|}</target>
        </segment>
      </unit>
      <unit id="4093" name="err_lifetimebound_implicit_object_parameter_void_return_type">
        <segment>
          <source>'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'</source>
          <target>'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'</target>
        </segment>
      </unit>
      <unit id="4094" name="err_lifetimebound_no_object_param">
        <segment>
          <source state="initial">'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter</source>
          <target>'lifetimebound' attribute cannot be applied; {$arg0 :select s0=|non-| s1=|static | s2=|explicit object |}member function has no implicit object parameter</target>
        </segment>
      </unit>
      <unit id="4095" name="err_lifetimebound_parameter_void_return_type">
        <segment>
          <source>'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'</source>
          <target>'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'</target>
        </segment>
      </unit>
      <unit id="4096" name="err_list_init_in_parens">
        <segment>
          <source>cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list</source>
          <target>cannot initialize {$arg0 :select s0=|non-class| s1=|reference|} type {$arg1} with a parenthesized initializer list</target>
        </segment>
      </unit>
      <unit id="4097" name="err_literal_operator_bad_param_count">
        <segment>
          <source>non-template literal operator must have one or two parameters</source>
          <target>non-template literal operator must have one or two parameters</target>
        </segment>
      </unit>
      <unit id="4098" name="err_literal_operator_default_argument">
        <segment>
          <source>literal operator cannot have a default argument</source>
          <target>literal operator cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="4099" name="err_literal_operator_extern_c">
        <segment>
          <source>literal operator must have C++ linkage</source>
          <target>literal operator must have C++ linkage</target>
        </segment>
      </unit>
      <unit id="4100" name="err_literal_operator_id_outside_namespace">
        <segment>
          <source state="initial">non-namespace scope %0 cannot have a literal operator member</source>
          <target>non-namespace scope {$arg0} cannot have a literal operator member</target>
        </segment>
      </unit>
      <unit id="4101" name="err_literal_operator_invalid_param">
        <segment>
          <source>parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'</source>
          <target>parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'</target>
        </segment>
      </unit>
      <unit id="4102" name="err_literal_operator_outside_namespace">
        <segment>
          <source>literal operator %0 must be in a namespace or global scope</source>
          <target>literal operator {$arg0} must be in a namespace or global scope</target>
        </segment>
      </unit>
      <unit id="4103" name="err_literal_operator_param">
        <segment>
          <source>invalid literal operator parameter type %0, did you mean %1?</source>
          <target>invalid literal operator parameter type {$arg0}, did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="4104" name="err_literal_operator_template">
        <segment>
          <source>template parameter list for literal operator must be either 'char...' or 'typename T, T...'</source>
          <target>template parameter list for literal operator must be either 'char...' or 'typename T, T...'</target>
        </segment>
      </unit>
      <unit id="4105" name="err_literal_operator_template_with_params">
        <segment>
          <source>literal operator template cannot have any parameters</source>
          <target>literal operator template cannot have any parameters</target>
        </segment>
      </unit>
      <unit id="4106" name="err_loader_uninitialized_cant_init">
        <segment>
          <source>variable with 'loader_uninitialized' attribute cannot have an initializer</source>
          <target>variable with 'loader_uninitialized' attribute cannot have an initializer</target>
        </segment>
      </unit>
      <unit id="4107" name="err_loader_uninitialized_extern_decl">
        <segment>
          <source>variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute</source>
          <target>variable {$arg0} cannot be declared both 'extern' and with the 'loader_uninitialized' attribute</target>
        </segment>
      </unit>
      <unit id="4108" name="err_loader_uninitialized_redeclaration">
        <segment>
          <source>redeclaration cannot add 'loader_uninitialized' attribute</source>
          <target>redeclaration cannot add 'loader_uninitialized' attribute</target>
        </segment>
      </unit>
      <unit id="4109" name="err_loader_uninitialized_trivial_ctor">
        <segment>
          <source>variable with 'loader_uninitialized' attribute must have a trivial default constructor</source>
          <target>variable with 'loader_uninitialized' attribute must have a trivial default constructor</target>
        </segment>
      </unit>
      <unit id="4110" name="err_local_cant_init">
        <segment>
          <source>'__local' variable cannot have an initializer</source>
          <target>'__local' variable cannot have an initializer</target>
        </segment>
      </unit>
      <unit id="4111" name="err_loop_attr_conflict">
        <segment>
          <source>conflicting loop attribute %0</source>
          <target>conflicting loop attribute {$arg0}</target>
        </segment>
      </unit>
      <unit id="4112" name="err_lvalue_reference_bind_to_initlist">
        <segment>
          <source>%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} lvalue reference to type {$arg1} cannot bind to an initializer list temporary</target>
        </segment>
      </unit>
      <unit id="4113" name="err_lvalue_reference_bind_to_temporary">
        <segment>
          <source>%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2</target>
        </segment>
      </unit>
      <unit id="4114" name="err_lvalue_reference_bind_to_unrelated">
        <segment>
          <source>%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2</target>
        </segment>
      </unit>
      <unit id="4115" name="err_lvalue_to_rvalue_ref">
        <segment>
          <source>rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1</source>
          <target>rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1</target>
        </segment>
      </unit>
      <unit id="4116" name="err_machine_mode">
        <segment>
          <source>%select{unknown|unsupported}0 machine mode %1</source>
          <target>{$arg0 :select s0=|unknown| s1=|unsupported|} machine mode {$arg1}</target>
        </segment>
      </unit>
      <unit id="4117" name="err_main_arg_wrong">
        <segment>
          <source>%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1</source>
          <target>{$arg0 :select s0=|first| s1=|second| s2=|third| s3=|fourth|} parameter of 'main' ({$arg0 :select s0=|argument count| s1=|argument array| s2=|environment| s3=|platform-specific data|}) must be of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4118" name="err_main_global_variable">
        <segment>
          <source state="initial">main cannot be declared as a variable %select{in the global scope|with C language linkage}0</source>
          <target>main cannot be declared as a variable {$arg0 :select s0=|in the global scope| s1=|with C language linkage|}</target>
        </segment>
      </unit>
      <unit id="4119" name="err_main_returns_nonint">
        <segment>
          <source>'main' must return 'int'</source>
          <target>'main' must return 'int'</target>
        </segment>
      </unit>
      <unit id="4120" name="err_main_surplus_args">
        <segment>
          <source>too many parameters (%0) for 'main': must be 0, 2, or 3</source>
          <target>too many parameters ({$arg0}) for 'main': must be 0, 2, or 3</target>
        </segment>
      </unit>
      <unit id="4121" name="err_mainlike_template_decl">
        <segment>
          <source>%0 cannot be a template</source>
          <target>{$arg0} cannot be a template</target>
        </segment>
      </unit>
      <unit id="4122" name="err_make_signed_integral_only">
        <segment>
          <source>'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3</source>
          <target>'{$arg0 :select s0=|make_unsigned| s1=|make_signed|}' is only compatible with non-{$arg1 :select s0=|bool| s1=|_BitInt(1)|} integers and enum types, but was given {$arg2}{$arg3 :select s0=|| s1=| whose underlying type is {$arg4}|}</target>
        </segment>
      </unit>
      <unit id="4123" name="err_malformed_std_class_template">
        <segment>
          <source>std::%0 must be a class template with a single type parameter</source>
          <target>std::{$arg0} must be a class template with a single type parameter</target>
        </segment>
      </unit>
      <unit id="4124" name="err_malformed_std_coroutine_handle">
        <segment>
          <source>std::coroutine_handle isn't a class template</source>
          <target>std::coroutine_handle isn't a class template</target>
        </segment>
      </unit>
      <unit id="4125" name="err_malformed_std_coroutine_traits">
        <segment>
          <source>std::coroutine_traits isn't a class template</source>
          <target>std::coroutine_traits isn't a class template</target>
        </segment>
      </unit>
      <unit id="4126" name="err_malformed_std_nothrow">
        <segment>
          <source>std::nothrow must be a valid variable declaration</source>
          <target>std::nothrow must be a valid variable declaration</target>
        </segment>
      </unit>
      <unit id="4127" name="err_matrix_incomplete_index">
        <segment>
          <source>single subscript expressions are not allowed for matrix values</source>
          <target>single subscript expressions are not allowed for matrix values</target>
        </segment>
      </unit>
      <unit id="4128" name="err_matrix_index_not_integer">
        <segment>
          <source>matrix %select{row|column}0 index is not an integer</source>
          <target>matrix {$arg0 :select s0=|row| s1=|column|} index is not an integer</target>
        </segment>
      </unit>
      <unit id="4129" name="err_matrix_index_outside_range">
        <segment>
          <source>matrix %select{row|column}0 index is outside the allowed range [0, %1)</source>
          <target>matrix {$arg0 :select s0=|row| s1=|column|} index is outside the allowed range [0, {$arg1})</target>
        </segment>
      </unit>
      <unit id="4130" name="err_matrix_separate_incomplete_index">
        <segment>
          <source>matrix row and column subscripts cannot be separated by any expression</source>
          <target>matrix row and column subscripts cannot be separated by any expression</target>
        </segment>
      </unit>
      <unit id="4131" name="err_matrix_subscript_comma">
        <segment>
          <source>comma expressions are not allowed as indices in matrix subscript expressions</source>
          <target>comma expressions are not allowed as indices in matrix subscript expressions</target>
        </segment>
      </unit>
      <unit id="4132" name="err_mem_init_not_member_or_class">
        <segment>
          <source>member initializer %0 does not name a non-static data member or base class</source>
          <target>member initializer {$arg0} does not name a non-static data member or base class</target>
        </segment>
      </unit>
      <unit id="4133" name="err_mem_init_not_member_or_class_suggest">
        <segment>
          <source>initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?</source>
          <target>initializer {$arg0} does not name a non-static data member or base class; did you mean the {$arg1 :select s0=|base class| s1=|member|} {$arg2}?</target>
        </segment>
      </unit>
      <unit id="4134" name="err_member_call_without_object">
        <segment>
          <source>call to %select{non-static|explicit}0 member function without an object argument</source>
          <target>call to {$arg0 :select s0=|non-static| s1=|explicit|} member function without an object argument</target>
        </segment>
      </unit>
      <unit id="4135" name="err_member_decl_does_not_match">
        <segment>
          <source>out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1</source>
          <target>out-of-line {$arg2 :select s0=|declaration| s1=|definition|} of {$arg0} does not match any declaration in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4136" name="err_member_decl_does_not_match_suggest">
        <segment>
          <source>out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?</source>
          <target>out-of-line {$arg2 :select s0=|declaration| s1=|definition|} of {$arg0} does not match any declaration in {$arg1}; did you mean {$arg3}?</target>
        </segment>
      </unit>
      <unit id="4137" name="err_member_def_does_not_match_ret_type">
        <segment>
          <source>return type of out-of-line definition of %q0 differs from that in the declaration</source>
          <target>return type of out-of-line definition of {$arg0 :q} differs from that in the declaration</target>
        </segment>
      </unit>
      <unit id="4138" name="err_member_def_undefined_record">
        <segment>
          <source>out-of-line definition of %0 from class %1 without definition</source>
          <target>out-of-line definition of {$arg0} from class {$arg1} without definition</target>
        </segment>
      </unit>
      <unit id="4139" name="err_member_extra_qualification">
        <segment>
          <source>extra qualification on member %0</source>
          <target>extra qualification on member {$arg0}</target>
        </segment>
      </unit>
      <unit id="4140" name="err_member_function_call_bad_cvr">
        <segment>
          <source>'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2</source>
          <target>'this' argument to member function {$arg0} has type {$arg1}, but function is not marked {$arg2 :select s0=|const| s1=|restrict| s2=|const or restrict| s3=|volatile| s4=|const or volatile| s5=|volatile or restrict| s6=|const, volatile, or restrict|}</target>
        </segment>
      </unit>
      <unit id="4141" name="err_member_function_call_bad_ref">
        <segment>
          <source>'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier</source>
          <target>'this' argument to member function {$arg0} is an {$arg1 :select s0=|lvalue| s1=|rvalue|}, but function has {$arg2 :select s0=|non-const lvalue| s1=|rvalue|} ref-qualifier</target>
        </segment>
      </unit>
      <unit id="4142" name="err_member_function_call_bad_type">
        <segment>
          <source>cannot initialize object parameter of type %0 with an expression of type %1</source>
          <target>cannot initialize object parameter of type {$arg0} with an expression of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4143" name="err_member_function_initialization">
        <segment>
          <source>initializer on function does not look like a pure-specifier</source>
          <target>initializer on function does not look like a pure-specifier</target>
        </segment>
      </unit>
      <unit id="4144" name="err_member_name_of_class">
        <segment>
          <source>member %0 has the same name as its class</source>
          <target>member {$arg0} has the same name as its class</target>
        </segment>
      </unit>
      <unit id="4145" name="err_member_not_yet_instantiated">
        <segment>
          <source>no member %0 in %1; it has not yet been instantiated</source>
          <target>no member {$arg0} in {$arg1}; it has not yet been instantiated</target>
        </segment>
      </unit>
      <unit id="4146" name="err_member_qualification">
        <segment>
          <source>non-friend class member %0 cannot have a qualified name</source>
          <target>non-friend class member {$arg0} cannot have a qualified name</target>
        </segment>
      </unit>
      <unit id="4147" name="err_member_redeclared">
        <segment>
          <source>class member cannot be redeclared</source>
          <target>class member cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="4148" name="err_member_redeclared_in_instantiation">
        <segment>
          <source>multiple overloads of %0 instantiate to the same signature %1</source>
          <target>multiple overloads of {$arg0} instantiate to the same signature {$arg1}</target>
        </segment>
      </unit>
      <unit id="4149" name="err_member_reference_needs_call">
        <segment>
          <source>base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?</source>
          <target>base of member reference is a function; perhaps you meant to call it{$arg0 :select s0=|| s1=| with no arguments|}?</target>
        </segment>
      </unit>
      <unit id="4150" name="err_member_with_template_arguments">
        <segment>
          <source>member %0 cannot have template arguments</source>
          <target>member {$arg0} cannot have template arguments</target>
        </segment>
      </unit>
      <unit id="4151" name="err_memptr_conv_via_virtual">
        <segment>
          <source>conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed</source>
          <target>conversion from pointer to member of class {$arg0} to pointer to member of class {$arg1} via virtual base {$arg2} is not allowed</target>
        </segment>
      </unit>
      <unit id="4152" name="err_memptr_incomplete">
        <segment>
          <source>member pointer has incomplete base type %0</source>
          <target>member pointer has incomplete base type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4153" name="err_memtag_any2arg_pointer">
        <segment>
          <source>at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)</source>
          <target>at least one argument of MTE builtin function must be a pointer ({$arg0}, {$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4154" name="err_memtag_arg_must_be_integer">
        <segment>
          <source>%0 argument of MTE builtin function must be an integer type (%1 invalid)</source>
          <target>{$arg0} argument of MTE builtin function must be an integer type ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4155" name="err_memtag_arg_must_be_pointer">
        <segment>
          <source>%0 argument of MTE builtin function must be a pointer (%1 invalid)</source>
          <target>{$arg0} argument of MTE builtin function must be a pointer ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4156" name="err_memtag_arg_null_or_pointer">
        <segment>
          <source>%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)</source>
          <target>{$arg0} argument of MTE builtin function must be a null or a pointer ({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4157" name="err_messaging_class_with_direct_method">
        <segment>
          <source>messaging a Class with a method that is possibly direct</source>
          <target>messaging a Class with a method that is possibly direct</target>
        </segment>
      </unit>
      <unit id="4158" name="err_messaging_super_with_direct_method">
        <segment>
          <source>messaging super with a direct method</source>
          <target>messaging super with a direct method</target>
        </segment>
      </unit>
      <unit id="4159" name="err_messaging_unqualified_id_with_direct_method">
        <segment>
          <source>messaging unqualified id with a method that is possibly direct</source>
          <target>messaging unqualified id with a method that is possibly direct</target>
        </segment>
      </unit>
      <unit id="4160" name="err_method_kernel">
        <segment>
          <source>kernel functions cannot be class members</source>
          <target>kernel functions cannot be class members</target>
        </segment>
      </unit>
      <unit id="4161" name="err_method_not_found_with_typo">
        <segment>
          <source>%select{instance|class}1 method %0 not found ; did you mean %2?</source>
          <target>{$arg1 :select s0=|instance| s1=|class|} method {$arg0} not found ; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="4162" name="err_mips_builtin_requires_dsp">
        <segment>
          <source>this builtin requires 'dsp' ASE, please use -mdsp</source>
          <target>this builtin requires 'dsp' ASE, please use -mdsp</target>
        </segment>
      </unit>
      <unit id="4163" name="err_mips_builtin_requires_dspr2">
        <segment>
          <source>this builtin requires 'dsp r2' ASE, please use -mdspr2</source>
          <target>this builtin requires 'dsp r2' ASE, please use -mdspr2</target>
        </segment>
      </unit>
      <unit id="4164" name="err_mips_builtin_requires_msa">
        <segment>
          <source>this builtin requires 'msa' ASE, please use -mmsa</source>
          <target>this builtin requires 'msa' ASE, please use -mmsa</target>
        </segment>
      </unit>
      <unit id="4165" name="err_mismatched_code_seg_base">
        <segment>
          <source>derived class must specify the same code segment as its base classes</source>
          <target>derived class must specify the same code segment as its base classes</target>
        </segment>
      </unit>
      <unit id="4166" name="err_mismatched_code_seg_override">
        <segment>
          <source>overriding virtual function must specify the same code segment as its overridden function</source>
          <target>overriding virtual function must specify the same code segment as its overridden function</target>
        </segment>
      </unit>
      <unit id="4167" name="err_mismatched_exception_spec">
        <segment>
          <source>exception specification in declaration does not match previous declaration</source>
          <target>exception specification in declaration does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="4168" name="err_mismatched_exception_spec_explicit_instantiation">
        <segment>
          <source>exception specification in explicit instantiation does not match instantiated one</source>
          <target>exception specification in explicit instantiation does not match instantiated one</target>
        </segment>
      </unit>
      <unit id="4169" name="err_mismatched_ms_inheritance">
        <segment>
          <source>inheritance model does not match %select{definition|previous declaration}0</source>
          <target>inheritance model does not match {$arg0 :select s0=|definition| s1=|previous declaration|}</target>
        </segment>
      </unit>
      <unit id="4170" name="err_mismatched_owning_module">
        <segment>
          <source>declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3</source>
          <target>declaration of {$arg0} in {$arg1 :select s0=|the global module| s1=|module {$arg2}|} follows declaration in {$arg3 :select s0=|the global module| s1=|module {$arg4}|}</target>
        </segment>
      </unit>
      <unit id="4171" name="err_mismatched_uuid">
        <segment>
          <source>uuid does not match previous declaration</source>
          <target>uuid does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="4172" name="err_mismatched_visibility">
        <segment>
          <source>visibility does not match previous declaration</source>
          <target>visibility does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="4173" name="err_mismatching_type_aware_cleanup_deallocator">
        <segment>
          <source>type aware %0 requires a matching type aware %select{|placement }1%2 to be declared in the same scope</source>
          <target>type aware {$arg0} requires a matching type aware {$arg1 :select s0=|| s1=|placement |}{$arg2} to be declared in the same scope</target>
        </segment>
      </unit>
      <unit id="4174" name="err_misplaced_ivar">
        <segment>
          <source>instance variables may not be placed in %select{categories|class extension}0</source>
          <target>instance variables may not be placed in {$arg0 :select s0=|categories| s1=|class extension|}</target>
        </segment>
      </unit>
      <unit id="4175" name="err_missing_actual_pipe_type">
        <segment>
          <source>missing actual type specifier for pipe</source>
          <target>missing actual type specifier for pipe</target>
        </segment>
      </unit>
      <unit id="4176" name="err_missing_arm_state">
        <segment>
          <source>missing state for %0</source>
          <target>missing state for {$arg0}</target>
        </segment>
      </unit>
      <unit id="4177" name="err_missing_atsign_prefix">
        <segment>
          <source>%select{string|numeric}0 literal must be prefixed by '@'</source>
          <target>{$arg0 :select s0=|string| s1=|numeric|} literal must be prefixed by '@'</target>
        </segment>
      </unit>
      <unit id="4178" name="err_missing_custom_discrimination">
        <segment>
          <source>missing custom discrimination</source>
          <target>missing custom discrimination</target>
        </segment>
      </unit>
      <unit id="4179" name="err_missing_default_ctor">
        <segment>
          <source>%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor</source>
          <target>{$arg0 :select s0=|constructor for {$arg1} must explicitly initialize the| s1=|implicit default constructor for {$arg1} must explicitly initialize the| s2=|cannot use constructor inherited from base class {$arg4};|} {$arg2 :select s0=|base class| s1=|member|} {$arg3} {$arg0 :select s0=|which| s1=|which| s2=|of {$arg1}|} does not have a default constructor</target>
        </segment>
      </unit>
      <unit id="4180" name="err_missing_exception_specification">
        <segment>
          <source>%0 is missing exception specification '%1'</source>
          <target>{$arg0} is missing exception specification '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4181" name="err_missing_method_context">
        <segment>
          <source>missing context for method declaration</source>
          <target>missing context for method declaration</target>
        </segment>
      </unit>
      <unit id="4182" name="err_missing_open_square_message_send">
        <segment>
          <source>missing '[' at start of message send expression</source>
          <target>missing '[' at start of message send expression</target>
        </segment>
      </unit>
      <unit id="4183" name="err_missing_property_context">
        <segment>
          <source>missing context for property implementation declaration</source>
          <target>missing context for property implementation declaration</target>
        </segment>
      </unit>
      <unit id="4184" name="err_missing_property_interface">
        <segment>
          <source>property implementation in a category with no category declaration</source>
          <target>property implementation in a category with no category declaration</target>
        </segment>
      </unit>
      <unit id="4185" name="err_missing_property_ivar_decl">
        <segment>
          <source>synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable</source>
          <target>synthesized property {$arg0} must either be named the same as a compatible instance variable or must explicitly name an instance variable</target>
        </segment>
      </unit>
      <unit id="4186" name="err_missing_type_specifier">
        <segment>
          <source>a type specifier is required for all declarations</source>
          <target>a type specifier is required for all declarations</target>
        </segment>
      </unit>
      <unit id="4187" name="err_mixing_cxx_try_seh_try">
        <segment>
          <source>cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'</source>
          <target>cannot use {$arg0 :select s0=|C++ 'try'| s1=|Objective-C '@try'|} in the same function as SEH '__try'</target>
        </segment>
      </unit>
      <unit id="4188" name="err_mode_not_primitive">
        <segment>
          <source>mode attribute only supported for integer and floating-point types</source>
          <target>mode attribute only supported for integer and floating-point types</target>
        </segment>
      </unit>
      <unit id="4189" name="err_mode_wrong_type">
        <segment>
          <source>type of machine mode does not match type of base type</source>
          <target>type of machine mode does not match type of base type</target>
        </segment>
      </unit>
      <unit id="4190" name="err_module_decl_in_header_unit">
        <segment>
          <source>'module' declaration found while building header unit</source>
          <target>'module' declaration found while building header unit</target>
        </segment>
      </unit>
      <unit id="4191" name="err_module_decl_in_module_map_module">
        <segment>
          <source>'module' declaration found while building module from module map</source>
          <target>'module' declaration found while building module from module map</target>
        </segment>
      </unit>
      <unit id="4192" name="err_module_decl_not_at_start">
        <segment>
          <source>module declaration must occur at the start of the translation unit</source>
          <target>module declaration must occur at the start of the translation unit</target>
        </segment>
      </unit>
      <unit id="4193" name="err_module_declaration_missing">
        <segment>
          <source>missing 'export module' declaration in module interface unit</source>
          <target>missing 'export module' declaration in module interface unit</target>
        </segment>
      </unit>
      <unit id="4194" name="err_module_declaration_missing_after_global_module_introducer">
        <segment>
          <source>missing 'module' declaration at end of global module fragment introduced here</source>
          <target>missing 'module' declaration at end of global module fragment introduced here</target>
        </segment>
      </unit>
      <unit id="4195" name="err_module_import_in_implementation">
        <segment>
          <source>@import of module '%0' in implementation of '%1'; use #import</source>
          <target>@import of module '{$arg0}' in implementation of '{$arg1}'; use #import</target>
        </segment>
      </unit>
      <unit id="4196" name="err_module_import_non_interface_nor_parition">
        <segment>
          <source>import of module '%0' imported non C++20 importable modules</source>
          <target>import of module '{$arg0}' imported non C++20 importable modules</target>
        </segment>
      </unit>
      <unit id="4197" name="err_module_import_not_at_top_level_fatal">
        <segment>
          <source>import of module '%0' appears within %1</source>
          <target>import of module '{$arg0}' appears within {$arg1}</target>
        </segment>
      </unit>
      <unit id="4198" name="err_module_interface_implementation_mismatch">
        <segment>
          <source>missing 'export' specifier in module declaration while building module interface</source>
          <target>missing 'export' specifier in module declaration while building module interface</target>
        </segment>
      </unit>
      <unit id="4199" name="err_module_not_defined">
        <segment>
          <source>definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface</source>
          <target>definition of module '{$arg0}' is not available; use -fmodule-file= to specify path to precompiled module interface</target>
        </segment>
      </unit>
      <unit id="4200" name="err_module_private_local">
        <segment>
          <source>%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__</source>
          <target>{$arg0 :select s0=|local variable| s1=|parameter| s2=|typedef|} {$arg1} cannot be declared __module_private__</target>
        </segment>
      </unit>
      <unit id="4201" name="err_module_private_local_class">
        <segment>
          <source>local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__</source>
          <target>local {$arg0 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} cannot be declared __module_private__</target>
        </segment>
      </unit>
      <unit id="4202" name="err_module_private_specialization">
        <segment>
          <source>%select{template|partial|member}0 specialization cannot be declared __module_private__</source>
          <target>{$arg0 :select s0=|template| s1=|partial| s2=|member|} specialization cannot be declared __module_private__</target>
        </segment>
      </unit>
      <unit id="4203" name="err_module_redeclaration">
        <segment>
          <source>translation unit contains multiple module declarations</source>
          <target>translation unit contains multiple module declarations</target>
        </segment>
      </unit>
      <unit id="4204" name="err_module_redefinition">
        <segment>
          <source>redefinition of module '%0'</source>
          <target>redefinition of module '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4205" name="err_module_self_import">
        <segment>
          <source>import of module '%0' appears within same top-level module '%1'</source>
          <target>import of module '{$arg0}' appears within same top-level module '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4206" name="err_module_self_import_cxx20">
        <segment>
          <source>import of module '%0' appears within its own %select{interface|implementation}1</source>
          <target>import of module '{$arg0}' appears within its own {$arg1 :select s0=|interface| s1=|implementation|}</target>
        </segment>
      </unit>
      <unit id="4207" name="err_module_unimported_use">
        <segment>
          <source>%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required</source>
          <target>{$arg0 :select s0=|declaration| s1=|definition| s2=|default argument| s3=|explicit specialization| s4=|partial specialization|} of {$arg1} must be imported from module '{$arg2}' before it is required</target>
        </segment>
      </unit>
      <unit id="4208" name="err_module_unimported_use_header">
        <segment>
          <source>%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used</source>
          <target>{$arg2 :select s0=|missing '#include'| s1=|missing '#include {$arg3}'|}; {$arg0 :select s0=|| s1=|| s2=|default argument of | s3=|explicit specialization of | s4=|partial specialization of |}{$arg1} must be {$arg0 :select s0=|declared| s1=|defined| s2=|defined| s3=|declared| s4=|declared|} before it is used</target>
        </segment>
      </unit>
      <unit id="4209" name="err_module_unimported_use_multiple">
        <segment>
          <source>%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2</source>
          <target>{$arg0 :select s0=|declaration| s1=|definition| s2=|default argument| s3=|explicit specialization| s4=|partial specialization|} of {$arg1} must be imported from one of the following modules before it is required:{$arg2}</target>
        </segment>
      </unit>
      <unit id="4210" name="err_ms___leave_not_in___try">
        <segment>
          <source>'__leave' statement not in __try block</source>
          <target>'__leave' statement not in __try block</target>
        </segment>
      </unit>
      <unit id="4211" name="err_ms_constexpr_cannot_be_applied">
        <segment>
          <source>attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1</source>
          <target>attribute 'msvc::constexpr' cannot be applied to the {$arg0 :select s0=|constexpr| s1=|consteval| s2=|virtual|} function {$arg1}</target>
        </segment>
      </unit>
      <unit id="4212" name="err_ms_va_start_used_in_sysv_function">
        <segment>
          <source>'__builtin_ms_va_start' used in System V ABI function</source>
          <target>'__builtin_ms_va_start' used in System V ABI function</target>
        </segment>
      </unit>
      <unit id="4213" name="err_msvc_annotation_wide_str">
        <segment>
          <source>arguments to __annotation must be wide string constants</source>
          <target>arguments to __annotation must be wide string constants</target>
        </segment>
      </unit>
      <unit id="4214" name="err_multiple_base_initialization">
        <segment>
          <source>multiple initializations given for base %0</source>
          <target>multiple initializations given for base {$arg0}</target>
        </segment>
      </unit>
      <unit id="4215" name="err_multiple_decl_in_different_modules">
        <segment>
          <source state="initial">declaration %0 attached to named module '%1' cannot be attached to other modules</source>
          <target>declaration {$arg0} attached to named module '{$arg1}' cannot be attached to other modules</target>
        </segment>
      </unit>
      <unit id="4216" name="err_multiple_default_labels_defined">
        <segment>
          <source>multiple default labels in one switch</source>
          <target>multiple default labels in one switch</target>
        </segment>
      </unit>
      <unit id="4217" name="err_multiple_final_overriders">
        <segment>
          <source>virtual function %q0 has more than one final overrider in %1</source>
          <target>virtual function {$arg0 :q} has more than one final overrider in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4218" name="err_multiple_mem_initialization">
        <segment>
          <source>multiple initializations given for non-static member %0</source>
          <target>multiple initializations given for non-static member {$arg0}</target>
        </segment>
      </unit>
      <unit id="4219" name="err_multiple_mem_union_initialization">
        <segment>
          <source>initializing multiple members of union</source>
          <target>initializing multiple members of union</target>
        </segment>
      </unit>
      <unit id="4220" name="err_multiversion_after_used">
        <segment>
          <source>function declaration cannot become a multiversioned function after first usage</source>
          <target>function declaration cannot become a multiversioned function after first usage</target>
        </segment>
      </unit>
      <unit id="4221" name="err_multiversion_diff">
        <segment>
          <source>multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0</source>
          <target>multiversioned function declaration has a different {$arg0 :select s0=|calling convention| s1=|return type| s2=|constexpr specification| s3=|inline specification| s4=|linkage| s5=|language linkage|}</target>
        </segment>
      </unit>
      <unit id="4222" name="err_multiversion_disallowed_other_attr">
        <segment>
          <source>attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1</source>
          <target>attribute '{$arg0 :select s0=|| s1=|target| s2=|cpu_specific| s3=|cpu_dispatch| s4=|target_clones| s5=|target_version|}' multiversioning cannot be combined with attribute {$arg1}</target>
        </segment>
      </unit>
      <unit id="4223" name="err_multiversion_doesnt_support">
        <segment>
          <source>attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1</source>
          <target>attribute '{$arg0 :select s0=|| s1=|target| s2=|cpu_specific| s3=|cpu_dispatch| s4=|target_clones| s5=|target_version|}' multiversioned functions do not yet support {$arg1 :select s0=|function templates| s1=|virtual functions| s2=|deduced return types| s3=|constructors| s4=|destructors| s5=|deleted functions| s6=|defaulted functions| s7=|constexpr functions| s8=|consteval function| s9=|lambdas|}</target>
        </segment>
      </unit>
      <unit id="4224" name="err_multiversion_duplicate">
        <segment>
          <source>multiversioned function redeclarations require identical target attributes</source>
          <target>multiversioned function redeclarations require identical target attributes</target>
        </segment>
      </unit>
      <unit id="4225" name="err_multiversion_noproto">
        <segment>
          <source>multiversioned function must have a prototype</source>
          <target>multiversioned function must have a prototype</target>
        </segment>
      </unit>
      <unit id="4226" name="err_multiversion_not_allowed_on_main">
        <segment>
          <source>'main' cannot be a multiversioned function</source>
          <target>'main' cannot be a multiversioned function</target>
        </segment>
      </unit>
      <unit id="4227" name="err_multiversion_not_supported">
        <segment>
          <source>function multiversioning is not supported on the current target</source>
          <target>function multiversioning is not supported on the current target</target>
        </segment>
      </unit>
      <unit id="4228" name="err_multiversion_required_in_redecl">
        <segment>
          <source>function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function</source>
          <target>function declaration is missing {$arg0 :select s0=|'target'| s1=|'cpu_specific' or 'cpu_dispatch'| s2=|'target_version'|} attribute in a multiversioned function</target>
        </segment>
      </unit>
      <unit id="4229" name="err_multiversion_types_mixed">
        <segment>
          <source>multiversioning attributes cannot be combined</source>
          <target>multiversioning attributes cannot be combined</target>
        </segment>
      </unit>
      <unit id="4230" name="err_musttail_callconv_mismatch">
        <segment>
          <source>cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention</source>
          <target>cannot perform a tail call to function{$arg0 :select s0=|| s1=| {$arg1}|} because it uses an incompatible calling convention</target>
        </segment>
      </unit>
      <unit id="4231" name="err_musttail_forbidden_from_this_context">
        <segment>
          <source>%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1</source>
          <target>{$arg0} attribute cannot be used from {$arg1 :select s0=|a block| s1=|an Objective-C function| s2=|this context|}</target>
        </segment>
      </unit>
      <unit id="4232" name="err_musttail_member_mismatch">
        <segment>
          <source>%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2</source>
          <target>{$arg0 :select s0=|non-member| s1=|static member| s2=|non-static member|} function cannot perform a tail call to {$arg1 :select s0=|non-member| s1=|static member| s2=|non-static member| s3=|pointer-to-member|} function{$arg2 :select s0=|| s1=| {$arg3}|}</target>
        </segment>
      </unit>
      <unit id="4233" name="err_musttail_mismatch">
        <segment>
          <source>cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function</source>
          <target>cannot perform a tail call to function{$arg0 :select s0=|| s1=| {$arg1}|} because its signature is incompatible with the calling function</target>
        </segment>
      </unit>
      <unit id="4234" name="err_musttail_needs_call">
        <segment>
          <source>%0 attribute requires that the return value is the result of a function call</source>
          <target>{$arg0} attribute requires that the return value is the result of a function call</target>
        </segment>
      </unit>
      <unit id="4235" name="err_musttail_needs_prototype">
        <segment>
          <source>%0 attribute requires that both caller and callee functions have a prototype</source>
          <target>{$arg0} attribute requires that both caller and callee functions have a prototype</target>
        </segment>
      </unit>
      <unit id="4236" name="err_musttail_needs_trivial_args">
        <segment>
          <source>tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible</source>
          <target>tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible</target>
        </segment>
      </unit>
      <unit id="4237" name="err_musttail_no_return">
        <segment>
          <source>%0 attribute may not be used with no-return-attribute functions</source>
          <target>{$arg0} attribute may not be used with no-return-attribute functions</target>
        </segment>
      </unit>
      <unit id="4238" name="err_musttail_no_variadic">
        <segment>
          <source>%0 attribute may not be used with variadic functions</source>
          <target>{$arg0} attribute may not be used with variadic functions</target>
        </segment>
      </unit>
      <unit id="4239" name="err_musttail_scope">
        <segment>
          <source>cannot perform a tail call from this return statement</source>
          <target>cannot perform a tail call from this return statement</target>
        </segment>
      </unit>
      <unit id="4240" name="err_musttail_structors_forbidden">
        <segment>
          <source>cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1</source>
          <target>cannot perform a tail call {$arg0 :select s0=|from| s1=|to|} a {$arg1 :select s0=|constructor| s1=|destructor|}</target>
        </segment>
      </unit>
      <unit id="4241" name="err_mutable_const">
        <segment>
          <source>'mutable' and 'const' cannot be mixed</source>
          <target>'mutable' and 'const' cannot be mixed</target>
        </segment>
      </unit>
      <unit id="4242" name="err_mutable_function">
        <segment>
          <source>'mutable' cannot be applied to functions</source>
          <target>'mutable' cannot be applied to functions</target>
        </segment>
      </unit>
      <unit id="4243" name="err_mutable_nonmember">
        <segment>
          <source>'mutable' can only be applied to member variables</source>
          <target>'mutable' can only be applied to member variables</target>
        </segment>
      </unit>
      <unit id="4244" name="err_mutable_reference">
        <segment>
          <source>'mutable' cannot be applied to references</source>
          <target>'mutable' cannot be applied to references</target>
        </segment>
      </unit>
      <unit id="4245" name="err_need_header_before_placement_new">
        <segment>
          <source>no matching %0 function for non-allocating placement new expression; include &lt;new&gt;</source>
          <target>no matching {$arg0} function for non-allocating placement new expression; include &lt;new&gt;</target>
        </segment>
      </unit>
      <unit id="4246" name="err_need_header_before_typeid">
        <segment>
          <source>you need to include &lt;typeinfo&gt; before using the 'typeid' operator</source>
          <target>you need to include &lt;typeinfo&gt; before using the 'typeid' operator</target>
        </segment>
      </unit>
      <unit id="4247" name="err_nested_name_member_ref_lookup_ambiguous">
        <segment>
          <source>lookup of %0 in member access expression is ambiguous</source>
          <target>lookup of {$arg0} in member access expression is ambiguous</target>
        </segment>
      </unit>
      <unit id="4248" name="err_nested_name_spec_is_not_class">
        <segment>
          <source>%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?</source>
          <target>{$arg0} cannot appear before '::' because it is not a class{$arg1 :select s0=| or namespace| s1=|, namespace, or enumeration|}; did you mean ':'?</target>
        </segment>
      </unit>
      <unit id="4249" name="err_nested_name_spec_non_tag">
        <segment>
          <source>type %0 cannot be used prior to '::' because it has no members</source>
          <target>type {$arg0} cannot be used prior to '::' because it has no members</target>
        </segment>
      </unit>
      <unit id="4250" name="err_nested_non_static_member_use">
        <segment>
          <source>%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3</source>
          <target>{$arg0 :select s0=|call to non-static member function| s1=|use of non-static data member|} {$arg2} of {$arg1} from nested type {$arg3}</target>
        </segment>
      </unit>
      <unit id="4251" name="err_nested_pointer_qualifier_mismatch">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types</target>
        </segment>
      </unit>
      <unit id="4252" name="err_nested_redefinition">
        <segment>
          <source>nested redefinition of %0</source>
          <target>nested redefinition of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4253" name="err_new_abi_tag_on_redeclaration">
        <segment>
          <source>'abi_tag' %0 missing in original declaration</source>
          <target>'abi_tag' {$arg0} missing in original declaration</target>
        </segment>
      </unit>
      <unit id="4254" name="err_new_array_init_args">
        <segment>
          <source>array 'new' cannot have initialization arguments</source>
          <target>array 'new' cannot have initialization arguments</target>
        </segment>
      </unit>
      <unit id="4255" name="err_new_array_nonconst">
        <segment>
          <source>only the first dimension of an allocated array may have dynamic size</source>
          <target>only the first dimension of an allocated array may have dynamic size</target>
        </segment>
      </unit>
      <unit id="4256" name="err_new_array_of_auto">
        <segment>
          <source>cannot allocate array of 'auto'</source>
          <target>cannot allocate array of 'auto'</target>
        </segment>
      </unit>
      <unit id="4257" name="err_new_array_size_unknown_from_init">
        <segment>
          <source>cannot determine allocated array size from initializer</source>
          <target>cannot determine allocated array size from initializer</target>
        </segment>
      </unit>
      <unit id="4258" name="err_new_incomplete_or_sizeless_type">
        <segment>
          <source>allocation of %select{incomplete|sizeless}0 type %1</source>
          <target>allocation of {$arg0 :select s0=|incomplete| s1=|sizeless|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4259" name="err_no_accessor_for_property">
        <segment>
          <source>no %select{getter|setter}0 defined for property %1</source>
          <target>no {$arg0 :select s0=|getter| s1=|setter|} defined for property {$arg1}</target>
        </segment>
      </unit>
      <unit id="4260" name="err_no_base_classes">
        <segment>
          <source>invalid use of '__super', %0 has no base classes</source>
          <target>invalid use of '__super', {$arg0} has no base classes</target>
        </segment>
      </unit>
      <unit id="4261" name="err_no_declarators">
        <segment>
          <source>declaration does not declare anything</source>
          <target>declaration does not declare anything</target>
        </segment>
      </unit>
      <unit id="4262" name="err_no_default_vtable_pointer_auth">
        <segment>
          <source>cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set</source>
          <target>cannot specify a default vtable pointer authentication {$arg0 :select s0=|key| s1=|address discrimination mode| s2=|discriminator|} with no default set</target>
        </segment>
      </unit>
      <unit id="4263" name="err_no_dynamic_cast_with_fno_rtti">
        <segment>
          <source>use of dynamic_cast requires -frtti</source>
          <target>use of dynamic_cast requires -frtti</target>
        </segment>
      </unit>
      <unit id="4264" name="err_no_matching_local_friend">
        <segment>
          <source state="initial">cannot define friend function in a local class definition</source>
          <target>cannot define friend function in a local class definition</target>
        </segment>
      </unit>
      <unit id="4265" name="err_no_matching_local_friend_suggest">
        <segment>
          <source state="initial">cannot define friend function %0 in a local class definition; did you mean %3?</source>
          <target>cannot define friend function {$arg0} in a local class definition; did you mean {$arg3}?</target>
        </segment>
      </unit>
      <unit id="4266" name="err_no_member">
        <segment>
          <source>no member named %0 in %1</source>
          <target>no member named {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4267" name="err_no_member_overloaded_arrow">
        <segment>
          <source>no member named %0 in %1; did you mean to use '-&gt;' instead of '.'?</source>
          <target>no member named {$arg0} in {$arg1}; did you mean to use '-&gt;' instead of '.'?</target>
        </segment>
      </unit>
      <unit id="4268" name="err_no_member_suggest">
        <segment>
          <source>no member named %0 in %1; did you mean %select{|simply }2%3?</source>
          <target>no member named {$arg0} in {$arg1}; did you mean {$arg2 :select s0=|| s1=|simply |}{$arg3}?</target>
        </segment>
      </unit>
      <unit id="4269" name="err_no_member_template">
        <segment>
          <source>no template named %0 in %1</source>
          <target>no template named {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4270" name="err_no_member_template_suggest">
        <segment>
          <source>no template named %0 in %1; did you mean %select{|simply }2%3?</source>
          <target>no template named {$arg0} in {$arg1}; did you mean {$arg2 :select s0=|| s1=|simply |}{$arg3}?</target>
        </segment>
      </unit>
      <unit id="4271" name="err_no_nsconstant_string_class">
        <segment>
          <source>cannot find interface declaration for %0</source>
          <target>cannot find interface declaration for {$arg0}</target>
        </segment>
      </unit>
      <unit id="4272" name="err_no_subobject_property_setting">
        <segment>
          <source>expression is not assignable</source>
          <target>expression is not assignable</target>
        </segment>
      </unit>
      <unit id="4273" name="err_no_suitable_delete_member_function_found">
        <segment>
          <source>no suitable member %0 in %1</source>
          <target>no suitable member {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4274" name="err_no_super_class_message">
        <segment>
          <source>no @interface declaration found in class messaging of %0</source>
          <target>no @interface declaration found in class messaging of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4275" name="err_no_template">
        <segment>
          <source>no template named %0</source>
          <target>no template named {$arg0}</target>
        </segment>
      </unit>
      <unit id="4276" name="err_no_template_suggest">
        <segment>
          <source>no template named %0; did you mean %1?</source>
          <target>no template named {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="4277" name="err_no_typeid_with_fno_rtti">
        <segment>
          <source>use of typeid requires -frtti</source>
          <target>use of typeid requires -frtti</target>
        </segment>
      </unit>
      <unit id="4278" name="err_no_viable_destructor">
        <segment>
          <source>no viable destructor found for class %0</source>
          <target>no viable destructor found for class {$arg0}</target>
        </segment>
      </unit>
      <unit id="4279" name="err_nogetter_property_compound_assignment">
        <segment>
          <source>a getter method is needed to perform a compound assignment on a property</source>
          <target>a getter method is needed to perform a compound assignment on a property</target>
        </segment>
      </unit>
      <unit id="4280" name="err_nogetter_property_incdec">
        <segment>
          <source>no getter method %1 for %select{increment|decrement}0 of property</source>
          <target>no getter method {$arg1} for {$arg0 :select s0=|increment| s1=|decrement|} of property</target>
        </segment>
      </unit>
      <unit id="4281" name="err_non_asm_stmt_in_naked_function">
        <segment>
          <source>non-ASM statement in naked function is not supported</source>
          <target>non-ASM statement in naked function is not supported</target>
        </segment>
      </unit>
      <unit id="4282" name="err_non_bool_atomic_constraint">
        <segment>
          <source>atomic constraint must be of type 'bool' (found %0)</source>
          <target>atomic constraint must be of type 'bool' (found {$arg0})</target>
        </segment>
      </unit>
      <unit id="4283" name="err_non_c_like_anon_struct_in_typedef">
        <segment>
          <source>anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition</source>
          <target>anonymous non-C-compatible type given name for linkage purposes by {$arg0 :select s0=|typedef| s1=|alias|} declaration after its linkage was computed; add a tag name here to establish linkage prior to definition</target>
        </segment>
      </unit>
      <unit id="4284" name="err_non_constant_constraint_expression">
        <segment>
          <source>substitution into constraint expression resulted in a non-constant expression</source>
          <target>substitution into constraint expression resulted in a non-constant expression</target>
        </segment>
      </unit>
      <unit id="4285" name="err_non_consteval_override">
        <segment>
          <source>non-consteval function %0 cannot override a consteval function</source>
          <target>non-consteval function {$arg0} cannot override a consteval function</target>
        </segment>
      </unit>
      <unit id="4286" name="err_non_deduced_mismatch">
        <segment>
          <source>could not match %diff{$ against $|types}0,1</source>
          <target>could not match %diff{$ against $|types}0,1</target>
        </segment>
      </unit>
      <unit id="4287" name="err_non_deleted_override">
        <segment>
          <source>non-deleted function %0 cannot override a deleted function</source>
          <target>non-deleted function {$arg0} cannot override a deleted function</target>
        </segment>
      </unit>
      <unit id="4288" name="err_non_designated_init_used">
        <segment>
          <source>a randomized struct can only be initialized with a designated initializer</source>
          <target>a randomized struct can only be initialized with a designated initializer</target>
        </segment>
      </unit>
      <unit id="4289" name="err_non_extern_extern">
        <segment>
          <source>non-extern declaration of %0 follows extern declaration</source>
          <target>non-extern declaration of {$arg0} follows extern declaration</target>
        </segment>
      </unit>
      <unit id="4290" name="err_non_first_default_compare_deletes">
        <segment>
          <source>defaulting %select{this %select{&lt;ERROR&gt;|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator&lt;=&gt;'}0 would delete it after its first declaration</source>
          <target>defaulting %select{this {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational}1 comparison operator| s5=|the corresponding implicit 'operator==' for this defaulted 'operator&lt;=&gt;'|} would delete it after its first declaration</target>
        </segment>
      </unit>
      <unit id="4291" name="err_non_first_default_compare_in_class">
        <segment>
          <source>defaulting this %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class</source>
          <target>defaulting this {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator is not allowed because it was already declared outside the class</target>
        </segment>
      </unit>
      <unit id="4292" name="err_non_local_variable_decl_in_for">
        <segment>
          <source>declaration of non-local variable in 'for' loop</source>
          <target>declaration of non-local variable in 'for' loop</target>
        </segment>
      </unit>
      <unit id="4293" name="err_non_polymorphic_vtable_pointer_auth">
        <segment>
          <source>cannot set vtable pointer authentication on monomorphic type %0</source>
          <target>cannot set vtable pointer authentication on monomorphic type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4294" name="err_non_static_static">
        <segment>
          <source>non-static declaration of %0 follows static declaration</source>
          <target>non-static declaration of {$arg0} follows static declaration</target>
        </segment>
      </unit>
      <unit id="4295" name="err_non_temp_friend_decl_with_requires_clause_must_be_def">
        <segment>
          <source>non-template friend declaration with a requires clause must be a definition</source>
          <target>non-template friend declaration with a requires clause must be a definition</target>
        </segment>
      </unit>
      <unit id="4296" name="err_non_temp_spec_requires_clause">
        <segment>
          <source>%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template</source>
          <target>{$arg0 :select s0=|explicit| s1=|friend|} specialization cannot have a trailing requires clause unless it declares a function template</target>
        </segment>
      </unit>
      <unit id="4297" name="err_non_template_in_member_template_id_suggest">
        <segment>
          <source>member %0 of %1 is not a template; did you mean %select{|simply }2%3?</source>
          <target>member {$arg0} of {$arg1} is not a template; did you mean {$arg2 :select s0=|| s1=|simply |}{$arg3}?</target>
        </segment>
      </unit>
      <unit id="4298" name="err_non_template_in_template_id">
        <segment>
          <source>%0 does not name a template but is followed by template arguments</source>
          <target>{$arg0} does not name a template but is followed by template arguments</target>
        </segment>
      </unit>
      <unit id="4299" name="err_non_template_in_template_id_suggest">
        <segment>
          <source>%0 does not name a template but is followed by template arguments; did you mean %1?</source>
          <target>{$arg0} does not name a template but is followed by template arguments; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="4300" name="err_non_thread_thread">
        <segment>
          <source>non-thread-local declaration of %0 follows thread-local declaration</source>
          <target>non-thread-local declaration of {$arg0} follows thread-local declaration</target>
        </segment>
      </unit>
      <unit id="4301" name="err_non_top_level_vtable_pointer_auth">
        <segment>
          <source>cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1</source>
          <target>cannot set vtable pointer authentication on {$arg0} which is a subclass of polymorphic type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4302" name="err_non_trivial_c_union_in_invalid_context">
        <segment>
          <source>cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0</source>
          <target>cannot {$arg3 :select s0=|use type {$arg1} for a function/method parameter| s1=|use type {$arg1} for function/method return| s2=|default-initialize an object of type {$arg1}| s3=|declare an automatic variable of type {$arg1}| s4=|copy-initialize an object of type {$arg1}| s5=|assign to a variable of type {$arg1}| s6=|construct an automatic compound literal of type {$arg1}| s7=|capture a variable of type {$arg1}| s8=|cannot use volatile type {$arg1} where it causes an lvalue-to-rvalue conversion|} since it {$arg2 :select s0=|contains| s1=|is|} a union that is non-trivial to {$arg0 :select s0=|default-initialize| s1=|destruct| s2=|copy|}</target>
        </segment>
      </unit>
      <unit id="4303" name="err_non_type_template_arg_addr_label_diff">
        <segment>
          <source>template argument / label address difference / what did you expect?</source>
          <target>template argument / label address difference / what did you expect?</target>
        </segment>
      </unit>
      <unit id="4304" name="err_non_type_template_arg_subobject">
        <segment>
          <source>non-type template argument refers to subobject '%0'</source>
          <target>non-type template argument refers to subobject '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4305" name="err_non_type_template_in_nested_name_specifier">
        <segment>
          <source>qualified name refers into a specialization of %select{function|variable}0 template %1</source>
          <target>qualified name refers into a specialization of {$arg0 :select s0=|function| s1=|variable|} template {$arg1}</target>
        </segment>
      </unit>
      <unit id="4306" name="err_non_type_template_parm_type_deduction_failure">
        <segment>
          <source>non-type template parameter %0 with type %1 has incompatible initializer of type %2</source>
          <target>non-type template parameter {$arg0} with type {$arg1} has incompatible initializer of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="4307" name="err_non_variable_decl_in_for">
        <segment>
          <source>non-variable declaration in 'for' loop</source>
          <target>non-variable declaration in 'for' loop</target>
        </segment>
      </unit>
      <unit id="4308" name="err_non_virtual_pure">
        <segment>
          <source>%0 is not virtual and cannot be declared pure</source>
          <target>{$arg0} is not virtual and cannot be declared pure</target>
        </segment>
      </unit>
      <unit id="4309" name="err_nonfunction_block_type">
        <segment>
          <source>block pointer to non-function type is invalid</source>
          <target>block pointer to non-function type is invalid</target>
        </segment>
      </unit>
      <unit id="4310" name="err_nonstatic_member_out_of_line">
        <segment>
          <source>non-static data member defined out-of-line</source>
          <target>non-static data member defined out-of-line</target>
        </segment>
      </unit>
      <unit id="4311" name="err_nontemporal_builtin_must_be_pointer">
        <segment>
          <source>address argument to nontemporal builtin must be a pointer (%0 invalid)</source>
          <target>address argument to nontemporal builtin must be a pointer ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="4312" name="err_nontemporal_builtin_must_be_pointer_intfltptr_or_vector">
        <segment>
          <source>address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)</source>
          <target>address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="4313" name="err_noreturn_has_return_expr">
        <segment>
          <source>%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return</source>
          <target>{$arg0 :select s0=|function| s1=|block| s2=|lambda| s3=|coroutine|} declared 'noreturn' should not return</target>
        </segment>
      </unit>
      <unit id="4314" name="err_noreturn_non_function">
        <segment>
          <source>'_Noreturn' can only appear on functions</source>
          <target>'_Noreturn' can only appear on functions</target>
        </segment>
      </unit>
      <unit id="4315" name="err_nosetter_property_assignment">
        <segment>
          <source>%select{assignment to readonly property|no setter method %1 for assignment to property}0</source>
          <target>{$arg0 :select s0=|assignment to readonly property| s1=|no setter method {$arg1} for assignment to property|}</target>
        </segment>
      </unit>
      <unit id="4316" name="err_nosetter_property_incdec">
        <segment>
          <source>%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0</source>
          <target>%select{{$arg1 :select s0=|increment| s1=|decrement|} of readonly property|no setter method {$arg2} for {$arg0 :select s0=|increment| s1=|decrement}1 of property|}</target>
        </segment>
      </unit>
      <unit id="4317" name="err_not_class_template_specialization">
        <segment>
          <source>cannot specialize a %select{dependent template|template template parameter}0</source>
          <target>cannot specialize a {$arg0 :select s0=|dependent template| s1=|template template parameter|}</target>
        </segment>
      </unit>
      <unit id="4318" name="err_not_direct_base_or_virtual">
        <segment>
          <source>type %0 is not a direct or virtual base of %1</source>
          <target>type {$arg0} is not a direct or virtual base of {$arg1}</target>
        </segment>
      </unit>
      <unit id="4319" name="err_not_found_by_two_phase_lookup">
        <segment>
          <source>call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup</source>
          <target>call to function {$arg0} that is neither visible in the template definition nor found by argument-dependent lookup</target>
        </segment>
      </unit>
      <unit id="4320" name="err_not_integral_type_anon_bitfield">
        <segment>
          <source>anonymous bit-field has non-integral type %0</source>
          <target>anonymous bit-field has non-integral type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4321" name="err_not_integral_type_bitfield">
        <segment>
          <source>bit-field %0 has non-integral type %1</source>
          <target>bit-field {$arg0} has non-integral type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4322" name="err_not_tag_in_scope">
        <segment>
          <source>no %select{struct|interface|union|class|enum}0 named %1 in %2</source>
          <target>no {$arg0 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} named {$arg1} in {$arg2}</target>
        </segment>
      </unit>
      <unit id="4323" name="err_ns_attribute_wrong_parameter_type">
        <segment>
          <source>%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters</source>
          <target>{$arg0} attribute only applies to {$arg1 :select s0=|Objective-C object| s1=|pointer| s2=|pointer-to-CF-pointer|} parameters</target>
        </segment>
      </unit>
      <unit id="4324" name="err_nsconsumed_attribute_mismatch">
        <segment>
          <source>overriding method has mismatched ns_consumed attribute on its parameter</source>
          <target>overriding method has mismatched ns_consumed attribute on its parameter</target>
        </segment>
      </unit>
      <unit id="4325" name="err_nserrordomain_invalid_decl">
        <segment>
          <source>domain argument %select{|%1 }0does not refer to global constant</source>
          <target>domain argument {$arg0 :select s0=|| s1=|{$arg1} |}does not refer to global constant</target>
        </segment>
      </unit>
      <unit id="4326" name="err_nserrordomain_wrong_type">
        <segment>
          <source>domain argument %0 does not point to an NSString or CFString constant</source>
          <target>domain argument {$arg0} does not point to an NSString or CFString constant</target>
        </segment>
      </unit>
      <unit id="4327" name="err_nsobject_attribute">
        <segment>
          <source>'NSObject' attribute is for pointer types only</source>
          <target>'NSObject' attribute is for pointer types only</target>
        </segment>
      </unit>
      <unit id="4328" name="err_nsreturns_retained_attribute_mismatch">
        <segment>
          <source>overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes</source>
          <target>overriding method has mismatched ns_returns_{$arg0 :select s0=|not_retained| s1=|retained|} attributes</target>
        </segment>
      </unit>
      <unit id="4329" name="err_nullability_cs_multilevel">
        <segment>
          <source>nullability keyword %0 cannot be applied to multi-level pointer type %1</source>
          <target>nullability keyword {$arg0} cannot be applied to multi-level pointer type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4330" name="err_nullability_nonpointer">
        <segment>
          <source>nullability specifier %0 cannot be applied to non-pointer type %1</source>
          <target>nullability specifier {$arg0} cannot be applied to non-pointer type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4331" name="err_nullptr_cast">
        <segment>
          <source>cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0</source>
          <target>cannot cast an object of type {$arg0 :select s0=|'nullptr_t' to {$arg1}| s1=|{$arg1} to 'nullptr_t'|}</target>
        </segment>
      </unit>
      <unit id="4332" name="err_objc_array_of_interfaces">
        <segment>
          <source>array of interface %0 is invalid (probably should be an array of pointers)</source>
          <target>array of interface {$arg0} is invalid (probably should be an array of pointers)</target>
        </segment>
      </unit>
      <unit id="4333" name="err_objc_attr_not_id">
        <segment>
          <source>parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1</source>
          <target>parameter of {$arg0} attribute must be a single name of an Objective-C {$arg1 :select s0=|class| s1=|protocol|}</target>
        </segment>
      </unit>
      <unit id="4334" name="err_objc_attr_protocol_requires_definition">
        <segment>
          <source>attribute %0 can only be applied to @protocol definitions, not forward declarations</source>
          <target>attribute {$arg0} can only be applied to @protocol definitions, not forward declarations</target>
        </segment>
      </unit>
      <unit id="4335" name="err_objc_attr_typedef_not_id">
        <segment>
          <source>parameter of %0 attribute must be 'id' when used on a typedef</source>
          <target>parameter of {$arg0} attribute must be 'id' when used on a typedef</target>
        </segment>
      </unit>
      <unit id="4336" name="err_objc_attr_typedef_not_void_pointer">
        <segment>
          <source>'objc_bridge(id)' is only allowed on structs and typedefs of void pointers</source>
          <target>'objc_bridge(id)' is only allowed on structs and typedefs of void pointers</target>
        </segment>
      </unit>
      <unit id="4337" name="err_objc_bridged_related_invalid_class">
        <segment>
          <source>could not find Objective-C class %0 to convert %1 to %2</source>
          <target>could not find Objective-C class {$arg0} to convert {$arg1} to {$arg2}</target>
        </segment>
      </unit>
      <unit id="4338" name="err_objc_bridged_related_invalid_class_name">
        <segment>
          <source>%0 must be name of an Objective-C class to be able to convert %1 to %2</source>
          <target>{$arg0} must be name of an Objective-C class to be able to convert {$arg1} to {$arg2}</target>
        </segment>
      </unit>
      <unit id="4339" name="err_objc_bridged_related_known_method">
        <segment>
          <source>%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion</source>
          <target>{$arg0} must be explicitly converted to {$arg1}; use {$arg3 :select s0=|%objcclass2| s1=|%objcinstance2|} method for this conversion</target>
        </segment>
      </unit>
      <unit id="4340" name="err_objc_cf_bridged_not_interface">
        <segment>
          <source>CF object of type %0 is bridged to %1, which is not an Objective-C class</source>
          <target>CF object of type {$arg0} is bridged to {$arg1}, which is not an Objective-C class</target>
        </segment>
      </unit>
      <unit id="4341" name="err_objc_decls_may_only_appear_in_global_scope">
        <segment>
          <source>Objective-C declarations may only appear in global scope</source>
          <target>Objective-C declarations may only appear in global scope</target>
        </segment>
      </unit>
      <unit id="4342" name="err_objc_direct_duplicate_decl">
        <segment>
          <source>%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3</source>
          <target>{$arg0 :select s0=|| s1=|direct |}{$arg1 :select s0=|method| s1=|property|} declaration conflicts with previous {$arg2 :select s0=|| s1=|direct |}declaration of {$arg1 :select s0=|method| s1=|property|} {$arg3}</target>
        </segment>
      </unit>
      <unit id="4343" name="err_objc_direct_dynamic_property">
        <segment>
          <source>direct property cannot be @dynamic</source>
          <target>direct property cannot be @dynamic</target>
        </segment>
      </unit>
      <unit id="4344" name="err_objc_direct_impl_decl_mismatch">
        <segment>
          <source>direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1</source>
          <target>direct method was declared in {$arg0 :select s0=|the primary interface| s1=|an extension| s2=|a category|} but is implemented in {$arg1 :select s0=|the primary interface| s1=|a category| s2=|a different category|}</target>
        </segment>
      </unit>
      <unit id="4345" name="err_objc_direct_missing_on_decl">
        <segment>
          <source>direct method implementation was previously declared not direct</source>
          <target>direct method implementation was previously declared not direct</target>
        </segment>
      </unit>
      <unit id="4346" name="err_objc_direct_on_override">
        <segment>
          <source>methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct</source>
          <target>methods that {$arg0 :select s0=|override superclass methods| s1=|implement protocol requirements|} cannot be direct</target>
        </segment>
      </unit>
      <unit id="4347" name="err_objc_direct_on_protocol">
        <segment>
          <source>'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol</source>
          <target>'objc_direct' attribute cannot be applied to {$arg0 :select s0=|methods| s1=|properties|} declared in an Objective-C protocol</target>
        </segment>
      </unit>
      <unit id="4348" name="err_objc_direct_protocol_conformance">
        <segment>
          <source>%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3</source>
          <target>{$arg0 :select s0=|category {$arg1}| s1=|class extension|} cannot conform to protocol {$arg2} because of direct members declared in interface {$arg3}</target>
        </segment>
      </unit>
      <unit id="4349" name="err_objc_exceptions_disabled">
        <segment>
          <source>cannot use '%0' with Objective-C exceptions disabled</source>
          <target>cannot use '{$arg0}' with Objective-C exceptions disabled</target>
        </segment>
      </unit>
      <unit id="4350" name="err_objc_for_range_init_stmt">
        <segment>
          <source>initialization statement is not supported when iterating over Objective-C collection</source>
          <target>initialization statement is not supported when iterating over Objective-C collection</target>
        </segment>
      </unit>
      <unit id="4351" name="err_objc_illegal_boxed_expression_type">
        <segment>
          <source>illegal type %0 used in a boxed expression</source>
          <target>illegal type {$arg0} used in a boxed expression</target>
        </segment>
      </unit>
      <unit id="4352" name="err_objc_incomplete_boxed_expression_type">
        <segment>
          <source>incomplete type %0 used in a boxed expression</source>
          <target>incomplete type {$arg0} used in a boxed expression</target>
        </segment>
      </unit>
      <unit id="4353" name="err_objc_index_incomplete_class_type">
        <segment>
          <source>Objective-C index expression has incomplete class type %0</source>
          <target>Objective-C index expression has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4354" name="err_objc_indexing_method_result_type">
        <segment>
          <source>method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0</source>
          <target>method for accessing {$arg1 :select s0=|dictionary| s1=|array|} element must have Objective-C object return type instead of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4355" name="err_objc_kindof_nonobject">
        <segment>
          <source>'__kindof' specifier cannot be applied to non-object type %0</source>
          <target>'__kindof' specifier cannot be applied to non-object type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4356" name="err_objc_kindof_wrong_position">
        <segment>
          <source>'__kindof' type specifier must precede the declarator</source>
          <target>'__kindof' type specifier must precede the declarator</target>
        </segment>
      </unit>
      <unit id="4357" name="err_objc_literal_method_sig">
        <segment>
          <source>literal construction method %0 has incompatible signature</source>
          <target>literal construction method {$arg0} has incompatible signature</target>
        </segment>
      </unit>
      <unit id="4358" name="err_objc_method_unsupported_param_ret_type">
        <segment>
          <source>%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2</source>
          <target>{$arg0} {$arg1 :select s0=|parameter| s1=|return|} type is unsupported; support for vector types for this target is introduced in {$arg2}</target>
        </segment>
      </unit>
      <unit id="4359" name="err_objc_multiple_subscript_type_conversion">
        <segment>
          <source>indexing expression is invalid because subscript type %0 has multiple type conversion functions</source>
          <target>indexing expression is invalid because subscript type {$arg0} has multiple type conversion functions</target>
        </segment>
      </unit>
      <unit id="4360" name="err_objc_non_runtime_protocol_in_protocol_expr">
        <segment>
          <source>cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression</source>
          <target>cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression</target>
        </segment>
      </unit>
      <unit id="4361" name="err_objc_non_trivially_copyable_boxed_expression_type">
        <segment>
          <source>non-trivially copyable type %0 cannot be used in a boxed expression</source>
          <target>non-trivially copyable type {$arg0} cannot be used in a boxed expression</target>
        </segment>
      </unit>
      <unit id="4362" name="err_objc_ns_bridged_invalid_cfobject">
        <segment>
          <source>Objective-C object of type %0 is bridged to %1, which is not valid CF object</source>
          <target>Objective-C object of type {$arg0} is bridged to {$arg1}, which is not valid CF object</target>
        </segment>
      </unit>
      <unit id="4363" name="err_objc_object_assignment">
        <segment>
          <source>cannot assign to class object (%0 invalid)</source>
          <target>cannot assign to class object ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="4364" name="err_objc_object_catch">
        <segment>
          <source>cannot catch an Objective-C object by value</source>
          <target>cannot catch an Objective-C object by value</target>
        </segment>
      </unit>
      <unit id="4365" name="err_objc_override_direct_method">
        <segment>
          <source>cannot override a method that is declared direct by a superclass</source>
          <target>cannot override a method that is declared direct by a superclass</target>
        </segment>
      </unit>
      <unit id="4366" name="err_objc_parameterized_category_nonclass">
        <segment>
          <source>%select{extension|category}0 of non-parameterized class %1 cannot have type parameters</source>
          <target>{$arg0 :select s0=|extension| s1=|category|} of non-parameterized class {$arg1} cannot have type parameters</target>
        </segment>
      </unit>
      <unit id="4367" name="err_objc_parameterized_forward_class">
        <segment>
          <source>forward declaration of non-parameterized class %0 cannot have type parameters</source>
          <target>forward declaration of non-parameterized class {$arg0} cannot have type parameters</target>
        </segment>
      </unit>
      <unit id="4368" name="err_objc_parameterized_forward_class_first">
        <segment>
          <source>class %0 previously declared with type parameters</source>
          <target>class {$arg0} previously declared with type parameters</target>
        </segment>
      </unit>
      <unit id="4369" name="err_objc_precise_lifetime_bad_type">
        <segment>
          <source>objc_precise_lifetime only applies to retainable types; type here is %0</source>
          <target>objc_precise_lifetime only applies to retainable types; type here is {$arg0}</target>
        </segment>
      </unit>
      <unit id="4370" name="err_objc_property_attr_mutually_exclusive">
        <segment>
          <source>property attributes '%0' and '%1' are mutually exclusive</source>
          <target>property attributes '{$arg0}' and '{$arg1}' are mutually exclusive</target>
        </segment>
      </unit>
      <unit id="4371" name="err_objc_property_requires_object">
        <segment>
          <source>property with '%0' attribute must be of object type</source>
          <target>property with '{$arg0}' attribute must be of object type</target>
        </segment>
      </unit>
      <unit id="4372" name="err_objc_root_class_subclass">
        <segment>
          <source>objc_root_class attribute may only be specified on a root class declaration</source>
          <target>objc_root_class attribute may only be specified on a root class declaration</target>
        </segment>
      </unit>
      <unit id="4373" name="err_objc_runtime_visible_category">
        <segment>
          <source>cannot implement a category for class %0 that is only visible via the Objective-C runtime</source>
          <target>cannot implement a category for class {$arg0} that is only visible via the Objective-C runtime</target>
        </segment>
      </unit>
      <unit id="4374" name="err_objc_runtime_visible_subclass">
        <segment>
          <source>cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime</source>
          <target>cannot implement subclass {$arg0} of a superclass {$arg1} that is only visible via the Objective-C runtime</target>
        </segment>
      </unit>
      <unit id="4375" name="err_objc_subscript_base_type">
        <segment>
          <source>%select{dictionary|array}1 subscript base type %0 is not an Objective-C object</source>
          <target>{$arg1 :select s0=|dictionary| s1=|array|} subscript base type {$arg0} is not an Objective-C object</target>
        </segment>
      </unit>
      <unit id="4376" name="err_objc_subscript_dic_object_type">
        <segment>
          <source>method object parameter type %0 is not object type</source>
          <target>method object parameter type {$arg0} is not object type</target>
        </segment>
      </unit>
      <unit id="4377" name="err_objc_subscript_index_type">
        <segment>
          <source>method index parameter type %0 is not integral type</source>
          <target>method index parameter type {$arg0} is not integral type</target>
        </segment>
      </unit>
      <unit id="4378" name="err_objc_subscript_key_type">
        <segment>
          <source>method key parameter type %0 is not object type</source>
          <target>method key parameter type {$arg0} is not object type</target>
        </segment>
      </unit>
      <unit id="4379" name="err_objc_subscript_method_not_found">
        <segment>
          <source>expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0</source>
          <target>expected method to {$arg1 :select s0=|read| s1=|write|} {$arg2 :select s0=|dictionary| s1=|array|} element not found on object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4380" name="err_objc_subscript_object_type">
        <segment>
          <source>cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type</source>
          <target>cannot assign to this {$arg1 :select s0=|dictionary| s1=|array|} because assigning method's 2nd parameter of type {$arg0} is not an Objective-C pointer type</target>
        </segment>
      </unit>
      <unit id="4381" name="err_objc_subscript_pointer">
        <segment>
          <source>indexing expression is invalid because subscript type %0 is not an Objective-C pointer</source>
          <target>indexing expression is invalid because subscript type {$arg0} is not an Objective-C pointer</target>
        </segment>
      </unit>
      <unit id="4382" name="err_objc_subscript_type_conversion">
        <segment>
          <source>indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type</source>
          <target>indexing expression is invalid because subscript type {$arg0} is not an integral or Objective-C pointer type</target>
        </segment>
      </unit>
      <unit id="4383" name="err_objc_synchronized_expects_object">
        <segment>
          <source>@synchronized requires an Objective-C object type (%0 invalid)</source>
          <target>@synchronized requires an Objective-C object type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="4384" name="err_objc_throw_expects_object">
        <segment>
          <source>@throw requires an Objective-C object type (%0 invalid)</source>
          <target>@throw requires an Objective-C object type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="4385" name="err_objc_type_arg_does_not_match_bound">
        <segment>
          <source>type argument %0 does not satisfy the bound (%1) of type parameter %2</source>
          <target>type argument {$arg0} does not satisfy the bound ({$arg1}) of type parameter {$arg2}</target>
        </segment>
      </unit>
      <unit id="4386" name="err_objc_type_arg_explicit_nullability">
        <segment>
          <source>type argument %0 cannot explicitly specify nullability</source>
          <target>type argument {$arg0} cannot explicitly specify nullability</target>
        </segment>
      </unit>
      <unit id="4387" name="err_objc_type_arg_missing">
        <segment>
          <source>no type or protocol named %0</source>
          <target>no type or protocol named {$arg0}</target>
        </segment>
      </unit>
      <unit id="4388" name="err_objc_type_arg_missing_star">
        <segment>
          <source>type argument %0 must be a pointer (requires a '*')</source>
          <target>type argument {$arg0} must be a pointer (requires a '*')</target>
        </segment>
      </unit>
      <unit id="4389" name="err_objc_type_arg_not_id_compatible">
        <segment>
          <source>type argument %0 is neither an Objective-C object nor a block type</source>
          <target>type argument {$arg0} is neither an Objective-C object nor a block type</target>
        </segment>
      </unit>
      <unit id="4390" name="err_objc_type_arg_qualified">
        <segment>
          <source>type argument %0 cannot be qualified with '%1'</source>
          <target>type argument {$arg0} cannot be qualified with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4391" name="err_objc_type_args_and_protocols">
        <segment>
          <source>angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)</source>
          <target>angle brackets contain both a {$arg0 :select s0=|type| s1=|protocol|} ({$arg1}) and a {$arg0 :select s0=|protocol| s1=|type|} ({$arg2})</target>
        </segment>
      </unit>
      <unit id="4392" name="err_objc_type_args_non_class">
        <segment>
          <source>type arguments cannot be applied to non-class type %0</source>
          <target>type arguments cannot be applied to non-class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4393" name="err_objc_type_args_non_parameterized_class">
        <segment>
          <source>type arguments cannot be applied to non-parameterized class %0</source>
          <target>type arguments cannot be applied to non-parameterized class {$arg0}</target>
        </segment>
      </unit>
      <unit id="4394" name="err_objc_type_args_specialized_class">
        <segment>
          <source>type arguments cannot be applied to already-specialized class type %0</source>
          <target>type arguments cannot be applied to already-specialized class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4395" name="err_objc_type_args_wrong_arity">
        <segment>
          <source>too %select{many|few}0 type arguments for class %1 (have %2, expected %3)</source>
          <target>too {$arg0 :select s0=|many| s1=|few|} type arguments for class {$arg1} (have {$arg2}, expected {$arg3})</target>
        </segment>
      </unit>
      <unit id="4396" name="err_objc_type_param_arity_mismatch">
        <segment>
          <source>%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)</source>
          <target>{$arg0 :select s0=|forward class declaration| s1=|class definition| s2=|category| s3=|extension|} has too {$arg1 :select s0=|few| s1=|many|} type parameters (expected {$arg2}, have {$arg3})</target>
        </segment>
      </unit>
      <unit id="4397" name="err_objc_type_param_bound_conflict">
        <segment>
          <source>type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4</source>
          <target>type bound {$arg0} for type parameter {$arg1} conflicts with {$arg2 :select s0=|implicit| s1=|previous|} bound {$arg3}{$arg4 :select s0=|for type parameter {$arg5}| s1=||}</target>
        </segment>
      </unit>
      <unit id="4398" name="err_objc_type_param_bound_explicit_nullability">
        <segment>
          <source>type parameter %0 bound %1 cannot explicitly specify nullability</source>
          <target>type parameter {$arg0} bound {$arg1} cannot explicitly specify nullability</target>
        </segment>
      </unit>
      <unit id="4399" name="err_objc_type_param_bound_missing">
        <segment>
          <source>missing type bound %0 for type parameter %1 in %select{@interface|@class}2</source>
          <target>missing type bound {$arg0} for type parameter {$arg1} in {$arg2 :select s0=|@interface| s1=|@class|}</target>
        </segment>
      </unit>
      <unit id="4400" name="err_objc_type_param_bound_missing_pointer">
        <segment>
          <source>missing '*' in type bound %0 for type parameter %1</source>
          <target>missing '*' in type bound {$arg0} for type parameter {$arg1}</target>
        </segment>
      </unit>
      <unit id="4401" name="err_objc_type_param_bound_nonobject">
        <segment>
          <source>type bound %0 for type parameter %1 is not an Objective-C pointer type</source>
          <target>type bound {$arg0} for type parameter {$arg1} is not an Objective-C pointer type</target>
        </segment>
      </unit>
      <unit id="4402" name="err_objc_type_param_bound_qualified">
        <segment>
          <source>type bound %1 for type parameter %0 cannot be qualified with '%2'</source>
          <target>type bound {$arg1} for type parameter {$arg0} cannot be qualified with '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="4403" name="err_objc_type_param_redecl">
        <segment>
          <source>redeclaration of type parameter %0</source>
          <target>redeclaration of type parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="4404" name="err_objc_type_param_variance_conflict">
        <segment>
          <source>%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3</source>
          <target>{$arg0 :select s0=|in| s1=|co| s2=|contra|}variant type parameter {$arg1} conflicts with previous {$arg2 :select s0=|in| s1=|co| s2=|contra|}variant type parameter {$arg3}</target>
        </segment>
      </unit>
      <unit id="4405" name="err_objc_var_decl_inclass">
        <segment>
          <source>cannot declare variable inside @interface or @protocol</source>
          <target>cannot declare variable inside @interface or @protocol</target>
        </segment>
      </unit>
      <unit id="4406" name="err_objc_variable_sized_type_not_at_end">
        <segment>
          <source>field %0 with variable sized type %1 is not at the end of class</source>
          <target>field {$arg0} with variable sized type {$arg1} is not at the end of class</target>
        </segment>
      </unit>
      <unit id="4407" name="err_object_cannot_be_passed_returned_by_value">
        <segment>
          <source>interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?</source>
          <target>interface type {$arg1} cannot be {$arg0 :select s0=|returned| s1=|passed|} by value; did you forget * in {$arg1}?</target>
        </segment>
      </unit>
      <unit id="4408" name="err_offsetof_array_type">
        <segment>
          <source>offsetof requires array type, %0 invalid</source>
          <target>offsetof requires array type, {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="4409" name="err_offsetof_bitfield">
        <segment>
          <source>cannot compute offset of bit-field %0</source>
          <target>cannot compute offset of bit-field {$arg0}</target>
        </segment>
      </unit>
      <unit id="4410" name="err_offsetof_field_of_virtual_base">
        <segment>
          <source>invalid application of 'offsetof' to a field of a virtual base</source>
          <target>invalid application of 'offsetof' to a field of a virtual base</target>
        </segment>
      </unit>
      <unit id="4411" name="err_offsetof_incomplete_type">
        <segment>
          <source>offsetof of incomplete type %0</source>
          <target>offsetof of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4412" name="err_offsetof_record_type">
        <segment>
          <source>offsetof requires struct, union, or class type, %0 invalid</source>
          <target>offsetof requires struct, union, or class type, {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="4413" name="err_omp_adjust_arg_multiple_clauses">
        <segment>
          <source>'adjust_arg' argument %0 used in multiple clauses</source>
          <target>'adjust_arg' argument {$arg0} used in multiple clauses</target>
        </segment>
      </unit>
      <unit id="4414" name="err_omp_aligned_expected_array_or_ptr">
        <segment>
          <source>argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0</source>
          <target>argument of aligned clause should be array{$arg1 :select s0=| or pointer| s1=|, pointer, reference to array or reference to pointer|}, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4415" name="err_omp_allocator_not_in_uses_allocators">
        <segment>
          <source>allocator must be specified in the 'uses_allocators' clause</source>
          <target>allocator must be specified in the 'uses_allocators' clause</target>
        </segment>
      </unit>
      <unit id="4416" name="err_omp_allocator_used_in_clauses">
        <segment>
          <source>allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses</source>
          <target>allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses</target>
        </segment>
      </unit>
      <unit id="4417" name="err_omp_ambiguous_conversion">
        <segment>
          <source>ambiguous conversion from type %0 to an integral or unscoped enumeration type</source>
          <target>ambiguous conversion from type {$arg0} to an integral or unscoped enumeration type</target>
        </segment>
      </unit>
      <unit id="4418" name="err_omp_append_args_with_varargs">
        <segment>
          <source>'append_args' is not allowed with varargs functions</source>
          <target>'append_args' is not allowed with varargs functions</target>
        </segment>
      </unit>
      <unit id="4419" name="err_omp_argument_type_isdeviceptr">
        <segment>
          <source>expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'</source>
          <target>expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'</target>
        </segment>
      </unit>
      <unit id="4420" name="err_omp_array_shaping_use">
        <segment>
          <source>OpenMP array shaping operation is not allowed here</source>
          <target>OpenMP array shaping operation is not allowed here</target>
        </segment>
      </unit>
      <unit id="4421" name="err_omp_at_least_one_motion_clause_required">
        <segment>
          <source>expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'</source>
          <target>expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'</target>
        </segment>
      </unit>
      <unit id="4422" name="err_omp_atomic_capture_not_compound_statement">
        <segment>
          <source>the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type</source>
          <target>the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type</target>
        </segment>
      </unit>
      <unit id="4423" name="err_omp_atomic_capture_not_expression_statement">
        <segment>
          <source>the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type</source>
          <target>the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type</target>
        </segment>
      </unit>
      <unit id="4424" name="err_omp_atomic_compare">
        <segment>
          <source>the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '&lt;' or '&gt;'</source>
          <target>the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '&lt;' or '&gt;'</target>
        </segment>
      </unit>
      <unit id="4425" name="err_omp_atomic_compare_capture">
        <segment>
          <source>the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '&lt;' or '&gt;'</source>
          <target>the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '&lt;' or '&gt;'</target>
        </segment>
      </unit>
      <unit id="4426" name="err_omp_atomic_fail_wrong_or_no_clauses">
        <segment>
          <source>expected a memory order clause</source>
          <target>expected a memory order clause</target>
        </segment>
      </unit>
      <unit id="4427" name="err_omp_atomic_incompatible_mem_order_clause">
        <segment>
          <source>directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause</source>
          <target>directive '#pragma omp atomic{$arg1 :select s0=| {$arg0}| s1=||}' cannot be used with '{$arg2}' clause</target>
        </segment>
      </unit>
      <unit id="4428" name="err_omp_atomic_no_compare">
        <segment>
          <source>expected 'compare' clause with the '%0' modifier</source>
          <target>expected 'compare' clause with the '{$arg0}' modifier</target>
        </segment>
      </unit>
      <unit id="4429" name="err_omp_atomic_not_expression_statement">
        <segment>
          <source>the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type</source>
          <target>the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type</target>
        </segment>
      </unit>
      <unit id="4430" name="err_omp_atomic_read_not_expression_statement">
        <segment>
          <source>the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type</source>
          <target>the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type</target>
        </segment>
      </unit>
      <unit id="4431" name="err_omp_atomic_several_clauses">
        <segment>
          <source>directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause</source>
          <target>directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause</target>
        </segment>
      </unit>
      <unit id="4432" name="err_omp_atomic_update_not_expression_statement">
        <segment>
          <source>the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type</source>
          <target>the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type</target>
        </segment>
      </unit>
      <unit id="4433" name="err_omp_atomic_weak_no_equality">
        <segment>
          <source>expected '==' operator for 'weak' clause</source>
          <target>expected '==' operator for 'weak' clause</target>
        </segment>
      </unit>
      <unit id="4434" name="err_omp_atomic_write_not_expression_statement">
        <segment>
          <source>the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type</source>
          <target>the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type</target>
        </segment>
      </unit>
      <unit id="4435" name="err_omp_bind_required_on_loop">
        <segment>
          <source>expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct</source>
          <target>expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct</target>
        </segment>
      </unit>
      <unit id="4436" name="err_omp_bit_fields_forbidden_in_clause">
        <segment>
          <source>bit fields cannot be used to specify storage in a '%0' clause</source>
          <target>bit fields cannot be used to specify storage in a '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="4437" name="err_omp_cannot_update_with_internal_linkage">
        <segment>
          <source>the host cannot update a declare target variable that is not externally visible</source>
          <target>the host cannot update a declare target variable that is not externally visible</target>
        </segment>
      </unit>
      <unit id="4438" name="err_omp_clause_floating_type_arg">
        <segment>
          <source>arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type</source>
          <target>arguments of OpenMP clause '{$arg0}' with bitwise operators cannot be of floating type</target>
        </segment>
      </unit>
      <unit id="4439" name="err_omp_clause_not_arithmetic_type_arg">
        <segment>
          <source>arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type</source>
          <target>arguments of OpenMP clause '{$arg0}' for 'min' or 'max' must be of {$arg1 :select s0=|scalar| s1=|arithmetic|} type</target>
        </segment>
      </unit>
      <unit id="4440" name="err_omp_clause_requires_dispatch_construct">
        <segment>
          <source>'%0' clause requires 'dispatch' context selector</source>
          <target>'{$arg0}' clause requires 'dispatch' context selector</target>
        </segment>
      </unit>
      <unit id="4441" name="err_omp_clauses_mutually_exclusive">
        <segment>
          <source>'%0' and '%1' clause are mutually exclusive and may not appear on the same directive</source>
          <target>'{$arg0}' and '{$arg1}' clause are mutually exclusive and may not appear on the same directive</target>
        </segment>
      </unit>
      <unit id="4442" name="err_omp_const_list_item">
        <segment>
          <source>const-qualified list item cannot be %0</source>
          <target>const-qualified list item cannot be {$arg0}</target>
        </segment>
      </unit>
      <unit id="4443" name="err_omp_const_not_mutable_variable">
        <segment>
          <source>const-qualified variable without mutable fields cannot be %0</source>
          <target>const-qualified variable without mutable fields cannot be {$arg0}</target>
        </segment>
      </unit>
      <unit id="4444" name="err_omp_const_variable">
        <segment>
          <source>const-qualified variable cannot be %0</source>
          <target>const-qualified variable cannot be {$arg0}</target>
        </segment>
      </unit>
      <unit id="4445" name="err_omp_critical_with_hint">
        <segment>
          <source>constructs with the same name must have a 'hint' clause with the same value</source>
          <target>constructs with the same name must have a 'hint' clause with the same value</target>
        </segment>
      </unit>
      <unit id="4446" name="err_omp_declare_mapper_redefinition">
        <segment>
          <source>redefinition of user-defined mapper for type %0 with name %1</source>
          <target>redefinition of user-defined mapper for type {$arg0} with name {$arg1}</target>
        </segment>
      </unit>
      <unit id="4447" name="err_omp_declare_mapper_wrong_var">
        <segment>
          <source>only variable %0 is allowed in map clauses of this 'omp declare mapper' directive</source>
          <target>only variable {$arg0} is allowed in map clauses of this 'omp declare mapper' directive</target>
        </segment>
      </unit>
      <unit id="4448" name="err_omp_declare_reduction_redefinition">
        <segment>
          <source>redefinition of user-defined reduction for type %0</source>
          <target>redefinition of user-defined reduction for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4449" name="err_omp_declare_target_has_local_vars">
        <segment>
          <source state="initial">local variable '%0' should not be used in 'declare target' directive;</source>
          <target>local variable '{$arg0}' should not be used in 'declare target' directive;</target>
        </segment>
      </unit>
      <unit id="4450" name="err_omp_declare_target_to_and_link">
        <segment>
          <source>%0 must not appear in both clauses 'to' and 'link'</source>
          <target>{$arg0} must not appear in both clauses 'to' and 'link'</target>
        </segment>
      </unit>
      <unit id="4451" name="err_omp_declare_variant_diff">
        <segment>
          <source>function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0</source>
          <target>function with '#pragma omp declare variant' has a different {$arg0 :select s0=|calling convention| s1=|return type| s2=|constexpr specification| s3=|inline specification| s4=|storage class| s5=|linkage|}</target>
        </segment>
      </unit>
      <unit id="4452" name="err_omp_declare_variant_doesnt_support">
        <segment>
          <source>'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0</source>
          <target>'#pragma omp declare variant' does not support {$arg0 :select s0=|function templates| s1=|virtual functions| s2=|deduced return types| s3=|constructors| s4=|destructors| s5=|deleted functions| s6=|defaulted functions| s7=|constexpr functions| s8=|consteval function|}</target>
        </segment>
      </unit>
      <unit id="4453" name="err_omp_declare_variant_incompat_attributes">
        <segment>
          <source>'#pragma omp declare variant' is not compatible with any target-specific attributes</source>
          <target>'#pragma omp declare variant' is not compatible with any target-specific attributes</target>
        </segment>
      </unit>
      <unit id="4454" name="err_omp_declare_variant_incompat_types">
        <segment>
          <source>variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2</source>
          <target>variant in '#pragma omp declare variant' with type {$arg0} is incompatible with type {$arg1}{$arg2 :select s0=|| s1=| with appended arguments|}</target>
        </segment>
      </unit>
      <unit id="4455" name="err_omp_declare_variant_prototype_required">
        <segment>
          <source>function with '#pragma omp declare variant' must have a prototype when 'append_args' is used</source>
          <target>function with '#pragma omp declare variant' must have a prototype when 'append_args' is used</target>
        </segment>
      </unit>
      <unit id="4456" name="err_omp_declare_variant_same_base_function">
        <segment>
          <source>variant in '#pragma omp declare variant' is the same as the base function</source>
          <target>variant in '#pragma omp declare variant' is the same as the base function</target>
        </segment>
      </unit>
      <unit id="4457" name="err_omp_declare_variant_user_condition_not_constant">
        <segment>
          <source>the user condition in the OpenMP context selector needs to be constant; %0 is not</source>
          <target>the user condition in the OpenMP context selector needs to be constant; {$arg0} is not</target>
        </segment>
      </unit>
      <unit id="4458" name="err_omp_defaultmap_no_attr_for_variable">
        <segment>
          <source>variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause</source>
          <target>variable {$arg0} must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause</target>
        </segment>
      </unit>
      <unit id="4459" name="err_omp_depend_clause_thread_simd">
        <segment>
          <source>'%0' clauses cannot be mixed with '%1' clause</source>
          <target>'{$arg0}' clauses cannot be mixed with '{$arg1}' clause</target>
        </segment>
      </unit>
      <unit id="4460" name="err_omp_depend_modifier_not_iterator">
        <segment>
          <source>expected iterator specification as depend modifier</source>
          <target>expected iterator specification as depend modifier</target>
        </segment>
      </unit>
      <unit id="4461" name="err_omp_depend_sink_expected_loop_iteration">
        <segment>
          <source>expected%select{| %1}0 loop iteration variable</source>
          <target>expected{$arg0 :select s0=|| s1=| {$arg1}|} loop iteration variable</target>
        </segment>
      </unit>
      <unit id="4462" name="err_omp_depend_sink_expected_plus_minus">
        <segment>
          <source>expected '+' or '-' operation</source>
          <target>expected '+' or '-' operation</target>
        </segment>
      </unit>
      <unit id="4463" name="err_omp_depend_sink_source_with_modifier">
        <segment>
          <source>depend modifier cannot be used with 'sink' or 'source' depend type</source>
          <target>depend modifier cannot be used with 'sink' or 'source' depend type</target>
        </segment>
      </unit>
      <unit id="4464" name="err_omp_depend_sink_unexpected_expr">
        <segment>
          <source>unexpected expression: number of expressions is larger than the number of associated loops</source>
          <target>unexpected expression: number of expressions is larger than the number of associated loops</target>
        </segment>
      </unit>
      <unit id="4465" name="err_omp_depend_zero_length_array_section_not_allowed">
        <segment>
          <source>zero-length array section is not allowed in 'depend' clause</source>
          <target>zero-length array section is not allowed in 'depend' clause</target>
        </segment>
      </unit>
      <unit id="4466" name="err_omp_depobj_expected">
        <segment>
          <source>expected depobj expression</source>
          <target>expected depobj expression</target>
        </segment>
      </unit>
      <unit id="4467" name="err_omp_depobj_single_clause_expected">
        <segment>
          <source>exactly one of 'depend', 'destroy', or 'update' clauses is expected</source>
          <target>exactly one of 'depend', 'destroy', or 'update' clauses is expected</target>
        </segment>
      </unit>
      <unit id="4468" name="err_omp_device_ancestor_without_requires_reverse_offload">
        <segment>
          <source>device clause with ancestor device-modifier used without specifying 'requires reverse_offload'</source>
          <target>device clause with ancestor device-modifier used without specifying 'requires reverse_offload'</target>
        </segment>
      </unit>
      <unit id="4469" name="err_omp_device_type_mismatch">
        <segment>
          <source>'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration</source>
          <target>'device_type({$arg0})' does not match previously specified 'device_type({$arg1})' for the same declaration</target>
        </segment>
      </unit>
      <unit id="4470" name="err_omp_directive_before_requires">
        <segment>
          <source>'%0' region encountered before requires directive with '%1' clause</source>
          <target>'{$arg0}' region encountered before requires directive with '{$arg1}' clause</target>
        </segment>
      </unit>
      <unit id="4471" name="err_omp_dispatch_statement_call">
        <segment>
          <source>statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one</source>
          <target>statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one</target>
        </segment>
      </unit>
      <unit id="4472" name="err_omp_duplicate_map_type_modifier">
        <segment>
          <source>same map type modifier has been specified more than once</source>
          <target>same map type modifier has been specified more than once</target>
        </segment>
      </unit>
      <unit id="4473" name="err_omp_duplicate_motion_modifier">
        <segment>
          <source>same motion modifier has been specified more than once</source>
          <target>same motion modifier has been specified more than once</target>
        </segment>
      </unit>
      <unit id="4474" name="err_omp_expected_access_to_data_field">
        <segment>
          <source>expected access to data field</source>
          <target>expected access to data field</target>
        </segment>
      </unit>
      <unit id="4475" name="err_omp_expected_addressable_lvalue_or_array_item">
        <segment>
          <source>expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1</source>
          <target>expected addressable lvalue expression, array element{$arg0 :select s0=| or array section| s1=|, array section or array shaping expression|}{$arg1 :select s0=|| s1=| of non 'omp_depend_t' type|}</target>
        </segment>
      </unit>
      <unit id="4476" name="err_omp_expected_array_alloctraits">
        <segment>
          <source>expected constant sized array of 'omp_alloctrait_t' elements, not %0</source>
          <target>expected constant sized array of 'omp_alloctrait_t' elements, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4477" name="err_omp_expected_base_var_name">
        <segment>
          <source>expected variable name as a base of the array %select{subscript|section}0</source>
          <target>expected variable name as a base of the array {$arg0 :select s0=|subscript| s1=|section|}</target>
        </segment>
      </unit>
      <unit id="4478" name="err_omp_expected_int_param">
        <segment>
          <source>expected a reference to an integer-typed parameter</source>
          <target>expected a reference to an integer-typed parameter</target>
        </segment>
      </unit>
      <unit id="4479" name="err_omp_expected_named_var_member_or_array_expression">
        <segment>
          <source>expected expression containing only member accesses and/or array sections based on named variables</source>
          <target>expected expression containing only member accesses and/or array sections based on named variables</target>
        </segment>
      </unit>
      <unit id="4480" name="err_omp_expected_omp_depend_t_lvalue">
        <segment>
          <source>expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0</source>
          <target>expected lvalue expression{$arg0 :select s0=| of 'omp_depend_t' type, not {$arg1}| s1=||}</target>
        </segment>
      </unit>
      <unit id="4481" name="err_omp_expected_predefined_allocator">
        <segment>
          <source>expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'</source>
          <target>expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'</target>
        </segment>
      </unit>
      <unit id="4482" name="err_omp_expected_private_copy_for_allocate">
        <segment>
          <source>the referenced item is not found in any private clause on the same directive</source>
          <target>the referenced item is not found in any private clause on the same directive</target>
        </segment>
      </unit>
      <unit id="4483" name="err_omp_expected_uniform_param">
        <segment>
          <source>expected a reference to a parameter specified in a 'uniform' clause</source>
          <target>expected a reference to a parameter specified in a 'uniform' clause</target>
        </segment>
      </unit>
      <unit id="4484" name="err_omp_expected_var_arg">
        <segment>
          <source>%0 is not a global variable, static local variable or static data member</source>
          <target>{$arg0} is not a global variable, static local variable or static data member</target>
        </segment>
      </unit>
      <unit id="4485" name="err_omp_expected_var_arg_suggest">
        <segment>
          <source>%0 is not a global variable, static local variable or static data member; did you mean %1</source>
          <target>{$arg0} is not a global variable, static local variable or static data member; did you mean {$arg1}</target>
        </segment>
      </unit>
      <unit id="4486" name="err_omp_expected_var_name_member_expr">
        <segment>
          <source>expected variable name%select{| or data member of current class}0</source>
          <target>expected variable name{$arg0 :select s0=|| s1=| or data member of current class|}</target>
        </segment>
      </unit>
      <unit id="4487" name="err_omp_expected_var_name_member_expr_or_array_item">
        <segment>
          <source>expected variable name%select{|, data member of current class}0, array element or array section</source>
          <target>expected variable name{$arg0 :select s0=|| s1=|, data member of current class|}, array element or array section</target>
        </segment>
      </unit>
      <unit id="4488" name="err_omp_expected_var_name_member_expr_with_type">
        <segment>
          <source>expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'</source>
          <target>expected variable{$arg0 :select s0=|| s1=| or static data member| s2=|, static data member, or non-static data member of current class|} of type '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4489" name="err_omp_explicit_conversion">
        <segment>
          <source>expression requires explicit conversion from %0 to %1</source>
          <target>expression requires explicit conversion from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="4490" name="err_omp_firstprivate_incomplete_type">
        <segment>
          <source>a firstprivate variable with incomplete type %0</source>
          <target>a firstprivate variable with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4491" name="err_omp_flush_order_clause_and_list">
        <segment>
          <source>'flush' directive with memory order clause '%0' cannot have the list</source>
          <target>'flush' directive with memory order clause '{$arg0}' cannot have the list</target>
        </segment>
      </unit>
      <unit id="4492" name="err_omp_function_expected">
        <segment>
          <source>'#pragma omp declare %select{simd|variant}0' can only be applied to functions</source>
          <target>'#pragma omp declare {$arg0 :select s0=|simd| s1=|variant|}' can only be applied to functions</target>
        </segment>
      </unit>
      <unit id="4493" name="err_omp_function_in_link_clause">
        <segment>
          <source>function name is not allowed in 'link' clause</source>
          <target>function name is not allowed in 'link' clause</target>
        </segment>
      </unit>
      <unit id="4494" name="err_omp_global_var_arg">
        <segment>
          <source>arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1</source>
          <target>arguments of '#pragma omp {$arg0}' must have {$arg1 :select s0=|global storage| s1=|static storage duration|}</target>
        </segment>
      </unit>
      <unit id="4495" name="err_omp_hint_clause_no_name">
        <segment>
          <source>the name of the construct must be specified in presence of 'hint' clause</source>
          <target>the name of the construct must be specified in presence of 'hint' clause</target>
        </segment>
      </unit>
      <unit id="4496" name="err_omp_implied_type_not_found">
        <segment>
          <source>'%0' type not found; include &lt;omp.h&gt;</source>
          <target>'{$arg0}' type not found; include &lt;omp.h&gt;</target>
        </segment>
      </unit>
      <unit id="4497" name="err_omp_inclusive_exclusive_not_reduction">
        <segment>
          <source>the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive</source>
          <target>the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive</target>
        </segment>
      </unit>
      <unit id="4498" name="err_omp_incomplete_type">
        <segment>
          <source>expression has incomplete class type %0</source>
          <target>expression has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4499" name="err_omp_inscan_reduction_expected">
        <segment>
          <source>expected 'reduction' clause with the 'inscan' modifier</source>
          <target>expected 'reduction' clause with the 'inscan' modifier</target>
        </segment>
      </unit>
      <unit id="4500" name="err_omp_instantiation_not_supported">
        <segment>
          <source>instantiation of '%0' not supported yet</source>
          <target>instantiation of '{$arg0}' not supported yet</target>
        </segment>
      </unit>
      <unit id="4501" name="err_omp_interchange_permutation_value_range">
        <segment>
          <source>permutation index must be at least 1 and at most %0</source>
          <target>permutation index must be at least 1 and at most {$arg0}</target>
        </segment>
      </unit>
      <unit id="4502" name="err_omp_interchange_permutation_value_repeated">
        <segment>
          <source>index %0 must appear exactly once in the permutation clause</source>
          <target>index {$arg0} must appear exactly once in the permutation clause</target>
        </segment>
      </unit>
      <unit id="4503" name="err_omp_interop_bad_depend_clause">
        <segment>
          <source>'depend' clause requires the 'targetsync' interop type</source>
          <target>'depend' clause requires the 'targetsync' interop type</target>
        </segment>
      </unit>
      <unit id="4504" name="err_omp_interop_prefer_type">
        <segment>
          <source>prefer_list item must be a string literal or constant integral expression</source>
          <target>prefer_list item must be a string literal or constant integral expression</target>
        </segment>
      </unit>
      <unit id="4505" name="err_omp_interop_type_not_found">
        <segment>
          <source>'omp_interop_t' must be defined when 'append_args' clause is used; include &lt;omp.h&gt;</source>
          <target>'omp_interop_t' must be defined when 'append_args' clause is used; include &lt;omp.h&gt;</target>
        </segment>
      </unit>
      <unit id="4506" name="err_omp_interop_var_multiple_actions">
        <segment>
          <source>interop variable %0 used in multiple action clauses</source>
          <target>interop variable {$arg0} used in multiple action clauses</target>
        </segment>
      </unit>
      <unit id="4507" name="err_omp_interop_variable_expected">
        <segment>
          <source>expected%select{| non-const}0 variable of type 'omp_interop_t'</source>
          <target>expected{$arg0 :select s0=|| s1=| non-const|} variable of type 'omp_interop_t'</target>
        </segment>
      </unit>
      <unit id="4508" name="err_omp_interop_variable_wrong_type">
        <segment>
          <source>interop variable must be of type 'omp_interop_t'</source>
          <target>interop variable must be of type 'omp_interop_t'</target>
        </segment>
      </unit>
      <unit id="4509" name="err_omp_invalid_map_this_expr">
        <segment>
          <source>invalid 'this' expression on 'map' clause</source>
          <target>invalid 'this' expression on 'map' clause</target>
        </segment>
      </unit>
      <unit id="4510" name="err_omp_invalid_map_type_for_directive">
        <segment>
          <source>%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'</source>
          <target>{$arg0 :select s0=|map type '{$arg1}' is not allowed| s1=|map type must be specified|} for '#pragma omp {$arg2}'</target>
        </segment>
      </unit>
      <unit id="4511" name="err_omp_invalid_map_type_modifier_for_directive">
        <segment>
          <source>map type modifier '%0' is not allowed for '#pragma omp %1'</source>
          <target>map type modifier '{$arg0}' is not allowed for '#pragma omp {$arg1}'</target>
        </segment>
      </unit>
      <unit id="4512" name="err_omp_invalid_mapper">
        <segment>
          <source>cannot find a valid user-defined mapper for type %0 with name %1</source>
          <target>cannot find a valid user-defined mapper for type {$arg0} with name {$arg1}</target>
        </segment>
      </unit>
      <unit id="4513" name="err_omp_invalid_scope">
        <segment>
          <source>'#pragma omp %0' directive must appear only in file scope</source>
          <target>'#pragma omp {$arg0}' directive must appear only in file scope</target>
        </segment>
      </unit>
      <unit id="4514" name="err_omp_invalid_target_decl">
        <segment>
          <source>%0 used in declare target directive is not a variable or a function name</source>
          <target>{$arg0} used in declare target directive is not a variable or a function name</target>
        </segment>
      </unit>
      <unit id="4515" name="err_omp_invariant_dependency">
        <segment>
          <source>expected loop invariant expression</source>
          <target>expected loop invariant expression</target>
        </segment>
      </unit>
      <unit id="4516" name="err_omp_invariant_or_linear_dependency">
        <segment>
          <source>expected loop invariant expression or '&lt;invariant1&gt; * %0 + &lt;invariant2&gt;' kind of expression</source>
          <target>expected loop invariant expression or '&lt;invariant1&gt; * {$arg0} + &lt;invariant2&gt;' kind of expression</target>
        </segment>
      </unit>
      <unit id="4517" name="err_omp_iterator_not_integral_or_pointer">
        <segment>
          <source>expected integral or pointer type as the iterator-type, not %0</source>
          <target>expected integral or pointer type as the iterator-type, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4518" name="err_omp_iterator_step_constant_zero">
        <segment>
          <source>iterator step expression %0 evaluates to 0</source>
          <target>iterator step expression {$arg0} evaluates to 0</target>
        </segment>
      </unit>
      <unit id="4519" name="err_omp_iterator_step_not_integral">
        <segment>
          <source>iterator step expression %0 is not the integral expression</source>
          <target>iterator step expression {$arg0} is not the integral expression</target>
        </segment>
      </unit>
      <unit id="4520" name="err_omp_iterator_use">
        <segment>
          <source>OpenMP iterator is not allowed here</source>
          <target>OpenMP iterator is not allowed here</target>
        </segment>
      </unit>
      <unit id="4521" name="err_omp_lambda_capture_in_declare_target_not_to">
        <segment>
          <source>variable captured in declare target region must appear in a to clause</source>
          <target>variable captured in declare target region must appear in a to clause</target>
        </segment>
      </unit>
      <unit id="4522" name="err_omp_large_expression_in_clause">
        <segment>
          <source>argument to '%0' clause requires a value that can be represented by a 64-bit</source>
          <target>argument to '{$arg0}' clause requires a value that can be represented by a 64-bit</target>
        </segment>
      </unit>
      <unit id="4523" name="err_omp_lastprivate_conditional_non_scalar">
        <segment>
          <source>expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier</source>
          <target>expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier</target>
        </segment>
      </unit>
      <unit id="4524" name="err_omp_lastprivate_incomplete_type">
        <segment>
          <source>a lastprivate variable with incomplete type %0</source>
          <target>a lastprivate variable with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4525" name="err_omp_lastprivate_loop_var_non_loop_iteration">
        <segment>
          <source>only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives</source>
          <target>only loop iteration variables are allowed in 'lastprivate' clause in 'omp {$arg0}' directives</target>
        </segment>
      </unit>
      <unit id="4526" name="err_omp_linear_distribute_var_non_loop_iteration">
        <segment>
          <source>only loop iteration variables are allowed in 'linear' clause in distribute directives</source>
          <target>only loop iteration variables are allowed in 'linear' clause in distribute directives</target>
        </segment>
      </unit>
      <unit id="4527" name="err_omp_linear_expected_int_or_ptr">
        <segment>
          <source>argument of a linear clause should be of integral or pointer type, not %0</source>
          <target>argument of a linear clause should be of integral or pointer type, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4528" name="err_omp_linear_incomplete_type">
        <segment>
          <source>a linear variable with incomplete type %0</source>
          <target>a linear variable with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4529" name="err_omp_linear_ordered">
        <segment>
          <source>'linear' clause cannot be specified along with 'ordered' clause with a parameter</source>
          <target>'linear' clause cannot be specified along with 'ordered' clause with a parameter</target>
        </segment>
      </unit>
      <unit id="4530" name="err_omp_local_var_in_threadprivate_init">
        <segment>
          <source>variable with local storage in initial value of threadprivate variable</source>
          <target>variable with local storage in initial value of threadprivate variable</target>
        </segment>
      </unit>
      <unit id="4531" name="err_omp_loop_bad_collapse_var">
        <segment>
          <source>cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement</source>
          <target>cannot use variable {$arg1} in collapsed imperfectly-nested loop {$arg0 :select s0=|init| s1=|condition| s2=|increment|} statement</target>
        </segment>
      </unit>
      <unit id="4532" name="err_omp_loop_cannot_use_stmt">
        <segment>
          <source>'%0' statement cannot be used in OpenMP for loop</source>
          <target>'{$arg0}' statement cannot be used in OpenMP for loop</target>
        </segment>
      </unit>
      <unit id="4533" name="err_omp_loop_diff_cxx">
        <segment>
          <source>could not calculate number of iterations calling 'operator-' with upper and lower loop bounds</source>
          <target>could not calculate number of iterations calling 'operator-' with upper and lower loop bounds</target>
        </segment>
      </unit>
      <unit id="4534" name="err_omp_loop_incr_not_compatible">
        <segment>
          <source>increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop</source>
          <target>increment expression must cause {$arg0} to {$arg1 :select s0=|decrease| s1=|increase|} on each iteration of OpenMP for loop</target>
        </segment>
      </unit>
      <unit id="4535" name="err_omp_loop_not_canonical_cond">
        <segment>
          <source>condition of OpenMP for loop must be a relational comparison ('&lt;', '&lt;=', '&gt;', %select{or '&gt;='|'&gt;=', or '!='}0) of loop variable %1</source>
          <target>condition of OpenMP for loop must be a relational comparison ('&lt;', '&lt;=', '&gt;', {$arg0 :select s0=|or '&gt;='| s1=|'&gt;=', or '!='|}) of loop variable {$arg1}</target>
        </segment>
      </unit>
      <unit id="4536" name="err_omp_loop_not_canonical_incr">
        <segment>
          <source>increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0</source>
          <target>increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable {$arg0}</target>
        </segment>
      </unit>
      <unit id="4537" name="err_omp_loop_not_canonical_init">
        <segment>
          <source>initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')</source>
          <target>initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')</target>
        </segment>
      </unit>
      <unit id="4538" name="err_omp_loop_reduction_clause">
        <segment>
          <source>'reduction' clause not allowed with '#pragma omp loop bind(teams)'</source>
          <target>'reduction' clause not allowed with '#pragma omp loop bind(teams)'</target>
        </segment>
      </unit>
      <unit id="4539" name="err_omp_loop_var_dsa">
        <segment>
          <source>loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2</source>
          <target>loop iteration variable in the associated loop of 'omp {$arg1}' directive may not be {$arg0}, predetermined as {$arg2}</target>
        </segment>
      </unit>
      <unit id="4540" name="err_omp_loop_variable_type">
        <segment>
          <source>variable must be of integer or %select{pointer|random access iterator}0 type</source>
          <target>variable must be of integer or {$arg0 :select s0=|pointer| s1=|random access iterator|} type</target>
        </segment>
      </unit>
      <unit id="4541" name="err_omp_map_modifier_not_iterator">
        <segment>
          <source>expected iterator specification as map modifier</source>
          <target>expected iterator specification as map modifier</target>
        </segment>
      </unit>
      <unit id="4542" name="err_omp_map_shared_storage">
        <segment>
          <source>variable already marked as mapped in current construct</source>
          <target>variable already marked as mapped in current construct</target>
        </segment>
      </unit>
      <unit id="4543" name="err_omp_mapper_wrong_type">
        <segment>
          <source>mapper type must be of struct, union or class type</source>
          <target>mapper type must be of struct, union or class type</target>
        </segment>
      </unit>
      <unit id="4544" name="err_omp_multi_expr_not_allowed">
        <segment>
          <source>only one expression allowed in '%0' clause</source>
          <target>only one expression allowed in '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="4545" name="err_omp_multiple_array_items_in_map_clause">
        <segment>
          <source>multiple array elements associated with the same variable are not allowed in map clauses of the same construct</source>
          <target>multiple array elements associated with the same variable are not allowed in map clauses of the same construct</target>
        </segment>
      </unit>
      <unit id="4546" name="err_omp_negative_expression_in_clause">
        <segment>
          <source>argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value</source>
          <target>argument to '{$arg0}' clause must be a {$arg1 :select s0=|non-negative| s1=|strictly positive|} integer value</target>
        </segment>
      </unit>
      <unit id="4547" name="err_omp_no_clause_for_directive">
        <segment>
          <source>expected at least one %0 clause for '#pragma omp %1'</source>
          <target>expected at least one {$arg0} clause for '#pragma omp {$arg1}'</target>
        </segment>
      </unit>
      <unit id="4548" name="err_omp_no_dsa_for_variable">
        <segment>
          <source>variable %0 must have explicitly specified data sharing attributes</source>
          <target>variable {$arg0} must have explicitly specified data sharing attributes</target>
        </segment>
      </unit>
      <unit id="4549" name="err_omp_no_more_if_clause">
        <segment>
          <source>no more 'if' clause is allowed</source>
          <target>no more 'if' clause is allowed</target>
        </segment>
      </unit>
      <unit id="4550" name="err_omp_non_lvalue_in_map_or_motion_clauses">
        <segment>
          <source>expected addressable lvalue in '%0' clause</source>
          <target>expected addressable lvalue in '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="4551" name="err_omp_non_pointer_type_array_shaping_base">
        <segment>
          <source>expected expression with a pointer to a complete type as a base of an array shaping operation</source>
          <target>expected expression with a pointer to a complete type as a base of an array shaping operation</target>
        </segment>
      </unit>
      <unit id="4552" name="err_omp_nonpredefined_allocator_without_traits">
        <segment>
          <source>non-predefined allocator must have traits specified</source>
          <target>non-predefined allocator must have traits specified</target>
        </segment>
      </unit>
      <unit id="4553" name="err_omp_not_for">
        <segment>
          <source>%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0</source>
          <target>%select{statement after '#pragma omp {$arg1}' must be a for loop|expected {$arg2} for loops after '#pragma omp {$arg1}'{$arg0 :select s0=|| s1=|, but found only {$arg4}}3|}</target>
        </segment>
      </unit>
      <unit id="4554" name="err_omp_not_integral">
        <segment>
          <source>expression must have integral or unscoped enumeration type, not %0</source>
          <target>expression must have integral or unscoped enumeration type, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4555" name="err_omp_not_resolved_reduction_identifier">
        <segment>
          <source>unable to resolve declare reduction construct for type %0</source>
          <target>unable to resolve declare reduction construct for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4556" name="err_omp_nowait_clause_without_depend">
        <segment>
          <source>directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause</source>
          <target>directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause</target>
        </segment>
      </unit>
      <unit id="4557" name="err_omp_once_referenced">
        <segment>
          <source>variable can appear only once in OpenMP '%0' clause</source>
          <target>variable can appear only once in OpenMP '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="4558" name="err_omp_once_referenced_in_target_update">
        <segment>
          <source>variable can appear only once in OpenMP 'target update' construct</source>
          <target>variable can appear only once in OpenMP 'target update' construct</target>
        </segment>
      </unit>
      <unit id="4559" name="err_omp_one_defaultmap_each_category">
        <segment>
          <source>at most one defaultmap clause for each variable-category can appear on the directive</source>
          <target>at most one defaultmap clause for each variable-category can appear on the directive</target>
        </segment>
      </unit>
      <unit id="4560" name="err_omp_ordered_directive_with_param">
        <segment>
          <source>'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter</source>
          <target>'ordered' directive {$arg0 :select s0=|without any clauses| s1=|with 'threads' clause|} cannot be closely nested inside ordered region with specified parameter</target>
        </segment>
      </unit>
      <unit id="4561" name="err_omp_ordered_directive_without_param">
        <segment>
          <source>'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter</source>
          <target>'ordered' directive with '{$arg0}' clause cannot be closely nested inside ordered region without specified parameter</target>
        </segment>
      </unit>
      <unit id="4562" name="err_omp_ordered_simd">
        <segment>
          <source state="initial">'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive</source>
          <target>'ordered' clause with a parameter cannot be specified in '#pragma omp {$arg0}' directive</target>
        </segment>
      </unit>
      <unit id="4563" name="err_omp_original_storage_is_shared_and_does_not_contain">
        <segment>
          <source>original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage</source>
          <target>original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage</target>
        </segment>
      </unit>
      <unit id="4564" name="err_omp_orphaned_device_directive">
        <segment>
          <source>orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?</source>
          <target>orphaned 'omp {$arg0}' directives are prohibited; perhaps you forget to enclose the directive into a {$arg1 :select s0=|| s1=|| s2=|| s3=|target | s4=|teams| s5=|for, simd, for simd, parallel for, or parallel for simd |}region?</target>
        </segment>
      </unit>
      <unit id="4565" name="err_omp_orphaned_section_directive">
        <segment>
          <source>%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0</source>
          <target>{$arg0 :select s0=|orphaned 'omp section' directives are prohibited, it| s1=|'omp section' directive|} must be closely nested to a sections region{$arg0 :select s0=|| s1=|, not a {$arg1} region|}</target>
        </segment>
      </unit>
      <unit id="4566" name="err_omp_parallel_reduction_in_task_firstprivate">
        <segment>
          <source>argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct</source>
          <target>argument of a reduction clause of a {$arg0} construct must not appear in a firstprivate clause on a task construct</target>
        </segment>
      </unit>
      <unit id="4567" name="err_omp_param_or_this_in_clause">
        <segment>
          <source>expected reference to one of the parameters of function %0%select{| or 'this'}1</source>
          <target>expected reference to one of the parameters of function {$arg0}{$arg1 :select s0=|| s1=| or 'this'|}</target>
        </segment>
      </unit>
      <unit id="4568" name="err_omp_parent_cancel_region_nowait">
        <segment>
          <source>parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait</source>
          <target>parent region for 'omp {$arg0 :select s0=|cancellation point| s1=|cancel|}' construct cannot be nowait</target>
        </segment>
      </unit>
      <unit id="4569" name="err_omp_parent_cancel_region_ordered">
        <segment>
          <source>parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered</source>
          <target>parent region for 'omp {$arg0 :select s0=|cancellation point| s1=|cancel|}' construct cannot be ordered</target>
        </segment>
      </unit>
      <unit id="4570" name="err_omp_pointer_mapped_along_with_derived_section">
        <segment>
          <source>pointer cannot be mapped along with a section derived from itself</source>
          <target>pointer cannot be mapped along with a section derived from itself</target>
        </segment>
      </unit>
      <unit id="4571" name="err_omp_predefined_allocator_with_traits">
        <segment>
          <source>predefined allocator cannot have traits specified</source>
          <target>predefined allocator cannot have traits specified</target>
        </segment>
      </unit>
      <unit id="4572" name="err_omp_private_incomplete_type">
        <segment>
          <source>a private variable with incomplete type %0</source>
          <target>a private variable with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4573" name="err_omp_prohibited_region">
        <segment>
          <source>region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2</source>
          <target>region cannot be{$arg0 :select s0=|| s1=| closely|} nested inside '{$arg1}' region{$arg2 :select s0=|| s1=|; perhaps you forget to enclose 'omp {$arg3}' directive into a parallel region?| s2=|; perhaps you forget to enclose 'omp {$arg3}' directive into a for or a parallel for region with 'ordered' clause?| s3=|; perhaps you forget to enclose 'omp {$arg3}' directive into a target region?| s4=|; perhaps you forget to enclose 'omp {$arg3}' directive into a teams region?| s5=|; perhaps you forget to enclose 'omp {$arg3}' directive into a for, simd, for simd, parallel for, or parallel for simd region?|}</target>
        </segment>
      </unit>
      <unit id="4574" name="err_omp_prohibited_region_atomic">
        <segment>
          <source>OpenMP constructs may not be nested inside an atomic region</source>
          <target>OpenMP constructs may not be nested inside an atomic region</target>
        </segment>
      </unit>
      <unit id="4575" name="err_omp_prohibited_region_critical_same_name">
        <segment>
          <source>cannot nest 'critical' regions having the same name %0</source>
          <target>cannot nest 'critical' regions having the same name {$arg0}</target>
        </segment>
      </unit>
      <unit id="4576" name="err_omp_prohibited_region_order">
        <segment>
          <source>construct '%0' not allowed in a region associated with a directive with 'order' clause</source>
          <target>construct '{$arg0}' not allowed in a region associated with a directive with 'order' clause</target>
        </segment>
      </unit>
      <unit id="4577" name="err_omp_prohibited_region_simd">
        <segment>
          <source>OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0</source>
          <target>OpenMP constructs may not be nested inside a simd region{$arg0 :select s0=|| s1=| except for ordered simd, simd, scan, or atomic directive|}</target>
        </segment>
      </unit>
      <unit id="4578" name="err_omp_reduction_id_not_compatible">
        <segment>
          <source>list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value</source>
          <target>list item of type {$arg0} is not valid for specified reduction operation: unable to provide default initialization value</target>
        </segment>
      </unit>
      <unit id="4579" name="err_omp_reduction_identifier_mismatch">
        <segment>
          <source>in_reduction variable must have the same reduction operation as in a task_reduction clause</source>
          <target>in_reduction variable must have the same reduction operation as in a task_reduction clause</target>
        </segment>
      </unit>
      <unit id="4580" name="err_omp_reduction_in_task">
        <segment>
          <source>reduction variables may not be accessed in an explicit task</source>
          <target>reduction variables may not be accessed in an explicit task</target>
        </segment>
      </unit>
      <unit id="4581" name="err_omp_reduction_incomplete_type">
        <segment>
          <source>a reduction list item with incomplete type %0</source>
          <target>a reduction list item with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4582" name="err_omp_reduction_non_addressable_expression">
        <segment>
          <source>expected addressable reduction item for the task-based directives</source>
          <target>expected addressable reduction item for the task-based directives</target>
        </segment>
      </unit>
      <unit id="4583" name="err_omp_reduction_not_inclusive_exclusive">
        <segment>
          <source>the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive</source>
          <target>the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive</target>
        </segment>
      </unit>
      <unit id="4584" name="err_omp_reduction_ref_type_arg">
        <segment>
          <source>argument of OpenMP clause '%0' must reference the same object in all threads</source>
          <target>argument of OpenMP clause '{$arg0}' must reference the same object in all threads</target>
        </segment>
      </unit>
      <unit id="4585" name="err_omp_reduction_task_not_parallel_or_worksharing">
        <segment>
          <source>'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs</source>
          <target>'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs</target>
        </segment>
      </unit>
      <unit id="4586" name="err_omp_reduction_vla_unsupported">
        <segment>
          <source>cannot generate code for reduction on %select{|array section, which requires a }0variable length array</source>
          <target>cannot generate code for reduction on {$arg0 :select s0=|| s1=|array section, which requires a |}variable length array</target>
        </segment>
      </unit>
      <unit id="4587" name="err_omp_reduction_with_nogroup">
        <segment>
          <source>'reduction' clause cannot be used with 'nogroup' clause</source>
          <target>'reduction' clause cannot be used with 'nogroup' clause</target>
        </segment>
      </unit>
      <unit id="4588" name="err_omp_reduction_wrong_type">
        <segment>
          <source>reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type</source>
          <target>reduction type cannot be {$arg0 :select s0=|qualified with 'const', 'volatile' or 'restrict'| s1=|a function| s2=|a reference| s3=|an array|} type</target>
        </segment>
      </unit>
      <unit id="4589" name="err_omp_ref_type_arg">
        <segment>
          <source>arguments of '#pragma omp %0' cannot be of reference type %1</source>
          <target>arguments of '#pragma omp {$arg0}' cannot be of reference type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4590" name="err_omp_region_not_file_context">
        <segment>
          <source>directive must be at file or namespace scope</source>
          <target>directive must be at file or namespace scope</target>
        </segment>
      </unit>
      <unit id="4591" name="err_omp_required_access">
        <segment>
          <source>%0 variable must be %1</source>
          <target>{$arg0} variable must be {$arg1}</target>
        </segment>
      </unit>
      <unit id="4592" name="err_omp_requires_clause_redeclaration">
        <segment>
          <source>only one %0 clause can appear on a requires directive in a single translation unit</source>
          <target>only one {$arg0} clause can appear on a requires directive in a single translation unit</target>
        </segment>
      </unit>
      <unit id="4593" name="err_omp_same_pointer_dereferenced">
        <segment>
          <source>same pointer dereferenced in multiple different ways in map clause expressions</source>
          <target>same pointer dereferenced in multiple different ways in map clause expressions</target>
        </segment>
      </unit>
      <unit id="4594" name="err_omp_scan_single_clause_expected">
        <segment>
          <source>exactly one of 'inclusive' or 'exclusive' clauses is expected</source>
          <target>exactly one of 'inclusive' or 'exclusive' clauses is expected</target>
        </segment>
      </unit>
      <unit id="4595" name="err_omp_schedule_nonmonotonic_static">
        <segment>
          <source>'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind</source>
          <target>'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind</target>
        </segment>
      </unit>
      <unit id="4596" name="err_omp_section_function_type">
        <segment>
          <source>section of pointer to function type %0</source>
          <target>section of pointer to function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4597" name="err_omp_section_incomplete_type">
        <segment>
          <source>section of pointer to incomplete type %0</source>
          <target>section of pointer to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4598" name="err_omp_section_length_negative">
        <segment>
          <source>section length is evaluated to a negative value %0</source>
          <target>section length is evaluated to a negative value {$arg0}</target>
        </segment>
      </unit>
      <unit id="4599" name="err_omp_section_length_undefined">
        <segment>
          <source>section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0</source>
          <target>section length is unspecified and cannot be inferred because subscripted value is {$arg0 :select s0=|not an array| s1=|an array of unknown bound|}</target>
        </segment>
      </unit>
      <unit id="4600" name="err_omp_section_not_subset_of_array">
        <segment>
          <source>array section must be a subset of the original array</source>
          <target>array section must be a subset of the original array</target>
        </segment>
      </unit>
      <unit id="4601" name="err_omp_section_stride_non_positive">
        <segment>
          <source>section stride is evaluated to a non-positive value %0</source>
          <target>section stride is evaluated to a non-positive value {$arg0}</target>
        </segment>
      </unit>
      <unit id="4602" name="err_omp_sections_not_compound_stmt">
        <segment>
          <source>the statement for '#pragma omp %0' must be a compound statement</source>
          <target>the statement for '#pragma omp {$arg0}' must be a compound statement</target>
        </segment>
      </unit>
      <unit id="4603" name="err_omp_sections_substmt_not_section">
        <segment>
          <source>statement in 'omp %0' directive must be enclosed into a section region</source>
          <target>statement in 'omp {$arg0}' directive must be enclosed into a section region</target>
        </segment>
      </unit>
      <unit id="4604" name="err_omp_several_directives_in_region">
        <segment>
          <source>exactly one '%0' directive must appear in the loop body of an enclosing directive</source>
          <target>exactly one '{$arg0}' directive must appear in the loop body of an enclosing directive</target>
        </segment>
      </unit>
      <unit id="4605" name="err_omp_several_mem_order_clauses">
        <segment>
          <source state="initial">directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause</source>
          <target>directive '#pragma omp {$arg0}' cannot contain more than one 'seq_cst',{$arg1 :select s0=| 'relaxed',| s1=||} 'acq_rel', 'acquire' or 'release' clause</target>
        </segment>
      </unit>
      <unit id="4606" name="err_omp_shaping_dimension_not_positive">
        <segment>
          <source>array shaping dimension is evaluated to a non-positive value %0</source>
          <target>array shaping dimension is evaluated to a non-positive value {$arg0}</target>
        </segment>
      </unit>
      <unit id="4607" name="err_omp_simd_region_cannot_use_stmt">
        <segment>
          <source>'%0' statement cannot be used in OpenMP simd region</source>
          <target>'{$arg0}' statement cannot be used in OpenMP simd region</target>
        </segment>
      </unit>
      <unit id="4608" name="err_omp_simple_clause_incompatible_with_ordered">
        <segment>
          <source>'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified</source>
          <target>'{$arg0}' clause with '{$arg1}' modifier cannot be specified if an 'ordered' clause is specified</target>
        </segment>
      </unit>
      <unit id="4609" name="err_omp_single_copyprivate_with_nowait">
        <segment>
          <source>the 'copyprivate' clause must not be used with the 'nowait' clause</source>
          <target>the 'copyprivate' clause must not be used with the 'nowait' clause</target>
        </segment>
      </unit>
      <unit id="4610" name="err_omp_single_decl_in_declare_simd_variant">
        <segment>
          <source>single declaration is expected after 'declare %select{simd|variant}0' directive</source>
          <target>single declaration is expected after 'declare {$arg0 :select s0=|simd| s1=|variant|}' directive</target>
        </segment>
      </unit>
      <unit id="4611" name="err_omp_sink_and_source_not_allowed">
        <segment>
          <source>'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1</source>
          <target>'{$arg0}({$arg1 :select s0=|source| s1=|sink:vec|})' clause{$arg1 :select s0=|| s1=|s|} cannot be mixed with '{$arg0}({$arg1 :select s0=|sink:vec| s1=|source|})' clause{$arg1 :select s0=|s| s1=||}</target>
        </segment>
      </unit>
      <unit id="4612" name="err_omp_step_simple_modifier_exclusive">
        <segment>
          <source state="initial">step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier</source>
          <target>step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier</target>
        </segment>
      </unit>
      <unit id="4613" name="err_omp_stmt_depends_on_loop_counter">
        <segment>
          <source>the loop %select{initializer|condition}0 expression depends on the current loop control variable</source>
          <target>the loop {$arg0 :select s0=|initializer| s1=|condition|} expression depends on the current loop control variable</target>
        </segment>
      </unit>
      <unit id="4614" name="err_omp_target_contains_not_only_teams">
        <segment>
          <source>target construct with nested teams region contains statements outside of the teams construct</source>
          <target>target construct with nested teams region contains statements outside of the teams construct</target>
        </segment>
      </unit>
      <unit id="4615" name="err_omp_taskwait_depend_mutexinoutset_not_allowed">
        <segment>
          <source>'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive</source>
          <target>'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive</target>
        </segment>
      </unit>
      <unit id="4616" name="err_omp_threadprivate_in_clause">
        <segment>
          <source>threadprivate variables are not allowed in '%0' clause</source>
          <target>threadprivate variables are not allowed in '{$arg0}' clause</target>
        </segment>
      </unit>
      <unit id="4617" name="err_omp_threadprivate_in_target">
        <segment>
          <source>threadprivate variables cannot be used in target constructs</source>
          <target>threadprivate variables cannot be used in target constructs</target>
        </segment>
      </unit>
      <unit id="4618" name="err_omp_threadprivate_incomplete_type">
        <segment>
          <source>threadprivate variable with incomplete type %0</source>
          <target>threadprivate variable with incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4619" name="err_omp_typecheck_section_not_integer">
        <segment>
          <source>array section %select{lower bound|length}0 is not an integer</source>
          <target>array section {$arg0 :select s0=|lower bound| s1=|length|} is not an integer</target>
        </segment>
      </unit>
      <unit id="4620" name="err_omp_typecheck_section_value">
        <segment>
          <source>subscripted value is not an array or pointer</source>
          <target>subscripted value is not an array or pointer</target>
        </segment>
      </unit>
      <unit id="4621" name="err_omp_typecheck_shaping_not_integer">
        <segment>
          <source>array shaping operation dimension is not an integer</source>
          <target>array shaping operation dimension is not an integer</target>
        </segment>
      </unit>
      <unit id="4622" name="err_omp_unexpected_call_to_omp_runtime_api">
        <segment>
          <source>calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent</source>
          <target>calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent</target>
        </segment>
      </unit>
      <unit id="4623" name="err_omp_unexpected_clause_value">
        <segment>
          <source>expected %0 in OpenMP clause '%1'</source>
          <target>expected {$arg0} in OpenMP clause '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4624" name="err_omp_unexpected_schedule_modifier">
        <segment>
          <source>modifier '%0' cannot be used along with modifier '%1'</source>
          <target>modifier '{$arg0}' cannot be used along with modifier '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4625" name="err_omp_union_type_not_allowed">
        <segment>
          <source>mapping of union members is not allowed</source>
          <target>mapping of union members is not allowed</target>
        </segment>
      </unit>
      <unit id="4626" name="err_omp_unknown_reduction_identifier_prior_omp_6_0">
        <segment>
          <source>incorrect reduction identifier, expected one of '+', '-', '*', '&amp;', '|', '^', '&amp;&amp;', '||', 'min' or 'max' or declare reduction for type %0</source>
          <target>incorrect reduction identifier, expected one of '+', '-', '*', '&amp;', '|', '^', '&amp;&amp;', '||', 'min' or 'max' or declare reduction for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4627" name="err_omp_unknown_reduction_identifier_since_omp_6_0">
        <segment>
          <source>incorrect reduction identifier, expected one of '+', '*', '&amp;', '|', '^', '&amp;&amp;', '||', 'min' or 'max' or declare reduction for type %0</source>
          <target>incorrect reduction identifier, expected one of '+', '*', '&amp;', '|', '^', '&amp;&amp;', '||', 'min' or 'max' or declare reduction for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4628" name="err_omp_unnamed_if_clause">
        <segment>
          <source>expected%select{| one of}0 %1 directive name modifier%select{|s}0</source>
          <target>expected{$arg0 :select s0=|| s1=| one of|} {$arg1} directive name modifier{$arg0 :select s0=|| s1=|s|}</target>
        </segment>
      </unit>
      <unit id="4629" name="err_omp_unroll_full_variable_trip_count">
        <segment>
          <source>loop to be fully unrolled must have a constant trip count</source>
          <target>loop to be fully unrolled must have a constant trip count</target>
        </segment>
      </unit>
      <unit id="4630" name="err_omp_used_in_clause_twice">
        <segment>
          <source>%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause</source>
          <target>{$arg0 :select s0=|a variable| s1=|a parameter| s2=|'this'|} cannot appear in more than one {$arg1} clause</target>
        </segment>
      </unit>
      <unit id="4631" name="err_omp_usedeviceptr_not_a_pointer">
        <segment>
          <source>expected pointer or reference to pointer in 'use_device_ptr' clause</source>
          <target>expected pointer or reference to pointer in 'use_device_ptr' clause</target>
        </segment>
      </unit>
      <unit id="4632" name="err_omp_var_expected">
        <segment>
          <source>expected variable of the '%0' type%select{|, not %2}1</source>
          <target>expected variable of the '{$arg0}' type{$arg1 :select s0=|| s1=|, not {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="4633" name="err_omp_var_scope">
        <segment>
          <source>'#pragma omp %0' must appear in the scope of the %q1 variable declaration</source>
          <target>'#pragma omp {$arg0}' must appear in the scope of the {$arg1 :q} variable declaration</target>
        </segment>
      </unit>
      <unit id="4634" name="err_omp_var_thread_local">
        <segment>
          <source>variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1</source>
          <target>variable {$arg0} cannot be threadprivate because it is {$arg1 :select s0=|thread-local| s1=|a global named register variable|}</target>
        </segment>
      </unit>
      <unit id="4635" name="err_omp_var_used">
        <segment>
          <source>'#pragma omp %0' must precede all references to variable %q1</source>
          <target>'#pragma omp {$arg0}' must precede all references to variable {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="4636" name="err_omp_variable_in_given_clause_and_dsa">
        <segment>
          <source>%0 variable cannot be in a %1 clause in '#pragma omp %2' directive</source>
          <target>{$arg0} variable cannot be in a {$arg1} clause in '#pragma omp {$arg2}' directive</target>
        </segment>
      </unit>
      <unit id="4637" name="err_omp_variably_modified_type_not_supported">
        <segment>
          <source>arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1</source>
          <target>arguments of OpenMP clause '{$arg0}' in '#pragma omp {$arg2}' directive cannot be of variably-modified type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4638" name="err_omp_wrong_cancel_region">
        <segment>
          <source>one of 'for', 'parallel', 'sections' or 'taskgroup' is expected</source>
          <target>one of 'for', 'parallel', 'sections' or 'taskgroup' is expected</target>
        </segment>
      </unit>
      <unit id="4639" name="err_omp_wrong_dependency_iterator_type">
        <segment>
          <source>expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests</source>
          <target>expected an integer or a pointer type of the outer loop counter '{$arg0}' for non-rectangular nests</target>
        </segment>
      </unit>
      <unit id="4640" name="err_omp_wrong_device_function_call">
        <segment>
          <source>function with 'device_type(%0)' is not available on %select{device|host}1</source>
          <target>function with 'device_type({$arg0})' is not available on {$arg1 :select s0=|device| s1=|host|}</target>
        </segment>
      </unit>
      <unit id="4641" name="err_omp_wrong_dsa">
        <segment>
          <source>%0 variable cannot be %1</source>
          <target>{$arg0} variable cannot be {$arg1}</target>
        </segment>
      </unit>
      <unit id="4642" name="err_omp_wrong_if_directive_name_modifier">
        <segment>
          <source>directive name modifier '%0' is not allowed for '#pragma omp %1'</source>
          <target>directive name modifier '{$arg0}' is not allowed for '#pragma omp {$arg1}'</target>
        </segment>
      </unit>
      <unit id="4643" name="err_omp_wrong_inscan_reduction">
        <segment>
          <source>'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive</source>
          <target>'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive</target>
        </segment>
      </unit>
      <unit id="4644" name="err_omp_wrong_linear_modifier">
        <segment>
          <source>expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0</source>
          <target>expected {$arg0 :select s0=|'val' modifier| s1=|one of 'ref', val' or 'uval' modifiers|}</target>
        </segment>
      </unit>
      <unit id="4645" name="err_omp_wrong_linear_modifier_non_reference">
        <segment>
          <source>variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'</source>
          <target>variable of non-reference type {$arg0} can be used only with 'val' modifier, but used with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4646" name="err_omp_wrong_ordered_loop_count">
        <segment>
          <source>the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause</source>
          <target>the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause</target>
        </segment>
      </unit>
      <unit id="4647" name="err_omp_wrong_simdlen_safelen_values">
        <segment>
          <source>the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter</source>
          <target>the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter</target>
        </segment>
      </unit>
      <unit id="4648" name="err_omp_wrong_var_in_declare_reduction">
        <segment>
          <source>only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression</source>
          <target>only {$arg0 :select s0=|'omp_priv' or 'omp_orig'| s1=|'omp_in' or 'omp_out'|} variables are allowed in {$arg0 :select s0=|initializer| s1=|combiner|} expression</target>
        </segment>
      </unit>
      <unit id="4649" name="err_ompx_bare_no_grid">
        <segment>
          <source>'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses</source>
          <target>'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses</target>
        </segment>
      </unit>
      <unit id="4650" name="err_ompx_more_than_three_expr_not_allowed">
        <segment>
          <source>at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct</source>
          <target>at most three expressions are allowed in '{$arg0}' clause in 'target teams ompx_bare' construct</target>
        </segment>
      </unit>
      <unit id="4651" name="err_only_annotate_after_access_spec">
        <segment>
          <source>access specifier can only have annotation attributes</source>
          <target>access specifier can only have annotation attributes</target>
        </segment>
      </unit>
      <unit id="4652" name="err_only_constructors_take_base_inits">
        <segment>
          <source>only constructors take base initializers</source>
          <target>only constructors take base initializers</target>
        </segment>
      </unit>
      <unit id="4653" name="err_only_enums_have_underlying_types">
        <segment>
          <source>only enumeration types have underlying types</source>
          <target>only enumeration types have underlying types</target>
        </segment>
      </unit>
      <unit id="4654" name="err_opencl_addrspace_scope">
        <segment>
          <source>variables in the %0 address space can only be declared in the outermost scope of a kernel function</source>
          <target>variables in the {$arg0} address space can only be declared in the outermost scope of a kernel function</target>
        </segment>
      </unit>
      <unit id="4655" name="err_opencl_atomic_init">
        <segment>
          <source>atomic variable can be %select{assigned|initialized}0 to a variable only in global address space</source>
          <target>atomic variable can be {$arg0 :select s0=|assigned| s1=|initialized|} to a variable only in global address space</target>
        </segment>
      </unit>
      <unit id="4656" name="err_opencl_bitfields">
        <segment>
          <source>bit-fields are not supported in OpenCL</source>
          <target>bit-fields are not supported in OpenCL</target>
        </segment>
      </unit>
      <unit id="4657" name="err_opencl_block_ref_block">
        <segment>
          <source>cannot refer to a block inside block</source>
          <target>cannot refer to a block inside block</target>
        </segment>
      </unit>
      <unit id="4658" name="err_opencl_block_storage_type">
        <segment>
          <source>the __block storage type is not permitted</source>
          <target>the __block storage type is not permitted</target>
        </segment>
      </unit>
      <unit id="4659" name="err_opencl_builtin_expected_type">
        <segment>
          <source>illegal call to %0, expected %1 argument type</source>
          <target>illegal call to {$arg0}, expected {$arg1} argument type</target>
        </segment>
      </unit>
      <unit id="4660" name="err_opencl_builtin_pipe_arg_num">
        <segment>
          <source>invalid number of arguments to function: %0</source>
          <target>invalid number of arguments to function: {$arg0}</target>
        </segment>
      </unit>
      <unit id="4661" name="err_opencl_builtin_pipe_first_arg">
        <segment>
          <source>first argument to %0 must be a pipe type</source>
          <target>first argument to {$arg0} must be a pipe type</target>
        </segment>
      </unit>
      <unit id="4662" name="err_opencl_builtin_pipe_invalid_access_modifier">
        <segment>
          <source>invalid pipe access modifier (expecting %0)</source>
          <target>invalid pipe access modifier (expecting {$arg0})</target>
        </segment>
      </unit>
      <unit id="4663" name="err_opencl_builtin_pipe_invalid_arg">
        <segment>
          <source>invalid argument type to function %0 (expecting %1 having %2)</source>
          <target>invalid argument type to function {$arg0} (expecting {$arg1} having {$arg2})</target>
        </segment>
      </unit>
      <unit id="4664" name="err_opencl_builtin_to_addr_invalid_arg">
        <segment>
          <source>invalid argument %0 to function: %1, expecting a generic pointer argument</source>
          <target>invalid argument {$arg0} to function: {$arg1}, expecting a generic pointer argument</target>
        </segment>
      </unit>
      <unit id="4665" name="err_opencl_cast_non_zero_to_event_t">
        <segment>
          <source>cannot cast non-zero value '%0' to 'event_t'</source>
          <target>cannot cast non-zero value '{$arg0}' to 'event_t'</target>
        </segment>
      </unit>
      <unit id="4666" name="err_opencl_cast_to_half">
        <segment>
          <source>casting to type %0 is not allowed</source>
          <target>casting to type {$arg0} is not allowed</target>
        </segment>
      </unit>
      <unit id="4667" name="err_opencl_constant_no_init">
        <segment>
          <source>variable in constant address space must be initialized</source>
          <target>variable in constant address space must be initialized</target>
        </segment>
      </unit>
      <unit id="4668" name="err_opencl_enqueue_kernel_blocks_no_args">
        <segment>
          <source>blocks with parameters are not accepted in this prototype of enqueue_kernel call</source>
          <target>blocks with parameters are not accepted in this prototype of enqueue_kernel call</target>
        </segment>
      </unit>
      <unit id="4669" name="err_opencl_enqueue_kernel_blocks_non_local_void_args">
        <segment>
          <source>blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'</source>
          <target>blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'</target>
        </segment>
      </unit>
      <unit id="4670" name="err_opencl_enqueue_kernel_incorrect_args">
        <segment>
          <source>illegal call to enqueue_kernel, incorrect argument types</source>
          <target>illegal call to enqueue_kernel, incorrect argument types</target>
        </segment>
      </unit>
      <unit id="4671" name="err_opencl_enqueue_kernel_invalid_local_size_type">
        <segment>
          <source>illegal call to enqueue_kernel, parameter needs to be specified as integer type</source>
          <target>illegal call to enqueue_kernel, parameter needs to be specified as integer type</target>
        </segment>
      </unit>
      <unit id="4672" name="err_opencl_enqueue_kernel_local_size_args">
        <segment>
          <source>mismatch in number of block parameters and local size arguments passed</source>
          <target>mismatch in number of block parameters and local size arguments passed</target>
        </segment>
      </unit>
      <unit id="4673" name="err_opencl_ext_vector_component_invalid_length">
        <segment>
          <source>vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16</source>
          <target>vector component access has invalid length {$arg0}; supported lengths are: 1,2,3,4,8,16</target>
        </segment>
      </unit>
      <unit id="4674" name="err_opencl_extern_block_declaration">
        <segment>
          <source>invalid block variable declaration - using 'extern' storage class is disallowed</source>
          <target>invalid block variable declaration - using 'extern' storage class is disallowed</target>
        </segment>
      </unit>
      <unit id="4675" name="err_opencl_function_pointer">
        <segment>
          <source>%select{pointers|references}0 to functions are not allowed</source>
          <target>{$arg0 :select s0=|pointers| s1=|references|} to functions are not allowed</target>
        </segment>
      </unit>
      <unit id="4676" name="err_opencl_function_variable">
        <segment>
          <source>%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space</source>
          <target>{$arg0 :select s0=|non-kernel function| s1=|function scope|} variable cannot be declared in {$arg1} address space</target>
        </segment>
      </unit>
      <unit id="4677" name="err_opencl_global_invalid_addr_space">
        <segment>
          <source>%select{program scope|static local|extern}0 variable must reside in %1 address space</source>
          <target>{$arg0 :select s0=|program scope| s1=|static local| s2=|extern|} variable must reside in {$arg1} address space</target>
        </segment>
      </unit>
      <unit id="4678" name="err_opencl_half_declaration">
        <segment>
          <source>declaring variable of type %0 is not allowed</source>
          <target>declaring variable of type {$arg0} is not allowed</target>
        </segment>
      </unit>
      <unit id="4679" name="err_opencl_half_load_store">
        <segment>
          <source>%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead</source>
          <target>{$arg0 :select s0=|loading directly from| s1=|assigning directly to|} pointer to type {$arg1} requires cl_khr_fp16. Use vector data {$arg0 :select s0=|load| s1=|store|} builtin functions instead</target>
        </segment>
      </unit>
      <unit id="4680" name="err_opencl_implicit_vector_conversion">
        <segment>
          <source>implicit conversions between vector types (%0 and %1) are not permitted</source>
          <target>implicit conversions between vector types ({$arg0} and {$arg1}) are not permitted</target>
        </segment>
      </unit>
      <unit id="4681" name="err_opencl_invalid_access_qualifier">
        <segment>
          <source>access qualifier can only be used for pipe and image type</source>
          <target>access qualifier can only be used for pipe and image type</target>
        </segment>
      </unit>
      <unit id="4682" name="err_opencl_invalid_block_declaration">
        <segment>
          <source>invalid block variable declaration - must be %select{const qualified|initialized}0</source>
          <target>invalid block variable declaration - must be {$arg0 :select s0=|const qualified| s1=|initialized|}</target>
        </segment>
      </unit>
      <unit id="4683" name="err_opencl_invalid_param">
        <segment>
          <source>declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1</source>
          <target>declaring function parameter of type {$arg0} is not allowed{$arg1 :select s0=|; did you forget * ?| s1=||}</target>
        </segment>
      </unit>
      <unit id="4684" name="err_opencl_invalid_read_write">
        <segment>
          <source state="initial">access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2</source>
          <target>access qualifier {$arg0} cannot be used for {$arg1} {$arg2 :select s0=|| s1=|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature|}</target>
        </segment>
      </unit>
      <unit id="4685" name="err_opencl_invalid_return">
        <segment>
          <source>declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1</source>
          <target>declaring function return value of type {$arg0} is not allowed {$arg1 :select s0=|; did you forget * ?| s1=||}</target>
        </segment>
      </unit>
      <unit id="4686" name="err_opencl_invalid_type_array">
        <segment>
          <source>array of %0 type is invalid in OpenCL</source>
          <target>array of {$arg0} type is invalid in OpenCL</target>
        </segment>
      </unit>
      <unit id="4687" name="err_opencl_kernel_attr">
        <segment>
          <source>attribute %0 can only be applied to an OpenCL kernel function</source>
          <target>attribute {$arg0} can only be applied to an OpenCL kernel function</target>
        </segment>
      </unit>
      <unit id="4688" name="err_opencl_multiple_access_qualifiers">
        <segment>
          <source>multiple access qualifiers</source>
          <target>multiple access qualifiers</target>
        </segment>
      </unit>
      <unit id="4689" name="err_opencl_no_main">
        <segment>
          <source>%select{function|kernel}0 cannot be called 'main'</source>
          <target>{$arg0 :select s0=|function| s1=|kernel|} cannot be called 'main'</target>
        </segment>
      </unit>
      <unit id="4690" name="err_opencl_nonconst_global_sampler">
        <segment>
          <source>global sampler requires a const or constant address space qualifier</source>
          <target>global sampler requires a const or constant address space qualifier</target>
        </segment>
      </unit>
      <unit id="4691" name="err_opencl_pointer_to_type">
        <segment>
          <source>pointer to type %0 is invalid in OpenCL</source>
          <target>pointer to type {$arg0} is invalid in OpenCL</target>
        </segment>
      </unit>
      <unit id="4692" name="err_opencl_ptrptr_kernel_param">
        <segment>
          <source>kernel parameter cannot be declared as a pointer to a pointer</source>
          <target>kernel parameter cannot be declared as a pointer to a pointer</target>
        </segment>
      </unit>
      <unit id="4693" name="err_opencl_requires_extension">
        <segment>
          <source>use of %select{type|declaration}0 %1 requires %2 support</source>
          <target>use of {$arg0 :select s0=|type| s1=|declaration|} {$arg1} requires {$arg2} support</target>
        </segment>
      </unit>
      <unit id="4694" name="err_opencl_scalar_type_rank_greater_than_vector_type">
        <segment>
          <source>scalar operand type has greater rank than the type of the vector element. (%0 and %1)</source>
          <target>scalar operand type has greater rank than the type of the vector element. ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="4695" name="err_opencl_sizeof_alignof_type">
        <segment>
          <source>invalid application of '%0' to a void type</source>
          <target>invalid application of '{$arg0}' to a void type</target>
        </segment>
      </unit>
      <unit id="4696" name="err_opencl_taking_address_capture">
        <segment>
          <source>taking address of a capture is not allowed</source>
          <target>taking address of a capture is not allowed</target>
        </segment>
      </unit>
      <unit id="4697" name="err_opencl_ternary_with_block">
        <segment>
          <source>block type cannot be used as expression in ternary expression in OpenCL</source>
          <target>block type cannot be used as expression in ternary expression in OpenCL</target>
        </segment>
      </unit>
      <unit id="4698" name="err_opencl_type_can_only_be_used_as_function_parameter">
        <segment>
          <source>type %0 can only be used as a function parameter in OpenCL</source>
          <target>type {$arg0} can only be used as a function parameter in OpenCL</target>
        </segment>
      </unit>
      <unit id="4699" name="err_opencl_type_not_found">
        <segment>
          <source>%0 type %1 not found; include the base header with -finclude-default-header</source>
          <target>{$arg0} type {$arg1} not found; include the base header with -finclude-default-header</target>
        </segment>
      </unit>
      <unit id="4700" name="err_opencl_type_struct_or_union_field">
        <segment>
          <source>the %0 type cannot be used to declare a structure or union field</source>
          <target>the {$arg0} type cannot be used to declare a structure or union field</target>
        </segment>
      </unit>
      <unit id="4701" name="err_opencl_variadic_function">
        <segment>
          <source>invalid prototype, variadic arguments are not allowed in OpenCL</source>
          <target>invalid prototype, variadic arguments are not allowed in OpenCL</target>
        </segment>
      </unit>
      <unit id="4702" name="err_opencl_vla">
        <segment>
          <source>variable length arrays are not supported in OpenCL</source>
          <target>variable length arrays are not supported in OpenCL</target>
        </segment>
      </unit>
      <unit id="4703" name="err_openclcxx_placement_new">
        <segment>
          <source>use of placement new requires explicit declaration</source>
          <target>use of placement new requires explicit declaration</target>
        </segment>
      </unit>
      <unit id="4704" name="err_openmp_default_simd_align_expr">
        <segment>
          <source>invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed</source>
          <target>invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed</target>
        </segment>
      </unit>
      <unit id="4705" name="err_openmp_vla_in_task_untied">
        <segment>
          <source>variable length arrays are not supported in OpenMP tasking regions with 'untied' clause</source>
          <target>variable length arrays are not supported in OpenMP tasking regions with 'untied' clause</target>
        </segment>
      </unit>
      <unit id="4706" name="err_operator_arrow_circular">
        <segment>
          <source>circular pointer delegation detected</source>
          <target>circular pointer delegation detected</target>
        </segment>
      </unit>
      <unit id="4707" name="err_operator_arrow_depth_exceeded">
        <segment>
          <source>use of 'operator-&gt;' on type %0 would invoke a sequence of more than %1 'operator-&gt;' calls</source>
          <target>use of 'operator-&gt;' on type {$arg0} would invoke a sequence of more than {$arg1} 'operator-&gt;' calls</target>
        </segment>
      </unit>
      <unit id="4708" name="err_operator_delete_dependent_param_type">
        <segment>
          <source state="initial">%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %4 instead</source>
          <target>{$arg0 :select s0=|| s1=|type aware |}{$arg1 :select s0=|| s1=|destroying |}{$arg2} cannot take a dependent type as its %ordinal3 parameter; use {$arg4} instead</target>
        </segment>
      </unit>
      <unit id="4709" name="err_operator_delete_param_type">
        <segment>
          <source state="initial">%ordinal3 parameter of%select{| type aware}0%select{| destroying}1 %2 must have type %4</source>
          <target>%ordinal3 parameter of{$arg0 :select s0=|| s1=| type aware|}{$arg1 :select s0=|| s1=| destroying|} {$arg2} must have type {$arg4}</target>
        </segment>
      </unit>
      <unit id="4710" name="err_operator_new_default_arg">
        <segment>
          <source>parameter of %0 cannot have a default argument</source>
          <target>parameter of {$arg0} cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="4711" name="err_operator_new_delete_declared_in_namespace">
        <segment>
          <source>%0 cannot be declared inside a namespace</source>
          <target>{$arg0} cannot be declared inside a namespace</target>
        </segment>
      </unit>
      <unit id="4712" name="err_operator_new_delete_declared_static">
        <segment>
          <source>%0 cannot be declared static in global scope</source>
          <target>{$arg0} cannot be declared static in global scope</target>
        </segment>
      </unit>
      <unit id="4713" name="err_operator_new_delete_dependent_result_type">
        <segment>
          <source>%0 cannot have a dependent return type; use %1 instead</source>
          <target>{$arg0} cannot have a dependent return type; use {$arg1} instead</target>
        </segment>
      </unit>
      <unit id="4714" name="err_operator_new_delete_invalid_result_type">
        <segment>
          <source>%0 must return type %1</source>
          <target>{$arg0} must return type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4715" name="err_operator_new_delete_template_too_few_parameters">
        <segment>
          <source>%0 template must have at least two parameters</source>
          <target>{$arg0} template must have at least two parameters</target>
        </segment>
      </unit>
      <unit id="4716" name="err_operator_new_delete_too_few_parameters">
        <segment>
          <source state="initial">%select{|type aware }0%select{|destroying }1%2 must have at least %select{|one|two|three|four|five}3 parameter%s3</source>
          <target>{$arg0 :select s0=|| s1=|type aware |}{$arg1 :select s0=|| s1=|destroying |}{$arg2} must have at least {$arg3 :select s0=|| s1=|one| s2=|two| s3=|three| s4=|four| s5=|five|} parameter%s3</target>
        </segment>
      </unit>
      <unit id="4717" name="err_operator_new_dependent_param_type">
        <segment>
          <source state="initial">%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %5 (%4) instead</source>
          <target>{$arg0 :select s0=|| s1=|type aware |}{$arg1 :select s0=|| s1=|destroying |}{$arg2} cannot take a dependent type as its %ordinal3 parameter; use {$arg5} ({$arg4}) instead</target>
        </segment>
      </unit>
      <unit id="4718" name="err_operator_new_param_type">
        <segment>
          <source state="initial">%select{|type aware }0%select{|destroying }1%2 takes type %5 (%4) as %ordinal3 parameter</source>
          <target>{$arg0 :select s0=|| s1=|type aware |}{$arg1 :select s0=|| s1=|destroying |}{$arg2} takes type {$arg5} ({$arg4}) as %ordinal3 parameter</target>
        </segment>
      </unit>
      <unit id="4719" name="err_operator_overload_default_arg">
        <segment>
          <source>parameter of overloaded %0 cannot have a default argument</source>
          <target>parameter of overloaded {$arg0} cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="4720" name="err_operator_overload_must_be">
        <segment>
          <source>overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)</source>
          <target>overloaded {$arg0} must be a {$arg2 :select s0=|unary| s1=|binary| s2=|unary or binary|} operator (has {$arg1} parameter%s1)</target>
        </segment>
      </unit>
      <unit id="4721" name="err_operator_overload_must_be_member">
        <segment>
          <source>overloaded %0 must be a non-static member function</source>
          <target>overloaded {$arg0} must be a non-static member function</target>
        </segment>
      </unit>
      <unit id="4722" name="err_operator_overload_needs_class_or_enum">
        <segment>
          <source>overloaded %0 must have at least one parameter of class or enumeration type</source>
          <target>overloaded {$arg0} must have at least one parameter of class or enumeration type</target>
        </segment>
      </unit>
      <unit id="4723" name="err_operator_overload_post_incdec_must_be_int">
        <segment>
          <source>parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)</source>
          <target>parameter of overloaded post-{$arg1 :select s0=|increment| s1=|decrement|} operator must have type 'int' (not {$arg0})</target>
        </segment>
      </unit>
      <unit id="4724" name="err_operator_overload_static">
        <segment>
          <source>overloaded %0 cannot be a static member function</source>
          <target>overloaded {$arg0} cannot be a static member function</target>
        </segment>
      </unit>
      <unit id="4725" name="err_operator_overload_variadic">
        <segment>
          <source>overloaded %0 cannot be variadic</source>
          <target>overloaded {$arg0} cannot be variadic</target>
        </segment>
      </unit>
      <unit id="4726" name="err_os_log_argument_too_big">
        <segment>
          <source>os_log() argument %0 is too big (%1 bytes, max %2)</source>
          <target>os_log() argument {$arg0} is too big ({$arg1} bytes, max {$arg2})</target>
        </segment>
      </unit>
      <unit id="4727" name="err_os_log_format_not_string_constant">
        <segment>
          <source>os_log() format argument is not a string constant</source>
          <target>os_log() format argument is not a string constant</target>
        </segment>
      </unit>
      <unit id="4728" name="err_out_of_line_default_deletes">
        <segment>
          <source>defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration</source>
          <target>defaulting this {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} would delete it after its first declaration</target>
        </segment>
      </unit>
      <unit id="4729" name="err_out_of_line_qualified_id_type_names_constructor">
        <segment>
          <source>qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context</source>
          <target>qualified reference to {$arg0} is a constructor name rather than a {$arg1 :select s0=|template name| s1=|type|} in this context</target>
        </segment>
      </unit>
      <unit id="4730" name="err_overflow_builtin_bit_int_max_size">
        <segment>
          <source>__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits</source>
          <target>__builtin_mul_overflow does not support 'signed _BitInt' operands of more than {$arg0} bits</target>
        </segment>
      </unit>
      <unit id="4731" name="err_overflow_builtin_must_be_int">
        <segment>
          <source>operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)</source>
          <target>operand argument to {$arg0 :select s0=|overflow builtin| s1=|checked integer operation|} must be an integer type {$arg0 :select s0=|| s1=|other than plain 'char', 'bool', bit-precise, or an enumeration |}({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4732" name="err_overflow_builtin_must_be_ptr_int">
        <segment>
          <source>result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)</source>
          <target>result argument to {$arg0 :select s0=|overflow builtin| s1=|checked integer operation|} must be a pointer to a non-const integer type {$arg0 :select s0=|| s1=|other than plain 'char', 'bool', bit-precise, or an enumeration |}({$arg1} invalid)</target>
        </segment>
      </unit>
      <unit id="4733" name="err_override_exception_spec">
        <segment>
          <source>exception specification of overriding function is more lax than base version</source>
          <target>exception specification of overriding function is more lax than base version</target>
        </segment>
      </unit>
      <unit id="4734" name="err_ovl_ambiguous_call">
        <segment>
          <source>call to %0 is ambiguous</source>
          <target>call to {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4735" name="err_ovl_ambiguous_conversion_in_cast">
        <segment>
          <source>ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2</source>
          <target>ambiguous conversion for {$arg0 :select s0=|| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2}</target>
        </segment>
      </unit>
      <unit id="4736" name="err_ovl_ambiguous_init">
        <segment>
          <source>call to constructor of %0 is ambiguous</source>
          <target>call to constructor of {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4737" name="err_ovl_ambiguous_member_call">
        <segment>
          <source>call to member function %0 is ambiguous</source>
          <target>call to member function {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4738" name="err_ovl_ambiguous_object_call">
        <segment>
          <source>call to object of type %0 is ambiguous</source>
          <target>call to object of type {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4739" name="err_ovl_ambiguous_oper_binary">
        <segment>
          <source>use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)</source>
          <target>use of overloaded operator '{$arg0}' is ambiguous (with operand types {$arg1} and {$arg2})</target>
        </segment>
      </unit>
      <unit id="4740" name="err_ovl_ambiguous_oper_unary">
        <segment>
          <source>use of overloaded operator '%0' is ambiguous (operand type %1)</source>
          <target>use of overloaded operator '{$arg0}' is ambiguous (operand type {$arg1})</target>
        </segment>
      </unit>
      <unit id="4741" name="err_ovl_ambiguous_subscript_call">
        <segment>
          <source>call to subscript operator of type %0 is ambiguous</source>
          <target>call to subscript operator of type {$arg0} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4742" name="err_ovl_deleted_call">
        <segment>
          <source>call to deleted%select{| member}0 function %1%select{|: %3}2</source>
          <target>call to deleted{$arg0 :select s0=|| s1=| member|} function {$arg1}{$arg2 :select s0=|| s1=|: {$arg3}|}</target>
        </segment>
      </unit>
      <unit id="4743" name="err_ovl_deleted_comparison">
        <segment>
          <source>object of type %0 cannot be compared because its %1 is implicitly deleted</source>
          <target>object of type {$arg0} cannot be compared because its {$arg1} is implicitly deleted</target>
        </segment>
      </unit>
      <unit id="4744" name="err_ovl_deleted_conversion_in_cast">
        <segment>
          <source>%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3</source>
          <target>{$arg0 :select s0=|| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2} uses deleted function{$arg3 :select s0=|| s1=|: {$arg4}|}</target>
        </segment>
      </unit>
      <unit id="4745" name="err_ovl_deleted_init">
        <segment>
          <source>call to deleted constructor of %0%select{|: %2}1</source>
          <target>call to deleted constructor of {$arg0}{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="4746" name="err_ovl_deleted_object_call">
        <segment>
          <source>call to deleted function call operator in type %0%select{|: %2}1</source>
          <target>call to deleted function call operator in type {$arg0}{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="4747" name="err_ovl_deleted_oper">
        <segment>
          <source>overload resolution selected deleted operator '%0'%select{|: %2}1</source>
          <target>overload resolution selected deleted operator '{$arg0}'{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="4748" name="err_ovl_deleted_special_init">
        <segment>
          <source>call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1</source>
          <target>call to implicitly-deleted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor| s6=|function|} of {$arg1}</target>
        </segment>
      </unit>
      <unit id="4749" name="err_ovl_deleted_special_oper">
        <segment>
          <source>object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted</source>
          <target>object of type {$arg0} cannot be {$arg1 :select s0=|constructed| s1=|copied| s2=|moved| s3=|assigned| s4=|assigned| s5=|destroyed|} because its {$arg1 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} is implicitly deleted</target>
        </segment>
      </unit>
      <unit id="4750" name="err_ovl_diff_return_type">
        <segment>
          <source>functions that differ only in their return type cannot be overloaded</source>
          <target>functions that differ only in their return type cannot be overloaded</target>
        </segment>
      </unit>
      <unit id="4751" name="err_ovl_no_conversion_in_cast">
        <segment>
          <source>cannot convert %1 to %2 without a conversion operator</source>
          <target>cannot convert {$arg1} to {$arg2} without a conversion operator</target>
        </segment>
      </unit>
      <unit id="4752" name="err_ovl_no_oper">
        <segment>
          <source>type %0 does not provide a %select{subscript|call}1 operator</source>
          <target>type {$arg0} does not provide a {$arg1 :select s0=|subscript| s1=|call|} operator</target>
        </segment>
      </unit>
      <unit id="4753" name="err_ovl_no_viable_conversion_in_cast">
        <segment>
          <source>no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2</source>
          <target>no matching conversion for {$arg0 :select s0=|| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2}</target>
        </segment>
      </unit>
      <unit id="4754" name="err_ovl_no_viable_function_in_call">
        <segment>
          <source>no matching function for call to %0</source>
          <target>no matching function for call to {$arg0}</target>
        </segment>
      </unit>
      <unit id="4755" name="err_ovl_no_viable_function_in_init">
        <segment>
          <source>no matching constructor for initialization of %0</source>
          <target>no matching constructor for initialization of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4756" name="err_ovl_no_viable_literal_operator">
        <segment>
          <source>no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5</source>
          <target>no matching literal operator for call to {$arg0}{$arg1 :select s0=|| s1=| with argument of type {$arg2}| s2=| with arguments of types {$arg2} and {$arg3}|}{$arg4 :select s0=|| s1=| or 'const char *'|}{$arg5 :select s0=|| s1=|, and no matching literal operator template|}</target>
        </segment>
      </unit>
      <unit id="4757" name="err_ovl_no_viable_member_function_in_call">
        <segment>
          <source>no matching member function for call to %0</source>
          <target>no matching member function for call to {$arg0}</target>
        </segment>
      </unit>
      <unit id="4758" name="err_ovl_no_viable_object_call">
        <segment>
          <source>no matching function for call to object of type %0</source>
          <target>no matching function for call to object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4759" name="err_ovl_no_viable_oper">
        <segment>
          <source>no viable overloaded '%0'</source>
          <target>no viable overloaded '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4760" name="err_ovl_no_viable_subscript">
        <segment>
          <source>no viable overloaded operator[] for type %0</source>
          <target>no viable overloaded operator[] for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4761" name="err_ovl_rewrite_equalequal_not_bool">
        <segment>
          <source>return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'</source>
          <target>return type {$arg0} of selected 'operator==' function for rewritten '{$arg1}' comparison is not 'bool'</target>
        </segment>
      </unit>
      <unit id="4762" name="err_ovl_static_nonstatic_member">
        <segment>
          <source>static and non-static member functions with the same parameter types cannot be overloaded</source>
          <target>static and non-static member functions with the same parameter types cannot be overloaded</target>
        </segment>
      </unit>
      <unit id="4763" name="err_ovl_unresolvable">
        <segment>
          <source>reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?</source>
          <target>reference to {$arg1 :select s0=|overloaded| s1=|multiversioned|} function could not be resolved; did you mean to call it{$arg0 :select s0=|| s1=| with no arguments|}?</target>
        </segment>
      </unit>
      <unit id="4764" name="err_ownership_returns_index_mismatch">
        <segment>
          <source>'ownership_returns' attribute index does not match; here it is %0</source>
          <target>'ownership_returns' attribute index does not match; here it is {$arg0}</target>
        </segment>
      </unit>
      <unit id="4765" name="err_ownership_takes_class_mismatch">
        <segment>
          <source>'ownership_takes' attribute class does not match; here it is '%0'</source>
          <target>'ownership_takes' attribute class does not match; here it is '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4766" name="err_ownership_takes_return_type">
        <segment>
          <source>'ownership_returns' attribute only applies to functions that return a pointer</source>
          <target>'ownership_returns' attribute only applies to functions that return a pointer</target>
        </segment>
      </unit>
      <unit id="4767" name="err_ownership_type">
        <segment>
          <source>%0 attribute only applies to %select{pointer|integer}1 arguments</source>
          <target>{$arg0} attribute only applies to {$arg1 :select s0=|pointer| s1=|integer|} arguments</target>
        </segment>
      </unit>
      <unit id="4768" name="err_pack_expansion_length_conflict">
        <segment>
          <source state="initial">pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)</source>
          <target>pack expansion contains parameter packs {$arg0} and {$arg1} that have different lengths ({$arg2} vs. {$arg3 :select s0=|| s1=|at least |}{$arg4})</target>
        </segment>
      </unit>
      <unit id="4769" name="err_pack_expansion_length_conflict_multilevel">
        <segment>
          <source state="initial">pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs</source>
          <target>pack expansion contains parameter pack {$arg0} that has a different length ({$arg1} vs. {$arg2 :select s0=|| s1=|at least |}{$arg3}) from outer parameter packs</target>
        </segment>
      </unit>
      <unit id="4770" name="err_pack_expansion_length_conflict_partial">
        <segment>
          <source>pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs</source>
          <target>pack expansion contains parameter pack {$arg0} that has a different length (at least {$arg1} vs. {$arg2}) from outer parameter packs</target>
        </segment>
      </unit>
      <unit id="4771" name="err_pack_expansion_member_init">
        <segment>
          <source>pack expansion for initialization of member %0</source>
          <target>pack expansion for initialization of member {$arg0}</target>
        </segment>
      </unit>
      <unit id="4772" name="err_pack_expansion_without_parameter_packs">
        <segment>
          <source>pack expansion does not contain any unexpanded parameter packs</source>
          <target>pack expansion does not contain any unexpanded parameter packs</target>
        </segment>
      </unit>
      <unit id="4773" name="err_pack_index_out_of_bound">
        <segment>
          <source>invalid index %0 for pack %1 of size %2</source>
          <target>invalid index {$arg0} for pack {$arg1} of size {$arg2}</target>
        </segment>
      </unit>
      <unit id="4774" name="err_pack_outside_template">
        <segment>
          <source>pack declaration outside of template</source>
          <target>pack declaration outside of template</target>
        </segment>
      </unit>
      <unit id="4775" name="err_param_default_argument">
        <segment>
          <source>C does not support default arguments</source>
          <target>C does not support default arguments</target>
        </segment>
      </unit>
      <unit id="4776" name="err_param_default_argument_member_template_redecl">
        <segment>
          <source>default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0</source>
          <target>default arguments cannot be added to an out-of-line definition of a member of a {$arg0 :select s0=|class template| s1=|class template partial specialization| s2=|nested class in a template|}</target>
        </segment>
      </unit>
      <unit id="4777" name="err_param_default_argument_missing">
        <segment>
          <source>missing default argument on parameter</source>
          <target>missing default argument on parameter</target>
        </segment>
      </unit>
      <unit id="4778" name="err_param_default_argument_missing_name">
        <segment>
          <source>missing default argument on parameter %0</source>
          <target>missing default argument on parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="4779" name="err_param_default_argument_nonfunc">
        <segment>
          <source>default arguments can only be specified for parameters in a function declaration</source>
          <target>default arguments can only be specified for parameters in a function declaration</target>
        </segment>
      </unit>
      <unit id="4780" name="err_param_default_argument_on_parameter_pack">
        <segment>
          <source>parameter pack cannot have a default argument</source>
          <target>parameter pack cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="4781" name="err_param_default_argument_redefinition">
        <segment>
          <source>redefinition of default argument</source>
          <target>redefinition of default argument</target>
        </segment>
      </unit>
      <unit id="4782" name="err_param_default_argument_references_local">
        <segment>
          <source>default argument references local variable %0 of enclosing function</source>
          <target>default argument references local variable {$arg0} of enclosing function</target>
        </segment>
      </unit>
      <unit id="4783" name="err_param_default_argument_references_param">
        <segment>
          <source>default argument references parameter %0</source>
          <target>default argument references parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="4784" name="err_param_default_argument_references_this">
        <segment>
          <source>default argument references 'this'</source>
          <target>default argument references 'this'</target>
        </segment>
      </unit>
      <unit id="4785" name="err_param_default_argument_template_redecl">
        <segment>
          <source>default arguments cannot be added to a function template that has already been declared</source>
          <target>default arguments cannot be added to a function template that has already been declared</target>
        </segment>
      </unit>
      <unit id="4786" name="err_param_with_void_type">
        <segment>
          <source>argument may not have 'void' type</source>
          <target>argument may not have 'void' type</target>
        </segment>
      </unit>
      <unit id="4787" name="err_parameter_shadow_capture">
        <segment>
          <source>a lambda parameter cannot shadow an explicitly captured entity</source>
          <target>a lambda parameter cannot shadow an explicitly captured entity</target>
        </segment>
      </unit>
      <unit id="4788" name="err_parameters_retval_cannot_have_fp16_type">
        <segment>
          <source>%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?</source>
          <target>{$arg0 :select s0=|parameters| s1=|function return value|} cannot have __fp16 type; did you forget * ?</target>
        </segment>
      </unit>
      <unit id="4789" name="err_parens_pointer_member_function">
        <segment>
          <source>cannot parenthesize the name of a method when forming a member pointer</source>
          <target>cannot parenthesize the name of a method when forming a member pointer</target>
        </segment>
      </unit>
      <unit id="4790" name="err_partial_spec_args_match_primary_template">
        <segment>
          <source>%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list</source>
          <target>{$arg0 :select s0=|class| s1=|variable|} template partial specialization does not specialize any template argument; to {$arg1 :select s0=|declare| s1=|define|} the primary template, remove the template argument list</target>
        </segment>
      </unit>
      <unit id="4791" name="err_partial_spec_fully_specialized">
        <segment>
          <source>partial specialization of %0 does not use any of its template parameters</source>
          <target>partial specialization of {$arg0} does not use any of its template parameters</target>
        </segment>
      </unit>
      <unit id="4792" name="err_partial_spec_ordering_ambiguous">
        <segment>
          <source>ambiguous partial specializations of %0</source>
          <target>ambiguous partial specializations of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4793" name="err_partial_spec_redeclared">
        <segment>
          <source>class template partial specialization %0 cannot be redeclared</source>
          <target>class template partial specialization {$arg0} cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="4794" name="err_partial_specialization_friend">
        <segment>
          <source>partial specialization cannot be declared as a friend</source>
          <target>partial specialization cannot be declared as a friend</target>
        </segment>
      </unit>
      <unit id="4795" name="err_placeholder_constraints_not_satisfied">
        <segment>
          <source>deduced type %0 does not satisfy %1</source>
          <target>deduced type {$arg0} does not satisfy {$arg1}</target>
        </segment>
      </unit>
      <unit id="4796" name="err_placement_new_non_placement_delete">
        <segment>
          <source>'new' expression with placement arguments refers to non-placement 'operator delete'</source>
          <target>'new' expression with placement arguments refers to non-placement 'operator delete'</target>
        </segment>
      </unit>
      <unit id="4797" name="err_pointer_to_member_call_drops_quals">
        <segment>
          <source>call to pointer to member function of type %0 drops '%1' qualifier%s2</source>
          <target>call to pointer to member function of type {$arg0} drops '{$arg1}' qualifier%s2</target>
        </segment>
      </unit>
      <unit id="4798" name="err_pointer_to_member_oper_value_classify">
        <segment>
          <source>pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1</source>
          <target>pointer-to-member function type {$arg0} can only be called on an {$arg1 :select s0=|rvalue| s1=|lvalue|}</target>
        </segment>
      </unit>
      <unit id="4799" name="err_pointer_to_member_type">
        <segment>
          <source>invalid use of pointer to member type after %select{.*|-&gt;*}0</source>
          <target>invalid use of pointer to member type after {$arg0 :select s0=|.*| s1=|-&gt;*|}</target>
        </segment>
      </unit>
      <unit id="4800" name="err_ppc_builtin_requires_abi">
        <segment>
          <source>this builtin requires ABI -mabi=%0</source>
          <target>this builtin requires ABI -mabi={$arg0}</target>
        </segment>
      </unit>
      <unit id="4801" name="err_ppc_invalid_test_data_class_type">
        <segment>
          <source>expected a 'float', 'double' or '__float128' for the first argument</source>
          <target>expected a 'float', 'double' or '__float128' for the first argument</target>
        </segment>
      </unit>
      <unit id="4802" name="err_ppc_invalid_use_mma_type">
        <segment>
          <source>invalid use of PPC MMA type</source>
          <target>invalid use of PPC MMA type</target>
        </segment>
      </unit>
      <unit id="4803" name="err_pragma_alloc_text_c_linkage">
        <segment>
          <source>'#pragma alloc_text' is applicable only to functions with C linkage</source>
          <target>'#pragma alloc_text' is applicable only to functions with C linkage</target>
        </segment>
      </unit>
      <unit id="4804" name="err_pragma_alloc_text_not_function">
        <segment>
          <source>'#pragma alloc_text' is applicable only to functions</source>
          <target>'#pragma alloc_text' is applicable only to functions</target>
        </segment>
      </unit>
      <unit id="4805" name="err_pragma_attr_attr_no_push">
        <segment>
          <source>'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'</source>
          <target>'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'</target>
        </segment>
      </unit>
      <unit id="4806" name="err_pragma_attribute_invalid_matchers">
        <segment>
          <source state="initial">attribute %0 cannot be applied to %1</source>
          <target>attribute {$arg0} cannot be applied to {$arg1}</target>
        </segment>
      </unit>
      <unit id="4807" name="err_pragma_attribute_matcher_negated_subrule_contradicts_subrule">
        <segment>
          <source>negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'</source>
          <target>negated attribute subject matcher sub-rule '{$arg0}' contradicts sub-rule '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4808" name="err_pragma_attribute_matcher_subrule_contradicts_rule">
        <segment>
          <source>redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations</source>
          <target>redundant attribute subject matcher sub-rule '{$arg0}'; '{$arg1}' already matches those declarations</target>
        </segment>
      </unit>
      <unit id="4809" name="err_pragma_attribute_no_pop_eof">
        <segment>
          <source>unterminated '#pragma clang attribute push' at end of file</source>
          <target>unterminated '#pragma clang attribute push' at end of file</target>
        </segment>
      </unit>
      <unit id="4810" name="err_pragma_attribute_stack_mismatch">
        <segment>
          <source>'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'</source>
          <target>'#pragma clang attribute {$arg0 :select s0=|{$arg1}.| s1=||}pop' with no matching '#pragma clang attribute {$arg0 :select s0=|{$arg1}.| s1=||}push'</target>
        </segment>
      </unit>
      <unit id="4811" name="err_pragma_expected_file_scope">
        <segment>
          <source>'#pragma %0' can only appear at file scope</source>
          <target>'#pragma {$arg0}' can only appear at file scope</target>
        </segment>
      </unit>
      <unit id="4812" name="err_pragma_fc_except_requires_precise">
        <segment>
          <source>'#pragma float_control(except, on)' is illegal when precise is disabled</source>
          <target>'#pragma float_control(except, on)' is illegal when precise is disabled</target>
        </segment>
      </unit>
      <unit id="4813" name="err_pragma_fc_noprecise_requires_noexcept">
        <segment>
          <source>'#pragma float_control(precise, off)' is illegal when except is enabled</source>
          <target>'#pragma float_control(precise, off)' is illegal when except is enabled</target>
        </segment>
      </unit>
      <unit id="4814" name="err_pragma_fc_noprecise_requires_nofenv">
        <segment>
          <source>'#pragma float_control(precise, off)' is illegal when fenv_access is enabled</source>
          <target>'#pragma float_control(precise, off)' is illegal when fenv_access is enabled</target>
        </segment>
      </unit>
      <unit id="4815" name="err_pragma_fc_pp_scope">
        <segment>
          <source>'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification</source>
          <target>'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification</target>
        </segment>
      </unit>
      <unit id="4816" name="err_pragma_fenv_requires_precise">
        <segment>
          <source>'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled</source>
          <target>'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled</target>
        </segment>
      </unit>
      <unit id="4817" name="err_pragma_loop_compatibility">
        <segment>
          <source>%select{incompatible|duplicate}0 directives '%1' and '%2'</source>
          <target>{$arg0 :select s0=|incompatible| s1=|duplicate|} directives '{$arg1}' and '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="4818" name="err_pragma_loop_invalid_argument_type">
        <segment>
          <source>invalid argument of type %0; expected an integer type</source>
          <target>invalid argument of type {$arg0}; expected an integer type</target>
        </segment>
      </unit>
      <unit id="4819" name="err_pragma_loop_precedes_nonloop">
        <segment>
          <source>expected a for, while, or do-while loop to follow '%0'</source>
          <target>expected a for, while, or do-while loop to follow '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="4820" name="err_pragma_options_align_mac68k_target_unsupported">
        <segment>
          <source>mac68k alignment pragma is not supported on this target</source>
          <target>mac68k alignment pragma is not supported on this target</target>
        </segment>
      </unit>
      <unit id="4821" name="err_pragma_pack_identifer_not_supported">
        <segment>
          <source>specifying an identifier within `#pragma pack` is not supported on this target</source>
          <target>specifying an identifier within `#pragma pack` is not supported on this target</target>
        </segment>
      </unit>
      <unit id="4822" name="err_pragma_pack_invalid_alignment">
        <segment>
          <source>expected #pragma pack parameter to be '1', '2', '4', '8', or '16'</source>
          <target>expected #pragma pack parameter to be '1', '2', '4', '8', or '16'</target>
        </segment>
      </unit>
      <unit id="4823" name="err_pragma_pop_visibility_mismatch">
        <segment>
          <source>#pragma visibility pop with no matching #pragma visibility push</source>
          <target>#pragma visibility pop with no matching #pragma visibility push</target>
        </segment>
      </unit>
      <unit id="4824" name="err_pragma_push_visibility_mismatch">
        <segment>
          <source>#pragma visibility push with no matching #pragma visibility pop</source>
          <target>#pragma visibility push with no matching #pragma visibility pop</target>
        </segment>
      </unit>
      <unit id="4825" name="err_pragma_section_invalid_for_target">
        <segment>
          <source>argument to #pragma section is not valid for this target: %0</source>
          <target>argument to #pragma section is not valid for this target: {$arg0}</target>
        </segment>
      </unit>
      <unit id="4826" name="err_preserve_enum_value_invalid">
        <segment>
          <source>__builtin_preserve_enum_value argument %0 invalid</source>
          <target>__builtin_preserve_enum_value argument {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="4827" name="err_preserve_enum_value_not_const">
        <segment>
          <source>__builtin_preserve_enum_value argument %0 not a constant</source>
          <target>__builtin_preserve_enum_value argument {$arg0} not a constant</target>
        </segment>
      </unit>
      <unit id="4828" name="err_preserve_field_info_not_const">
        <segment>
          <source>__builtin_preserve_field_info argument %0 not a constant</source>
          <target>__builtin_preserve_field_info argument {$arg0} not a constant</target>
        </segment>
      </unit>
      <unit id="4829" name="err_preserve_field_info_not_field">
        <segment>
          <source>__builtin_preserve_field_info argument %0 not a field access</source>
          <target>__builtin_preserve_field_info argument {$arg0} not a field access</target>
        </segment>
      </unit>
      <unit id="4830" name="err_preserve_type_info_invalid">
        <segment>
          <source>__builtin_preserve_type_info argument %0 invalid</source>
          <target>__builtin_preserve_type_info argument {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="4831" name="err_preserve_type_info_not_const">
        <segment>
          <source>__builtin_preserve_type_info argument %0 not a constant</source>
          <target>__builtin_preserve_type_info argument {$arg0} not a constant</target>
        </segment>
      </unit>
      <unit id="4832" name="err_private_ivar_access">
        <segment>
          <source>instance variable %0 is private</source>
          <target>instance variable {$arg0} is private</target>
        </segment>
      </unit>
      <unit id="4833" name="err_private_module_fragment_not_module">
        <segment>
          <source>private module fragment declaration with no preceding module declaration</source>
          <target>private module fragment declaration with no preceding module declaration</target>
        </segment>
      </unit>
      <unit id="4834" name="err_private_module_fragment_not_module_interface">
        <segment>
          <source>private module fragment in module implementation unit</source>
          <target>private module fragment in module implementation unit</target>
        </segment>
      </unit>
      <unit id="4835" name="err_private_module_fragment_redefined">
        <segment>
          <source>private module fragment redefined</source>
          <target>private module fragment redefined</target>
        </segment>
      </unit>
      <unit id="4836" name="err_probability_not_constant_float">
        <segment>
          <source>probability argument to __builtin_expect_with_probability must be constant floating-point expression</source>
          <target>probability argument to __builtin_expect_with_probability must be constant floating-point expression</target>
        </segment>
      </unit>
      <unit id="4837" name="err_probability_out_of_range">
        <segment>
          <source>probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]</source>
          <target>probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]</target>
        </segment>
      </unit>
      <unit id="4838" name="err_property_accessor_type">
        <segment>
          <source>type of property %0 (%1) does not match type of accessor %2 (%3)</source>
          <target>type of property {$arg0} ({$arg1}) does not match type of accessor {$arg2} ({$arg3})</target>
        </segment>
      </unit>
      <unit id="4839" name="err_property_found_suggest">
        <segment>
          <source>property %0 found on object of type %1; did you mean to access it with the "." operator?</source>
          <target>property {$arg0} found on object of type {$arg1}; did you mean to access it with the "." operator?</target>
        </segment>
      </unit>
      <unit id="4840" name="err_property_function_in_objc_container">
        <segment>
          <source>use of Objective-C property in function nested in Objective-C container not supported, move function outside its container</source>
          <target>use of Objective-C property in function nested in Objective-C container not supported, move function outside its container</target>
        </segment>
      </unit>
      <unit id="4841" name="err_property_implemented">
        <segment>
          <source>property %0 is already implemented</source>
          <target>property {$arg0} is already implemented</target>
        </segment>
      </unit>
      <unit id="4842" name="err_property_is_variably_modified">
        <segment>
          <source>property %0 has a variably modified type</source>
          <target>property {$arg0} has a variably modified type</target>
        </segment>
      </unit>
      <unit id="4843" name="err_property_ivar_type">
        <segment>
          <source>type of property %0 (%1) does not match type of instance variable %2 (%3)</source>
          <target>type of property {$arg0} ({$arg1}) does not match type of instance variable {$arg2} ({$arg3})</target>
        </segment>
      </unit>
      <unit id="4844" name="err_property_method_unavailable">
        <segment>
          <source>property access is using %0 method which is unavailable</source>
          <target>property access is using {$arg0} method which is unavailable</target>
        </segment>
      </unit>
      <unit id="4845" name="err_property_not_as_forward_class">
        <segment>
          <source>property %0 refers to an incomplete Objective-C class %1 (with no @interface available)</source>
          <target>property {$arg0} refers to an incomplete Objective-C class {$arg1} (with no @interface available)</target>
        </segment>
      </unit>
      <unit id="4846" name="err_property_not_found">
        <segment>
          <source>property %0 not found on object of type %1</source>
          <target>property {$arg0} not found on object of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4847" name="err_property_not_found_forward_class">
        <segment>
          <source>property %0 cannot be found in forward class object %1</source>
          <target>property {$arg0} cannot be found in forward class object {$arg1}</target>
        </segment>
      </unit>
      <unit id="4848" name="err_property_not_found_suggest">
        <segment>
          <source>property %0 not found on object of type %1; did you mean %2?</source>
          <target>property {$arg0} not found on object of type {$arg1}; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="4849" name="err_property_setter_ambiguous_use">
        <segment>
          <source>synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior</source>
          <target>synthesized properties {$arg0} and {$arg1} both claim setter {$arg2} - use of this setter will cause unexpected behavior</target>
        </segment>
      </unit>
      <unit id="4850" name="err_property_type">
        <segment>
          <source>property cannot have array or function type %0</source>
          <target>property cannot have array or function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4851" name="err_protected_ivar_access">
        <segment>
          <source>instance variable %0 is protected</source>
          <target>instance variable {$arg0} is protected</target>
        </segment>
      </unit>
      <unit id="4852" name="err_protocol_has_circular_dependency">
        <segment>
          <source>protocol has circular dependency</source>
          <target>protocol has circular dependency</target>
        </segment>
      </unit>
      <unit id="4853" name="err_protocol_property_mismatch">
        <segment>
          <source>property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis</source>
          <target>property {$arg0 :select s0=|of type {$arg1}| s1=|with attribute '{$arg1}'| s2=|without attribute '{$arg1}'| s3=|with getter {$arg1}| s4=|with setter {$arg1}|} was selected for synthesis</target>
        </segment>
      </unit>
      <unit id="4854" name="err_pseudo_dtor_base_not_scalar">
        <segment>
          <source>object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression</source>
          <target>object expression of non-scalar type {$arg0} cannot be used in a pseudo-destructor expression</target>
        </segment>
      </unit>
      <unit id="4855" name="err_pseudo_dtor_call_with_args">
        <segment>
          <source>call to pseudo-destructor cannot have any arguments</source>
          <target>call to pseudo-destructor cannot have any arguments</target>
        </segment>
      </unit>
      <unit id="4856" name="err_pseudo_dtor_destructor_non_type">
        <segment>
          <source>%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1</source>
          <target>{$arg0} does not refer to a type name in pseudo-destructor expression; expected the name of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4857" name="err_pseudo_dtor_type_mismatch">
        <segment>
          <source>the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression</source>
          <target>the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression</target>
        </segment>
      </unit>
      <unit id="4858" name="err_ptrauth_address_discrimination_invalid">
        <segment>
          <source>invalid address discrimination flag '%0'; '__ptrauth' requires '0' or '1'</source>
          <target>invalid address discrimination flag '{$arg0}'; '__ptrauth' requires '0' or '1'</target>
        </segment>
      </unit>
      <unit id="4859" name="err_ptrauth_arg_not_ice">
        <segment>
          <source>argument to '__ptrauth' must be an integer constant expression</source>
          <target>argument to '__ptrauth' must be an integer constant expression</target>
        </segment>
      </unit>
      <unit id="4860" name="err_ptrauth_bad_constant_discriminator">
        <segment>
          <source>discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two</source>
          <target>discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two</target>
        </segment>
      </unit>
      <unit id="4861" name="err_ptrauth_bad_constant_pointer">
        <segment>
          <source>argument to ptrauth_sign_constant must refer to a global variable or function</source>
          <target>argument to ptrauth_sign_constant must refer to a global variable or function</target>
        </segment>
      </unit>
      <unit id="4862" name="err_ptrauth_disabled">
        <segment>
          <source>this target does not support pointer authentication</source>
          <target>this target does not support pointer authentication</target>
        </segment>
      </unit>
      <unit id="4863" name="err_ptrauth_extra_discriminator_invalid">
        <segment>
          <source>invalid extra discriminator flag '%0'; '__ptrauth' requires a value between '0' and '%1'</source>
          <target>invalid extra discriminator flag '{$arg0}'; '__ptrauth' requires a value between '0' and '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4864" name="err_ptrauth_indirect_goto_addrlabel_arithmetic">
        <segment>
          <source>%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos</source>
          <target>{$arg0 :select s0=|subtraction| s1=|addition|} of address-of-label expressions is not supported with ptrauth indirect gotos</target>
        </segment>
      </unit>
      <unit id="4865" name="err_ptrauth_invalid_key">
        <segment>
          <source>%0 does not identify a valid pointer authentication key for the current target</source>
          <target>{$arg0} does not identify a valid pointer authentication key for the current target</target>
        </segment>
      </unit>
      <unit id="4866" name="err_ptrauth_qualifier_cast">
        <segment>
          <source>cannot cast to '__ptrauth'-qualified type %0</source>
          <target>cannot cast to '__ptrauth'-qualified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4867" name="err_ptrauth_qualifier_invalid">
        <segment>
          <source>%select{return type|parameter type|property}1 may not be qualified with '__ptrauth'; type is %0</source>
          <target>{$arg1 :select s0=|return type| s1=|parameter type| s2=|property|} may not be qualified with '__ptrauth'; type is {$arg0}</target>
        </segment>
      </unit>
      <unit id="4868" name="err_ptrauth_qualifier_invalid_target">
        <segment>
          <source>'__ptrauth' qualifier only applies to pointer or pointer sized integer types; %0 is invalid</source>
          <target>'__ptrauth' qualifier only applies to pointer or pointer sized integer types; {$arg0} is invalid</target>
        </segment>
      </unit>
      <unit id="4869" name="err_ptrauth_qualifier_redundant">
        <segment>
          <source>type %0 is already '__ptrauth'-qualified</source>
          <target>type {$arg0} is already '__ptrauth'-qualified</target>
        </segment>
      </unit>
      <unit id="4870" name="err_ptrauth_string_not_literal">
        <segment>
          <source>argument must be a string literal%select{| of char type}0</source>
          <target>argument must be a string literal{$arg0 :select s0=|| s1=| of char type|}</target>
        </segment>
      </unit>
      <unit id="4871" name="err_ptrauth_type_disc_undiscriminated">
        <segment>
          <source>cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'</source>
          <target>cannot pass undiscriminated type {$arg0} to '__builtin_ptrauth_type_discriminator'</target>
        </segment>
      </unit>
      <unit id="4872" name="err_ptrauth_value_bad_type">
        <segment>
          <source>%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2</source>
          <target>{$arg0 :select s0=|signed value| s1=|extra discriminator| s2=|blended pointer| s3=|blended integer|} must have {$arg1 :select s0=|pointer| s1=|integer| s2=|pointer or integer|} type; type here is {$arg2}</target>
        </segment>
      </unit>
      <unit id="4873" name="err_pure_friend">
        <segment>
          <source>friend declaration cannot have a pure-specifier</source>
          <target>friend declaration cannot have a pure-specifier</target>
        </segment>
      </unit>
      <unit id="4874" name="err_qualified_catch_declarator">
        <segment>
          <source>exception declarator cannot be qualified</source>
          <target>exception declarator cannot be qualified</target>
        </segment>
      </unit>
      <unit id="4875" name="err_qualified_friend_def">
        <segment>
          <source state="initial">friend function definition cannot be qualified with %0</source>
          <target>friend function definition cannot be qualified with {$arg0}</target>
        </segment>
      </unit>
      <unit id="4876" name="err_qualified_friend_no_match">
        <segment>
          <source>friend declaration of %0 does not match any declaration in %1</source>
          <target>friend declaration of {$arg0} does not match any declaration in {$arg1}</target>
        </segment>
      </unit>
      <unit id="4877" name="err_qualified_function_typeid">
        <segment>
          <source>type operand %0 of 'typeid' cannot have '%1' qualifier</source>
          <target>type operand {$arg0} of 'typeid' cannot have '{$arg1}' qualifier</target>
        </segment>
      </unit>
      <unit id="4878" name="err_qualified_member_nonclass">
        <segment>
          <source>qualified member access refers to a member in %0</source>
          <target>qualified member access refers to a member in {$arg0}</target>
        </segment>
      </unit>
      <unit id="4879" name="err_qualified_member_of_unrelated">
        <segment>
          <source>%q0 is not a member of class %1</source>
          <target>{$arg0 :q} is not a member of class {$arg1}</target>
        </segment>
      </unit>
      <unit id="4880" name="err_qualified_objc_access">
        <segment>
          <source state="initial">%select{property|instance variable}0 access cannot be qualified with %1</source>
          <target>{$arg0 :select s0=|property| s1=|instance variable|} access cannot be qualified with {$arg1}</target>
        </segment>
      </unit>
      <unit id="4881" name="err_qualified_objc_catch_parm">
        <segment>
          <source>@catch parameter declarator cannot be qualified</source>
          <target>@catch parameter declarator cannot be qualified</target>
        </segment>
      </unit>
      <unit id="4882" name="err_qualified_param_declarator">
        <segment>
          <source>parameter declarator cannot be qualified</source>
          <target>parameter declarator cannot be qualified</target>
        </segment>
      </unit>
      <unit id="4883" name="err_qualified_typedef_declarator">
        <segment>
          <source>typedef declarator cannot be qualified</source>
          <target>typedef declarator cannot be qualified</target>
        </segment>
      </unit>
      <unit id="4884" name="err_range_on_array_parameter">
        <segment>
          <source>cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2</source>
          <target>cannot build range expression with array function parameter {$arg0} since parameter with array type {$arg1} is treated as pointer type {$arg2}</target>
        </segment>
      </unit>
      <unit id="4885" name="err_readonly_message_assignment">
        <segment>
          <source>assigning to 'readonly' return result of an Objective-C message not allowed</source>
          <target>assigning to 'readonly' return result of an Objective-C message not allowed</target>
        </segment>
      </unit>
      <unit id="4886" name="err_realimag_invalid_type">
        <segment>
          <source>invalid type %0 to %1 operator</source>
          <target>invalid type {$arg0} to {$arg1} operator</target>
        </segment>
      </unit>
      <unit id="4887" name="err_record_with_pointers_kernel_param">
        <segment>
          <source>%select{struct|union}0 kernel parameters may not contain pointers</source>
          <target>{$arg0 :select s0=|struct| s1=|union|} kernel parameters may not contain pointers</target>
        </segment>
      </unit>
      <unit id="4888" name="err_recursive_concept">
        <segment>
          <source>a concept definition cannot refer to itself</source>
          <target>a concept definition cannot refer to itself</target>
        </segment>
      </unit>
      <unit id="4889" name="err_recursive_default_argument">
        <segment>
          <source>recursive evaluation of default argument</source>
          <target>recursive evaluation of default argument</target>
        </segment>
      </unit>
      <unit id="4890" name="err_recursive_superclass">
        <segment>
          <source>trying to recursively use %0 as superclass of %1</source>
          <target>trying to recursively use {$arg0} as superclass of {$arg1}</target>
        </segment>
      </unit>
      <unit id="4891" name="err_redeclaration_different_type">
        <segment>
          <source>redeclaration of %0 with a different type%diff{: $ vs $|}1,2</source>
          <target>redeclaration of {$arg0} with a different type%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="4892" name="err_redeclaration_non_exported">
        <segment>
          <source>cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1</source>
          <target>cannot export redeclaration {$arg0} here since the previous declaration {$arg1 :select s0=|is not exported| s1=|has internal linkage| s2=|has module linkage|}</target>
        </segment>
      </unit>
      <unit id="4893" name="err_redefinition">
        <segment>
          <source>redefinition of %0</source>
          <target>redefinition of {$arg0}</target>
        </segment>
      </unit>
      <unit id="4894" name="err_redefinition_different_concept">
        <segment>
          <source>redefinition of concept %0 with different template parameters or requirements</source>
          <target>redefinition of concept {$arg0} with different template parameters or requirements</target>
        </segment>
      </unit>
      <unit id="4895" name="err_redefinition_different_kind">
        <segment>
          <source>redefinition of %0 as different kind of symbol</source>
          <target>redefinition of {$arg0} as different kind of symbol</target>
        </segment>
      </unit>
      <unit id="4896" name="err_redefinition_different_namespace_alias">
        <segment>
          <source>redefinition of %0 as an alias for a different namespace</source>
          <target>redefinition of {$arg0} as an alias for a different namespace</target>
        </segment>
      </unit>
      <unit id="4897" name="err_redefinition_different_type">
        <segment>
          <source>redefinition of %0 with a different type%diff{: $ vs $|}1,2</source>
          <target>redefinition of {$arg0} with a different type%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="4898" name="err_redefinition_different_typedef">
        <segment>
          <source>%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2</source>
          <target>{$arg0 :select s0=|typedef| s1=|type alias| s2=|type alias template|} redefinition with different types%diff{ ($ vs $)|}1,2</target>
        </segment>
      </unit>
      <unit id="4899" name="err_redefinition_extern_inline">
        <segment>
          <source>redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1</source>
          <target>redefinition of a 'extern inline' function {$arg0} is not supported in {$arg1 :select s0=|C99 mode| s1=|C++|}</target>
        </segment>
      </unit>
      <unit id="4900" name="err_redefinition_of_enumerator">
        <segment>
          <source>redefinition of enumerator %0</source>
          <target>redefinition of enumerator {$arg0}</target>
        </segment>
      </unit>
      <unit id="4901" name="err_redefinition_of_label">
        <segment>
          <source>redefinition of label %0</source>
          <target>redefinition of label {$arg0}</target>
        </segment>
      </unit>
      <unit id="4902" name="err_redefinition_variably_modified_typedef">
        <segment>
          <source>redefinition of %select{typedef|type alias}0 for variably-modified type %1</source>
          <target>redefinition of {$arg0 :select s0=|typedef| s1=|type alias|} for variably-modified type {$arg1}</target>
        </segment>
      </unit>
      <unit id="4903" name="err_reduction_op_mismatch">
        <segment>
          <source>OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)</source>
          <target>OpenACC 'reduction' variable must have the same operator in all nested constructs ({$arg0} vs {$arg1})</target>
        </segment>
      </unit>
      <unit id="4904" name="err_ref_array_type">
        <segment>
          <source>cannot refer to declaration with an array type inside block</source>
          <target>cannot refer to declaration with an array type inside block</target>
        </segment>
      </unit>
      <unit id="4905" name="err_ref_bad_target">
        <segment>
          <source>reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function</source>
          <target>reference to {$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} {$arg1 :select s0=|function| s1=|variable|} {$arg2} in {$arg3 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function</target>
        </segment>
      </unit>
      <unit id="4906" name="err_ref_bad_target_global_initializer">
        <segment>
          <source>reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer</source>
          <target>reference to {$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function {$arg1} in global initializer</target>
        </segment>
      </unit>
      <unit id="4907" name="err_ref_flexarray_type">
        <segment>
          <source>cannot refer to declaration of structure variable with flexible array member inside block</source>
          <target>cannot refer to declaration of structure variable with flexible array member inside block</target>
        </segment>
      </unit>
      <unit id="4908" name="err_ref_init_ambiguous">
        <segment>
          <source>reference initialization of type %0 with initializer of type %1 is ambiguous</source>
          <target>reference initialization of type {$arg0} with initializer of type {$arg1} is ambiguous</target>
        </segment>
      </unit>
      <unit id="4909" name="err_ref_non_value">
        <segment>
          <source>%0 does not refer to a value</source>
          <target>{$arg0} does not refer to a value</target>
        </segment>
      </unit>
      <unit id="4910" name="err_ref_qualifier_comparison_operator">
        <segment>
          <source>ref-qualifier '&amp;&amp;' is not allowed on a defaulted comparison operator</source>
          <target>ref-qualifier '&amp;&amp;' is not allowed on a defaulted comparison operator</target>
        </segment>
      </unit>
      <unit id="4911" name="err_ref_qualifier_constructor">
        <segment>
          <source>ref-qualifier '%select{&amp;&amp;|&amp;}0' is not allowed on a constructor</source>
          <target>ref-qualifier '{$arg0 :select s0=|&amp;&amp;| s1=|&amp;|}' is not allowed on a constructor</target>
        </segment>
      </unit>
      <unit id="4912" name="err_ref_qualifier_destructor">
        <segment>
          <source>ref-qualifier '%select{&amp;&amp;|&amp;}0' is not allowed on a destructor</source>
          <target>ref-qualifier '{$arg0 :select s0=|&amp;&amp;| s1=|&amp;|}' is not allowed on a destructor</target>
        </segment>
      </unit>
      <unit id="4913" name="err_ref_qualifier_overload">
        <segment>
          <source>cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&amp;'|with ref-qualifier '&amp;&amp;'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&amp;'|with ref-qualifier '&amp;&amp;'}1</source>
          <target>cannot overload a member function {$arg0 :select s0=|without a ref-qualifier| s1=|with ref-qualifier '&amp;'| s2=|with ref-qualifier '&amp;&amp;'|} with a member function {$arg1 :select s0=|without a ref-qualifier| s1=|with ref-qualifier '&amp;'| s2=|with ref-qualifier '&amp;&amp;'|}</target>
        </segment>
      </unit>
      <unit id="4914" name="err_ref_vm_type">
        <segment>
          <source>cannot refer to declaration with a variably modified type inside block</source>
          <target>cannot refer to declaration with a variably modified type inside block</target>
        </segment>
      </unit>
      <unit id="4915" name="err_reference_bind_drops_quals">
        <segment>
          <source>binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2</source>
          <target>binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops {$arg3} qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2</target>
        </segment>
      </unit>
      <unit id="4916" name="err_reference_bind_failed">
        <segment>
          <source>reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3</source>
          <target>reference %diff{to {$arg1 :select s0=|type| s1=|incomplete type|} $ could not bind to an {$arg2 :select s0=|rvalue| s1=|lvalue|} of type $|could not bind to {$arg0 :select s0=|rvalue| s1=|lvalue}2 of incompatible type|},3</target>
        </segment>
      </unit>
      <unit id="4917" name="err_reference_bind_init_list">
        <segment>
          <source>reference to type %0 cannot bind to an initializer list</source>
          <target>reference to type {$arg0} cannot bind to an initializer list</target>
        </segment>
      </unit>
      <unit id="4918" name="err_reference_bind_temporary_addrspace">
        <segment>
          <source>reference of type %0 cannot bind to a temporary object because of address space mismatch</source>
          <target>reference of type {$arg0} cannot bind to a temporary object because of address space mismatch</target>
        </segment>
      </unit>
      <unit id="4919" name="err_reference_bind_to_bitfield">
        <segment>
          <source>%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} reference cannot bind to bit-field{$arg2 :select s0=|| s1=| {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="4920" name="err_reference_bind_to_bitfield_in_cce">
        <segment>
          <source>reference cannot bind to bit-field in converted constant expression</source>
          <target>reference cannot bind to bit-field in converted constant expression</target>
        </segment>
      </unit>
      <unit id="4921" name="err_reference_bind_to_matrix_element">
        <segment>
          <source>%select{non-const|volatile}0 reference cannot bind to matrix element</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} reference cannot bind to matrix element</target>
        </segment>
      </unit>
      <unit id="4922" name="err_reference_bind_to_vector_element">
        <segment>
          <source>%select{non-const|volatile}0 reference cannot bind to vector element</source>
          <target>{$arg0 :select s0=|non-const| s1=|volatile|} reference cannot bind to vector element</target>
        </segment>
      </unit>
      <unit id="4923" name="err_reference_capture_with_reference_default">
        <segment>
          <source>'&amp;' cannot precede a capture when the capture default is '&amp;'</source>
          <target>'&amp;' cannot precede a capture when the capture default is '&amp;'</target>
        </segment>
      </unit>
      <unit id="4924" name="err_reference_has_multiple_inits">
        <segment>
          <source>reference cannot be initialized with multiple values</source>
          <target>reference cannot be initialized with multiple values</target>
        </segment>
      </unit>
      <unit id="4925" name="err_reference_pipe_type">
        <segment>
          <source>pipes packet types cannot be of reference type</source>
          <target>pipes packet types cannot be of reference type</target>
        </segment>
      </unit>
      <unit id="4926" name="err_reference_to_function_with_unsatisfied_constraints">
        <segment>
          <source>invalid reference to function %0: constraints not satisfied</source>
          <target>invalid reference to function {$arg0}: constraints not satisfied</target>
        </segment>
      </unit>
      <unit id="4927" name="err_reference_to_local_in_enclosing_context">
        <segment>
          <source>reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2</source>
          <target>reference to local {$arg1 :select s0=|variable| s1=|binding|} {$arg0} declared in enclosing {$arg2 :select s0=|{$arg3}| s1=|block literal| s2=|lambda expression| s3=|context|}</target>
        </segment>
      </unit>
      <unit id="4928" name="err_reference_to_void">
        <segment>
          <source>cannot form a reference to 'void'</source>
          <target>cannot form a reference to 'void'</target>
        </segment>
      </unit>
      <unit id="4929" name="err_reference_var_requires_init">
        <segment>
          <source>declaration of reference variable %0 requires an initializer</source>
          <target>declaration of reference variable {$arg0} requires an initializer</target>
        </segment>
      </unit>
      <unit id="4930" name="err_reference_without_init">
        <segment>
          <source>reference to type %0 requires an initializer</source>
          <target>reference to type {$arg0} requires an initializer</target>
        </segment>
      </unit>
      <unit id="4931" name="err_regparm_mismatch">
        <segment>
          <source>function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute</source>
          <target>function declared with regparm({$arg0}) attribute was previously declared %plural{0:without the regparm|:with the regparm({$arg1})}1 attribute</target>
        </segment>
      </unit>
      <unit id="4932" name="err_repeat_attribute">
        <segment>
          <source>%0 attribute cannot be repeated</source>
          <target>{$arg0} attribute cannot be repeated</target>
        </segment>
      </unit>
      <unit id="4933" name="err_require_constant_init_failed">
        <segment>
          <source>variable does not have a constant initializer</source>
          <target>variable does not have a constant initializer</target>
        </segment>
      </unit>
      <unit id="4934" name="err_requires_expr_local_parameter_default_argument">
        <segment>
          <source>default arguments not allowed for parameters of a requires expression</source>
          <target>default arguments not allowed for parameters of a requires expression</target>
        </segment>
      </unit>
      <unit id="4935" name="err_requires_expr_parameter_referenced_in_evaluated_context">
        <segment>
          <source>constraint variable %0 cannot be used in an evaluated context</source>
          <target>constraint variable {$arg0} cannot be used in an evaluated context</target>
        </segment>
      </unit>
      <unit id="4936" name="err_restricted_superclass_mismatch">
        <segment>
          <source>cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute</source>
          <target>cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute</target>
        </segment>
      </unit>
      <unit id="4937" name="err_ret_local_block">
        <segment>
          <source>returning block that lives on the local stack</source>
          <target>returning block that lives on the local stack</target>
        </segment>
      </unit>
      <unit id="4938" name="err_ret_local_temp_ref">
        <segment>
          <source>returning reference to local temporary object</source>
          <target>returning reference to local temporary object</target>
        </segment>
      </unit>
      <unit id="4939" name="err_rethrow_used_outside_catch">
        <segment>
          <source>@throw (rethrow) used outside of a @catch block</source>
          <target>@throw (rethrow) used outside of a @catch block</target>
        </segment>
      </unit>
      <unit id="4940" name="err_return_block_has_expr">
        <segment>
          <source>void block should not return a value</source>
          <target>void block should not return a value</target>
        </segment>
      </unit>
      <unit id="4941" name="err_return_in_captured_stmt">
        <segment>
          <source>cannot return from %0</source>
          <target>cannot return from {$arg0}</target>
        </segment>
      </unit>
      <unit id="4942" name="err_return_in_constructor_handler">
        <segment>
          <source>return in the catch of a function try block of a constructor is illegal</source>
          <target>return in the catch of a function try block of a constructor is illegal</target>
        </segment>
      </unit>
      <unit id="4943" name="err_return_in_coroutine">
        <segment>
          <source>return statement not allowed in coroutine; did you mean 'co_return'?</source>
          <target>return statement not allowed in coroutine; did you mean 'co_return'?</target>
        </segment>
      </unit>
      <unit id="4944" name="err_return_init_list">
        <segment>
          <source>%select{void function|void method|constructor|destructor}1 %0 must not return a value</source>
          <target>{$arg1 :select s0=|void function| s1=|void method| s2=|constructor| s3=|destructor|} {$arg0} must not return a value</target>
        </segment>
      </unit>
      <unit id="4945" name="err_return_value_with_address_space">
        <segment>
          <source>return type cannot be qualified with address space</source>
          <target>return type cannot be qualified with address space</target>
        </segment>
      </unit>
      <unit id="4946" name="err_riscv_attribute_interrupt_invalid_combination">
        <segment>
          <source>RISC-V 'interrupt' attribute contains invalid combination of interrupt types</source>
          <target>RISC-V 'interrupt' attribute contains invalid combination of interrupt types</target>
        </segment>
      </unit>
      <unit id="4947" name="err_riscv_attribute_interrupt_requires_extension">
        <segment>
          <source>RISC-V 'interrupt' attribute '%0' requires extension '%1'</source>
          <target>RISC-V 'interrupt' attribute '{$arg0}' requires extension '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="4948" name="err_riscv_builtin_invalid_lmul">
        <segment>
          <source>LMUL argument must be in the range [0,3] or [5,7]</source>
          <target>LMUL argument must be in the range [0,3] or [5,7]</target>
        </segment>
      </unit>
      <unit id="4949" name="err_riscv_builtin_requires_extension">
        <segment>
          <source>builtin requires%select{| at least one of the following extensions}0: %1</source>
          <target>builtin requires{$arg0 :select s0=|| s1=| at least one of the following extensions|}: {$arg1}</target>
        </segment>
      </unit>
      <unit id="4950" name="err_riscv_type_requires_extension">
        <segment>
          <source>RISC-V type %0 requires the '%1' extension</source>
          <target>RISC-V type {$arg0} requires the '{$arg1}' extension</target>
        </segment>
      </unit>
      <unit id="4951" name="err_root_class_cannot_use_super">
        <segment>
          <source>%0 cannot use 'super' because it is a root class</source>
          <target>{$arg0} cannot use 'super' because it is a root class</target>
        </segment>
      </unit>
      <unit id="4952" name="err_rotation_argument_to_cadd">
        <segment>
          <source>argument should be the value 90 or 270</source>
          <target>argument should be the value 90 or 270</target>
        </segment>
      </unit>
      <unit id="4953" name="err_rotation_argument_to_cmla">
        <segment>
          <source>argument should be the value 0, 90, 180 or 270</source>
          <target>argument should be the value 0, 90, 180 or 270</target>
        </segment>
      </unit>
      <unit id="4954" name="err_rref_in_exception_spec">
        <segment>
          <source>rvalue reference type %0 is not allowed in exception specification</source>
          <target>rvalue reference type {$arg0} is not allowed in exception specification</target>
        </segment>
      </unit>
      <unit id="4955" name="err_sampler_argument_required">
        <segment>
          <source>sampler_t variable required - got %0</source>
          <target>sampler_t variable required - got {$arg0}</target>
        </segment>
      </unit>
      <unit id="4956" name="err_sampler_initializer_not_integer">
        <segment>
          <source>sampler_t initialization requires 32-bit integer, not %0</source>
          <target>sampler_t initialization requires 32-bit integer, not {$arg0}</target>
        </segment>
      </unit>
      <unit id="4957" name="err_second_argument_to_cwsc_not_pointer">
        <segment>
          <source>second argument to __builtin_call_with_static_chain must be of pointer type</source>
          <target>second argument to __builtin_call_with_static_chain must be of pointer type</target>
        </segment>
      </unit>
      <unit id="4958" name="err_second_parameter_to_va_arg_abstract">
        <segment>
          <source>second argument to 'va_arg' is of abstract type %0</source>
          <target>second argument to 'va_arg' is of abstract type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4959" name="err_second_parameter_to_va_arg_incomplete">
        <segment>
          <source>second argument to 'va_arg' is of incomplete type %0</source>
          <target>second argument to 'va_arg' is of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4960" name="err_section_conflict">
        <segment>
          <source>%0 causes a section type conflict with %1</source>
          <target>{$arg0} causes a section type conflict with {$arg1}</target>
        </segment>
      </unit>
      <unit id="4961" name="err_seh_in_a_coroutine_with_cxx_exceptions">
        <segment>
          <source>cannot use SEH '__try' in a coroutine when C++ exceptions are enabled</source>
          <target>cannot use SEH '__try' in a coroutine when C++ exceptions are enabled</target>
        </segment>
      </unit>
      <unit id="4962" name="err_seh_try_outside_functions">
        <segment>
          <source>cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls</source>
          <target>cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls</target>
        </segment>
      </unit>
      <unit id="4963" name="err_seh_try_unsupported">
        <segment>
          <source>SEH '__try' is not supported on this target</source>
          <target>SEH '__try' is not supported on this target</target>
        </segment>
      </unit>
      <unit id="4964" name="err_selected_explicit_constructor">
        <segment>
          <source>chosen constructor is explicit in copy-initialization</source>
          <target>chosen constructor is explicit in copy-initialization</target>
        </segment>
      </unit>
      <unit id="4965" name="err_selector_element_const_type">
        <segment>
          <source>selector element of type %0 cannot be a constant lvalue expression</source>
          <target>selector element of type {$arg0} cannot be a constant lvalue expression</target>
        </segment>
      </unit>
      <unit id="4966" name="err_selector_element_not_lvalue">
        <segment>
          <source>selector element is not a valid lvalue</source>
          <target>selector element is not a valid lvalue</target>
        </segment>
      </unit>
      <unit id="4967" name="err_selector_element_type">
        <segment>
          <source>selector element type %0 is not a valid object</source>
          <target>selector element type {$arg0} is not a valid object</target>
        </segment>
      </unit>
      <unit id="4968" name="err_setter_type_void">
        <segment>
          <source>type of setter must be void</source>
          <target>type of setter must be void</target>
        </segment>
      </unit>
      <unit id="4969" name="err_setting_eval_method_used_in_unsafe_context">
        <segment>
          <source>%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1</source>
          <target>{$arg0 :select s0=|'#pragma clang fp eval_method'| s1=|option 'ffp-eval-method'|} cannot be used with {$arg1 :select s0=|option 'fapprox-func'| s1=|option 'mreassociate'| s2=|option 'freciprocal'| s3=|option 'ffp-eval-method'| s4=|'#pragma clang fp reassociate'| s5=|'#pragma clang fp reciprocal'|}</target>
        </segment>
      </unit>
      <unit id="4970" name="err_shared_var_init">
        <segment>
          <source>initialization is not supported for __shared__ variables</source>
          <target>initialization is not supported for __shared__ variables</target>
        </segment>
      </unit>
      <unit id="4971" name="err_shift_rhs_only_vector">
        <segment>
          <source>requested shift is a vector of type %0 but the first operand is not a vector (%1)</source>
          <target>requested shift is a vector of type {$arg0} but the first operand is not a vector ({$arg1})</target>
        </segment>
      </unit>
      <unit id="4972" name="err_shufflevector_argument_too_large">
        <segment>
          <source>index for __builtin_shufflevector must be less than the total number of vector elements</source>
          <target>index for __builtin_shufflevector must be less than the total number of vector elements</target>
        </segment>
      </unit>
      <unit id="4973" name="err_shufflevector_minus_one_is_undefined_behavior_constexpr">
        <segment>
          <source>index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context</source>
          <target>index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position {$arg0} is not permitted in a constexpr context</target>
        </segment>
      </unit>
      <unit id="4974" name="err_shufflevector_nonconstant_argument">
        <segment>
          <source>index for __builtin_shufflevector must be a constant integer</source>
          <target>index for __builtin_shufflevector must be a constant integer</target>
        </segment>
      </unit>
      <unit id="4975" name="err_sizeless_in_exception_spec">
        <segment>
          <source>%select{|reference to }0sizeless type %1 is not allowed in exception specification</source>
          <target>{$arg0 :select s0=|| s1=|reference to |}sizeless type {$arg1} is not allowed in exception specification</target>
        </segment>
      </unit>
      <unit id="4976" name="err_sizeless_nonlocal">
        <segment>
          <source>non-local variable with sizeless type %0</source>
          <target>non-local variable with sizeless type {$arg0}</target>
        </segment>
      </unit>
      <unit id="4977" name="err_sizeof_alignof_function_type">
        <segment>
          <source>invalid application of '%0' to a function type</source>
          <target>invalid application of '{$arg0}' to a function type</target>
        </segment>
      </unit>
      <unit id="4978" name="err_sizeof_alignof_incomplete_or_sizeless_type">
        <segment>
          <source>invalid application of '%0' to %select{an incomplete|sizeless}1 type %2</source>
          <target>invalid application of '{$arg0}' to {$arg1 :select s0=|an incomplete| s1=|sizeless|} type {$arg2}</target>
        </segment>
      </unit>
      <unit id="4979" name="err_sizeof_alignof_typeof_bitfield">
        <segment>
          <source>invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field</source>
          <target>invalid application of '{$arg0 :select s0=|sizeof| s1=|alignof| s2=|typeof| s3=|typeof_unqual|}' to bit-field</target>
        </segment>
      </unit>
      <unit id="4980" name="err_sizeof_nonfragile_interface">
        <segment>
          <source>application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform</source>
          <target>application of '{$arg1 :select s0=|alignof| s1=|sizeof|}' to interface {$arg0} is not supported on this architecture and platform</target>
        </segment>
      </unit>
      <unit id="4981" name="err_sizeof_pack_no_pack_name_suggest">
        <segment>
          <source>%0 does not refer to the name of a parameter pack; did you mean %1?</source>
          <target>{$arg0} does not refer to the name of a parameter pack; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="4982" name="err_sme_attr_mismatch">
        <segment>
          <source>function declared %0 was previously declared %1, which has different SME function attributes</source>
          <target>function declared {$arg0} was previously declared {$arg1}, which has different SME function attributes</target>
        </segment>
      </unit>
      <unit id="4983" name="err_sme_call_in_non_sme_target">
        <segment>
          <source>call to a streaming function requires 'sme'</source>
          <target>call to a streaming function requires 'sme'</target>
        </segment>
      </unit>
      <unit id="4984" name="err_sme_definition_using_sm_in_non_sme_target">
        <segment>
          <source>function executed in streaming-SVE mode requires 'sme'</source>
          <target>function executed in streaming-SVE mode requires 'sme'</target>
        </segment>
      </unit>
      <unit id="4985" name="err_sme_definition_using_za_in_non_sme_target">
        <segment>
          <source>function using ZA state requires 'sme'</source>
          <target>function using ZA state requires 'sme'</target>
        </segment>
      </unit>
      <unit id="4986" name="err_sme_definition_using_zt0_in_non_sme2_target">
        <segment>
          <source>function using ZT0 state requires 'sme2'</source>
          <target>function using ZT0 state requires 'sme2'</target>
        </segment>
      </unit>
      <unit id="4987" name="err_sme_openmp_captured_region">
        <segment>
          <source>OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0</source>
          <target>OpenMP captured regions are not yet supported in {$arg0 :select s0=|streaming functions| s1=|functions with ZA state| s2=|functions with ZT0 state|}</target>
        </segment>
      </unit>
      <unit id="4988" name="err_sme_unimplemented_za_save_restore">
        <segment>
          <source>call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented</source>
          <target>call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented</target>
        </segment>
      </unit>
      <unit id="4989" name="err_sme_unsupported_agnostic_new">
        <segment>
          <source>__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")</source>
          <target>__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")</target>
        </segment>
      </unit>
      <unit id="4990" name="err_sme_za_call_no_za_state">
        <segment>
          <source>call to a shared ZA function requires the caller to have ZA state</source>
          <target>call to a shared ZA function requires the caller to have ZA state</target>
        </segment>
      </unit>
      <unit id="4991" name="err_sme_zt0_call_no_zt0_state">
        <segment>
          <source>call to a shared ZT0 function requires the caller to have ZT0 state</source>
          <target>call to a shared ZT0 function requires the caller to have ZT0 state</target>
        </segment>
      </unit>
      <unit id="4992" name="err_spaceship_argument_narrowing">
        <segment>
          <source>argument to 'operator&lt;=&gt;' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0</source>
          <target>argument to 'operator&lt;=&gt;' {$arg0 :select s0=|cannot be narrowed from type {$arg1} to {$arg2}| s1=|evaluates to {$arg1}, which cannot be narrowed to type {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="4993" name="err_spec_member_not_instantiated">
        <segment>
          <source>specialization of member %q0 does not specialize an instantiated member</source>
          <target>specialization of member {$arg0 :q} does not specialize an instantiated member</target>
        </segment>
      </unit>
      <unit id="4994" name="err_specialization_after_instantiation">
        <segment>
          <source>explicit specialization of %0 after instantiation</source>
          <target>explicit specialization of {$arg0} after instantiation</target>
        </segment>
      </unit>
      <unit id="4995" name="err_specialization_not_primary_template">
        <segment>
          <source>cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization</source>
          <target>cannot reference member of primary template because deduced class template specialization {$arg0} is {$arg1 :select s0=|instantiated from a partial| s1=|an explicit|} specialization</target>
        </segment>
      </unit>
      <unit id="4996" name="err_specialize_member_of_template">
        <segment>
          <source>cannot specialize %select{|(with 'template&lt;&gt;') }0a member of an unspecialized template</source>
          <target>cannot specialize {$arg0 :select s0=|| s1=|(with 'template&lt;&gt;') |}a member of an unspecialized template</target>
        </segment>
      </unit>
      <unit id="4997" name="err_standalone_class_nested_name_specifier">
        <segment>
          <source>forward declaration of %0 cannot have a nested name specifier</source>
          <target>forward declaration of {$arg0} cannot have a nested name specifier</target>
        </segment>
      </unit>
      <unit id="4998" name="err_static_assert_expression_is_not_constant">
        <segment>
          <source>static assertion expression is not an integral constant expression</source>
          <target>static assertion expression is not an integral constant expression</target>
        </segment>
      </unit>
      <unit id="4999" name="err_static_assert_failed">
        <segment>
          <source>static assertion failed%select{: %1|}0</source>
          <target>static assertion failed{$arg0 :select s0=|: {$arg1}| s1=||}</target>
        </segment>
      </unit>
      <unit id="5000" name="err_static_assert_requirement_failed">
        <segment>
          <source>static assertion failed due to requirement '%0'%select{: %2|}1</source>
          <target>static assertion failed due to requirement '{$arg0}'{$arg1 :select s0=|: {$arg2}| s1=||}</target>
        </segment>
      </unit>
      <unit id="5001" name="err_static_block_func">
        <segment>
          <source>function declared in block scope cannot have 'static' storage class</source>
          <target>function declared in block scope cannot have 'static' storage class</target>
        </segment>
      </unit>
      <unit id="5002" name="err_static_data_member_not_allowed_in_anon_struct">
        <segment>
          <source>static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1</source>
          <target>static data member {$arg0} not allowed in anonymous {$arg1 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|}</target>
        </segment>
      </unit>
      <unit id="5003" name="err_static_data_member_not_allowed_in_local_class">
        <segment>
          <source>static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1</source>
          <target>static data member {$arg0} not allowed in local {$arg2 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="5004" name="err_static_data_member_reinitialization">
        <segment>
          <source>static data member %0 already has an initializer</source>
          <target>static data member {$arg0} already has an initializer</target>
        </segment>
      </unit>
      <unit id="5005" name="err_static_downcast_via_virtual">
        <segment>
          <source>cannot cast %0 to %1 via virtual base %2</source>
          <target>cannot cast {$arg0} to {$arg1} via virtual base {$arg2}</target>
        </segment>
      </unit>
      <unit id="5006" name="err_static_function_scope">
        <segment>
          <source>variables in function scope cannot be declared static</source>
          <target>variables in function scope cannot be declared static</target>
        </segment>
      </unit>
      <unit id="5007" name="err_static_illegal_in_new">
        <segment>
          <source>the 'static' modifier for the array size is not legal in new expressions</source>
          <target>the 'static' modifier for the array size is not legal in new expressions</target>
        </segment>
      </unit>
      <unit id="5008" name="err_static_kernel">
        <segment>
          <source>kernel functions cannot be declared static</source>
          <target>kernel functions cannot be declared static</target>
        </segment>
      </unit>
      <unit id="5009" name="err_static_main">
        <segment>
          <source>'main' is not allowed to be declared static</source>
          <target>'main' is not allowed to be declared static</target>
        </segment>
      </unit>
      <unit id="5010" name="err_static_non_static">
        <segment>
          <source>static declaration of %0 follows non-static declaration</source>
          <target>static declaration of {$arg0} follows non-static declaration</target>
        </segment>
      </unit>
      <unit id="5011" name="err_static_not_bitfield">
        <segment>
          <source>static member %0 cannot be a bit-field</source>
          <target>static member {$arg0} cannot be a bit-field</target>
        </segment>
      </unit>
      <unit id="5012" name="err_static_out_of_line">
        <segment>
          <source>'static' can only be specified inside the class definition</source>
          <target>'static' can only be specified inside the class definition</target>
        </segment>
      </unit>
      <unit id="5013" name="err_static_overrides_virtual">
        <segment>
          <source>'static' member function %0 overrides a virtual function in a base class</source>
          <target>'static' member function {$arg0} overrides a virtual function in a base class</target>
        </segment>
      </unit>
      <unit id="5014" name="err_statically_allocated_object">
        <segment>
          <source>interface type cannot be statically allocated</source>
          <target>interface type cannot be statically allocated</target>
        </segment>
      </unit>
      <unit id="5015" name="err_std_compare_type_not_supported">
        <segment>
          <source>standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1</source>
          <target>standard library implementation of {$arg0} is not supported; {$arg1 :select s0=|member '{$arg2}' does not have expected form| s1=|member '{$arg2}' is missing| s2=|the type is not trivially copyable| s3=|the type does not have the expected form|}</target>
        </segment>
      </unit>
      <unit id="5016" name="err_std_initializer_list_malformed">
        <segment>
          <source>%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'</source>
          <target>{$arg0} layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'</target>
        </segment>
      </unit>
      <unit id="5017" name="err_std_source_location_impl_malformed">
        <segment>
          <source>'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'</source>
          <target>'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'</target>
        </segment>
      </unit>
      <unit id="5018" name="err_std_source_location_impl_not_found">
        <segment>
          <source>'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called</source>
          <target>'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called</target>
        </segment>
      </unit>
      <unit id="5019" name="err_std_type_trait_not_class_template">
        <segment>
          <source>unsupported standard library implementation: 'std::%0' is not a class template</source>
          <target>unsupported standard library implementation: 'std::{$arg0}' is not a class template</target>
        </segment>
      </unit>
      <unit id="5020" name="err_stmt_expr_in_default_arg">
        <segment>
          <source>default %select{argument|non-type template argument}0 may not use a GNU statement expression</source>
          <target>default {$arg0 :select s0=|argument| s1=|non-type template argument|} may not use a GNU statement expression</target>
        </segment>
      </unit>
      <unit id="5021" name="err_storage_class_for_static_member">
        <segment>
          <source>static data member definition cannot specify a storage class</source>
          <target>static data member definition cannot specify a storage class</target>
        </segment>
      </unit>
      <unit id="5022" name="err_storage_spec_on_catch_parm">
        <segment>
          <source>@catch parameter cannot have storage specifier '%0'</source>
          <target>@catch parameter cannot have storage specifier '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="5023" name="err_storageclass_invalid_for_member">
        <segment>
          <source>storage class specified for a member declaration</source>
          <target>storage class specified for a member declaration</target>
        </segment>
      </unit>
      <unit id="5024" name="err_store_value_to_reg">
        <segment>
          <source state="initial">impossible constraint in asm: cannot store value into a register</source>
          <target>impossible constraint in asm: cannot store value into a register</target>
        </segment>
      </unit>
      <unit id="5025" name="err_strong_property">
        <segment>
          <source>existing instance variable %1 for strong property %0 may not be __weak</source>
          <target>existing instance variable {$arg1} for strong property {$arg0} may not be __weak</target>
        </segment>
      </unit>
      <unit id="5026" name="err_subscript_function_type">
        <segment>
          <source>subscript of pointer to function type %0</source>
          <target>subscript of pointer to function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5027" name="err_subscript_incomplete_or_sizeless_type">
        <segment>
          <source>subscript of pointer to %select{incomplete|sizeless}0 type %1</source>
          <target>subscript of pointer to {$arg0 :select s0=|incomplete| s1=|sizeless|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5028" name="err_subscript_nonfragile_interface">
        <segment>
          <source>subscript requires size of interface %0, which is not constant for this architecture and platform</source>
          <target>subscript requires size of interface {$arg0}, which is not constant for this architecture and platform</target>
        </segment>
      </unit>
      <unit id="5029" name="err_subscript_svbool_t">
        <segment>
          <source>subscript of svbool_t is not allowed</source>
          <target>subscript of svbool_t is not allowed</target>
        </segment>
      </unit>
      <unit id="5030" name="err_super_in_lambda_unsupported">
        <segment>
          <source>use of '__super' inside a lambda is unsupported</source>
          <target>use of '__super' inside a lambda is unsupported</target>
        </segment>
      </unit>
      <unit id="5031" name="err_sve_vector_in_non_streaming_function">
        <segment>
          <source>SVE vector type %0 cannot be used in a non-streaming function</source>
          <target>SVE vector type {$arg0} cannot be used in a non-streaming function</target>
        </segment>
      </unit>
      <unit id="5032" name="err_sve_vector_in_non_sve_target">
        <segment>
          <source>SVE vector type %0 cannot be used in a target without sve</source>
          <target>SVE vector type {$arg0} cannot be used in a target without sve</target>
        </segment>
      </unit>
      <unit id="5033" name="err_swift_abi_parameter_wrong_type">
        <segment>
          <source>'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2</source>
          <target>'{$arg0}' parameter must have pointer{$arg1 :select s0=|| s1=| to unqualified pointer|} type; type here is {$arg2}</target>
        </segment>
      </unit>
      <unit id="5034" name="err_swift_async_bad_block_type">
        <segment>
          <source>'swift_async' completion handler parameter must have block type returning 'void', type here is %0</source>
          <target>'swift_async' completion handler parameter must have block type returning 'void', type here is {$arg0}</target>
        </segment>
      </unit>
      <unit id="5035" name="err_swift_async_error_no_error_parameter">
        <segment>
          <source>%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter</source>
          <target>{$arg0} attribute with 'nonnull_error' convention can only be applied to a {$arg1 :select s0=|function| s1=|method|} with a completion handler with an error parameter</target>
        </segment>
      </unit>
      <unit id="5036" name="err_swift_async_error_non_integral">
        <segment>
          <source>%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3</source>
          <target>{$arg0} attribute with '{$arg1}' convention must have an integral-typed parameter in completion handler at index {$arg2}, type here is {$arg3}</target>
        </segment>
      </unit>
      <unit id="5037" name="err_swift_async_error_without_swift_async">
        <segment>
          <source>%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'</source>
          <target>{$arg0} attribute must be applied to a {$arg1 :select s0=|function| s1=|method|} annotated with non-'none' attribute 'swift_async'</target>
        </segment>
      </unit>
      <unit id="5038" name="err_swift_async_no_access">
        <segment>
          <source>first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'</source>
          <target>first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'</target>
        </segment>
      </unit>
      <unit id="5039" name="err_swift_error_result_not_after_swift_context">
        <segment>
          <source>'swift_error_result' parameter must follow 'swift_context' parameter</source>
          <target>'swift_error_result' parameter must follow 'swift_context' parameter</target>
        </segment>
      </unit>
      <unit id="5040" name="err_swift_indirect_result_not_first">
        <segment>
          <source>'swift_indirect_result' parameters must be first parameters of function</source>
          <target>'swift_indirect_result' parameters must be first parameters of function</target>
        </segment>
      </unit>
      <unit id="5041" name="err_swift_param_attr_not_swiftcall">
        <segment>
          <source>'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1</source>
          <target>'{$arg0}' parameter can only be used with swiftcall{$arg1 :select s0=| or swiftasynccall| s1=||} calling convention{$arg1 :select s0=|| s1=|s|}</target>
        </segment>
      </unit>
      <unit id="5042" name="err_switch_explicit_conversion">
        <segment>
          <source>switch condition type %0 requires explicit conversion to %1</source>
          <target>switch condition type {$arg0} requires explicit conversion to {$arg1}</target>
        </segment>
      </unit>
      <unit id="5043" name="err_switch_incomplete_class_type">
        <segment>
          <source>switch condition has incomplete class type %0</source>
          <target>switch condition has incomplete class type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5044" name="err_switch_into_protected_scope">
        <segment>
          <source>cannot jump from switch statement to this case label</source>
          <target>cannot jump from switch statement to this case label</target>
        </segment>
      </unit>
      <unit id="5045" name="err_switch_multiple_conversions">
        <segment>
          <source>multiple conversions from switch condition type %0 to an integral or enumeration type</source>
          <target>multiple conversions from switch condition type {$arg0} to an integral or enumeration type</target>
        </segment>
      </unit>
      <unit id="5046" name="err_sycl_entry_point_after_definition">
        <segment>
          <source>'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined</source>
          <target>'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined</target>
        </segment>
      </unit>
      <unit id="5047" name="err_sycl_entry_point_deduced_return_type">
        <segment>
          <source>'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type</source>
          <target>'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type</target>
        </segment>
      </unit>
      <unit id="5048" name="err_sycl_entry_point_invalid">
        <segment>
          <source>'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0</source>
          <target>'sycl_kernel_entry_point' attribute cannot be applied to a {$arg0 :select s0=|non-static member function| s1=|variadic function| s2=|deleted function| s3=|defaulted function| s4=|constexpr function| s5=|consteval function| s6=|function declared with the 'noreturn' attribute| s7=|coroutine| s8=|function defined with a function try block|}</target>
        </segment>
      </unit>
      <unit id="5049" name="err_sycl_entry_point_invalid_redeclaration">
        <segment>
          <source>'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1</source>
          <target>'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1</target>
        </segment>
      </unit>
      <unit id="5050" name="err_sycl_entry_point_return_type">
        <segment>
          <source>'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type</source>
          <target>'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type</target>
        </segment>
      </unit>
      <unit id="5051" name="err_sycl_kernel_name_conflict">
        <segment>
          <source>'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration</source>
          <target>'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration</target>
        </segment>
      </unit>
      <unit id="5052" name="err_sycl_special_type_num_init_method">
        <segment>
          <source>types with 'sycl_special_class' attribute must have one and only one '__init' method defined</source>
          <target>types with 'sycl_special_class' attribute must have one and only one '__init' method defined</target>
        </segment>
      </unit>
      <unit id="5053" name="err_synthesize_category_decl">
        <segment>
          <source>@synthesize not allowed in a category's implementation</source>
          <target>@synthesize not allowed in a category's implementation</target>
        </segment>
      </unit>
      <unit id="5054" name="err_synthesize_on_class_property">
        <segment>
          <source>@synthesize not allowed on a class property %0</source>
          <target>@synthesize not allowed on a class property {$arg0}</target>
        </segment>
      </unit>
      <unit id="5055" name="err_synthesize_variable_sized_ivar">
        <segment>
          <source>synthesized property with variable size type %0 requires an existing instance variable</source>
          <target>synthesized property with variable size type {$arg0} requires an existing instance variable</target>
        </segment>
      </unit>
      <unit id="5056" name="err_synthesizing_arc_weak_property_disabled">
        <segment>
          <source>cannot synthesize weak property in file using manual reference counting</source>
          <target>cannot synthesize weak property in file using manual reference counting</target>
        </segment>
      </unit>
      <unit id="5057" name="err_synthesizing_arc_weak_property_no_runtime">
        <segment>
          <source>cannot synthesize weak property because the current deployment target does not support weak references</source>
          <target>cannot synthesize weak property because the current deployment target does not support weak references</target>
        </segment>
      </unit>
      <unit id="5058" name="err_systemz_invalid_tabort_code">
        <segment>
          <source>invalid transaction abort code</source>
          <target>invalid transaction abort code</target>
        </segment>
      </unit>
      <unit id="5059" name="err_tag_definition_of_typedef">
        <segment>
          <source>definition of type %0 conflicts with %select{typedef|type alias}1 of the same name</source>
          <target>definition of type {$arg0} conflicts with {$arg1 :select s0=|typedef| s1=|type alias|} of the same name</target>
        </segment>
      </unit>
      <unit id="5060" name="err_tag_index_out_of_range">
        <segment>
          <source>%select{type tag|argument}0 index %1 is greater than the number of arguments specified</source>
          <target>{$arg0 :select s0=|type tag| s1=|argument|} index {$arg1} is greater than the number of arguments specified</target>
        </segment>
      </unit>
      <unit id="5061" name="err_tag_reference_conflict">
        <segment>
          <source>implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name</source>
          <target>implicit declaration introduced by elaborated type conflicts with a {$arg0 :select s0=|non-struct type| s1=|non-class type| s2=|non-union type| s3=|non-enum type| s4=|typedef| s5=|type alias| s6=|template| s7=|type alias template| s8=|template template argument|} of the same name</target>
        </segment>
      </unit>
      <unit id="5062" name="err_tag_reference_non_tag">
        <segment>
          <source>%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier</source>
          <target>{$arg1 :select s0=|non-struct type| s1=|non-class type| s2=|non-union type| s3=|non-enum type| s4=|typedef| s5=|type alias| s6=|template| s7=|alias template| s8=|template template argument|} {$arg0} cannot be referenced with the '{$arg2 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|}' specifier</target>
        </segment>
      </unit>
      <unit id="5063" name="err_tagless_friend_type_template">
        <segment>
          <source>friend type templates must use an elaborated type</source>
          <target>friend type templates must use an elaborated type</target>
        </segment>
      </unit>
      <unit id="5064" name="err_target_clone_doesnt_match">
        <segment>
          <source>'target_clones' attribute does not match previous declaration</source>
          <target>'target_clones' attribute does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="5065" name="err_target_clone_must_have_default">
        <segment>
          <source>'target_clones' multiversioning requires a default target</source>
          <target>'target_clones' multiversioning requires a default target</target>
        </segment>
      </unit>
      <unit id="5066" name="err_target_unsupported_type">
        <segment>
          <source>%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it</source>
          <target>{$arg0} requires {$arg1 :select s0=|| s1=|{$arg2} bit size|} {$arg3} {$arg4 :select s0=|| s1=|return |}type support, but target '{$arg5}' does not support it</target>
        </segment>
      </unit>
      <unit id="5067" name="err_tcb_conflicting_attributes">
        <segment>
          <source>attributes '%0("%2")' and '%1("%2")' are mutually exclusive</source>
          <target>attributes '{$arg0}("{$arg2}")' and '{$arg1}("{$arg2}")' are mutually exclusive</target>
        </segment>
      </unit>
      <unit id="5068" name="err_temp_copy_ambiguous">
        <segment>
          <source>ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1</source>
          <target>ambiguous constructor call when {$arg0 :select s0=|copying variable| s1=|copying parameter| s2=|initializing template parameter| s3=|returning object| s4=|initializing statement expression result| s5=|throwing object| s6=|copying member subobject| s7=|copying array element| s8=|allocating object| s9=|copying temporary| s10=|initializing base subobject| s11=|initializing vector element| s12=|capturing value|} of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5069" name="err_temp_copy_deleted">
        <segment>
          <source>%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor</source>
          <target>{$arg0 :select s0=|copying variable| s1=|copying parameter| s2=|initializing template parameter| s3=|returning object| s4=|initializing statement expression result| s5=|throwing object| s6=|copying member subobject| s7=|copying array element| s8=|allocating object| s9=|copying temporary| s10=|initializing base subobject| s11=|initializing vector element| s12=|capturing value|} of type {$arg1} invokes deleted constructor</target>
        </segment>
      </unit>
      <unit id="5070" name="err_temp_copy_incomplete">
        <segment>
          <source>copying a temporary object of incomplete type %0</source>
          <target>copying a temporary object of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5071" name="err_temp_copy_no_viable">
        <segment>
          <source>no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1</source>
          <target>no viable constructor {$arg0 :select s0=|copying variable| s1=|copying parameter| s2=|initializing template parameter| s3=|returning object| s4=|initializing statement expression result| s5=|throwing object| s6=|copying member subobject| s7=|copying array element| s8=|allocating object| s9=|copying temporary| s10=|initializing base subobject| s11=|initializing vector element| s12=|capturing value|} of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5072" name="err_template_arg_address_of_non_pointer">
        <segment>
          <source>address taken in non-type template argument for template parameter of reference type %0</source>
          <target>address taken in non-type template argument for template parameter of reference type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5073" name="err_template_arg_deduced_incomplete_pack">
        <segment>
          <source>deduced incomplete pack %0 for template parameter %1</source>
          <target>deduced incomplete pack {$arg0} for template parameter {$arg1}</target>
        </segment>
      </unit>
      <unit id="5074" name="err_template_arg_field">
        <segment>
          <source>non-type template argument refers to non-static data member %0</source>
          <target>non-type template argument refers to non-static data member {$arg0}</target>
        </segment>
      </unit>
      <unit id="5075" name="err_template_arg_invalid">
        <segment>
          <source>non-type template argument '%0' is invalid</source>
          <target>non-type template argument '{$arg0}' is invalid</target>
        </segment>
      </unit>
      <unit id="5076" name="err_template_arg_list_constraints_not_satisfied">
        <segment>
          <source>constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2</source>
          <target>constraints not satisfied for {$arg0 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|template|} {$arg1}{$arg2}</target>
        </segment>
      </unit>
      <unit id="5077" name="err_template_arg_list_different_arity">
        <segment>
          <source>%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2</source>
          <target>{$arg0 :select s0=|too few| s1=|too many|} template arguments for {$arg1 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|concept| s6=|template|} {$arg2}</target>
        </segment>
      </unit>
      <unit id="5078" name="err_template_arg_method">
        <segment>
          <source>non-type template argument refers to non-static member function %0</source>
          <target>non-type template argument refers to non-static member function {$arg0}</target>
        </segment>
      </unit>
      <unit id="5079" name="err_template_arg_must_be_expr">
        <segment>
          <source>template argument for non-type template parameter must be an expression</source>
          <target>template argument for non-type template parameter must be an expression</target>
        </segment>
      </unit>
      <unit id="5080" name="err_template_arg_must_be_template">
        <segment>
          <source>template argument for template template parameter must be a class template%select{| or type alias template}0</source>
          <target>template argument for template template parameter must be a class template{$arg0 :select s0=|| s1=| or type alias template|}</target>
        </segment>
      </unit>
      <unit id="5081" name="err_template_arg_must_be_type">
        <segment>
          <source>template argument for template type parameter must be a type</source>
          <target>template argument for template type parameter must be a type</target>
        </segment>
      </unit>
      <unit id="5082" name="err_template_arg_must_be_type_suggest">
        <segment>
          <source>template argument for template type parameter must be a type; did you forget 'typename'?</source>
          <target>template argument for template type parameter must be a type; did you forget 'typename'?</target>
        </segment>
      </unit>
      <unit id="5083" name="err_template_arg_no_ref_bind">
        <segment>
          <source>non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1</source>
          <target>non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1</target>
        </segment>
      </unit>
      <unit id="5084" name="err_template_arg_nontype_ambig">
        <segment>
          <source>template argument for non-type template parameter is treated as function type %0</source>
          <target>template argument for non-type template parameter is treated as function type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5085" name="err_template_arg_not_address_constant">
        <segment>
          <source>non-type template argument of type %0 is not a constant expression</source>
          <target>non-type template argument of type {$arg0} is not a constant expression</target>
        </segment>
      </unit>
      <unit id="5086" name="err_template_arg_not_address_of">
        <segment>
          <source>non-type template argument for template parameter of pointer type %0 must have its address taken</source>
          <target>non-type template argument for template parameter of pointer type {$arg0} must have its address taken</target>
        </segment>
      </unit>
      <unit id="5087" name="err_template_arg_not_convertible">
        <segment>
          <source>non-type template argument of type %0 cannot be converted to a value of type %1</source>
          <target>non-type template argument of type {$arg0} cannot be converted to a value of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5088" name="err_template_arg_not_decl_ref">
        <segment>
          <source>non-type template argument does not refer to any declaration</source>
          <target>non-type template argument does not refer to any declaration</target>
        </segment>
      </unit>
      <unit id="5089" name="err_template_arg_not_ice">
        <segment>
          <source>non-type template argument of type %0 is not an integral constant expression</source>
          <target>non-type template argument of type {$arg0} is not an integral constant expression</target>
        </segment>
      </unit>
      <unit id="5090" name="err_template_arg_not_integral_or_enumeral">
        <segment>
          <source>non-type template argument of type %0 must have an integral or enumeration type</source>
          <target>non-type template argument of type {$arg0} must have an integral or enumeration type</target>
        </segment>
      </unit>
      <unit id="5091" name="err_template_arg_not_object_or_func">
        <segment>
          <source>non-type template argument does not refer to an object or function</source>
          <target>non-type template argument does not refer to an object or function</target>
        </segment>
      </unit>
      <unit id="5092" name="err_template_arg_not_pointer_to_member_form">
        <segment>
          <source>non-type template argument is not a pointer to member constant</source>
          <target>non-type template argument is not a pointer to member constant</target>
        </segment>
      </unit>
      <unit id="5093" name="err_template_arg_not_valid_template">
        <segment>
          <source>template argument does not refer to a class or alias template, or template template parameter</source>
          <target>template argument does not refer to a class or alias template, or template template parameter</target>
        </segment>
      </unit>
      <unit id="5094" name="err_template_arg_object_no_linkage">
        <segment>
          <source>non-type template argument refers to %select{function|object}0 %1 that does not have linkage</source>
          <target>non-type template argument refers to {$arg0 :select s0=|function| s1=|object|} {$arg1} that does not have linkage</target>
        </segment>
      </unit>
      <unit id="5095" name="err_template_arg_overload_type">
        <segment>
          <source>template argument is the type of an unresolved overloaded function</source>
          <target>template argument is the type of an unresolved overloaded function</target>
        </segment>
      </unit>
      <unit id="5096" name="err_template_arg_ref_bind_ignores_quals">
        <segment>
          <source>reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers</source>
          <target>reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers</target>
        </segment>
      </unit>
      <unit id="5097" name="err_template_arg_reference_var">
        <segment>
          <source>non-type template argument of reference type %0 is not an object</source>
          <target>non-type template argument of reference type {$arg0} is not an object</target>
        </segment>
      </unit>
      <unit id="5098" name="err_template_arg_template_params_mismatch">
        <segment>
          <source>template template argument has different template parameters than its corresponding template template parameter</source>
          <target>template template argument has different template parameters than its corresponding template template parameter</target>
        </segment>
      </unit>
      <unit id="5099" name="err_template_arg_thread_local">
        <segment>
          <source>non-type template argument refers to thread-local object</source>
          <target>non-type template argument refers to thread-local object</target>
        </segment>
      </unit>
      <unit id="5100" name="err_template_arg_untyped_null_constant">
        <segment>
          <source>null non-type template argument must be cast to template parameter type %0</source>
          <target>null non-type template argument must be cast to template parameter type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5101" name="err_template_arg_wrongtype_null_constant">
        <segment>
          <source>null non-type template argument of type %0 does not match template parameter of type %1</source>
          <target>null non-type template argument of type {$arg0} does not match template parameter of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5102" name="err_template_different_requires_clause">
        <segment>
          <source>requires clause differs in template redeclaration</source>
          <target>requires clause differs in template redeclaration</target>
        </segment>
      </unit>
      <unit id="5103" name="err_template_different_type_constraint">
        <segment>
          <source>type constraint differs in template redeclaration</source>
          <target>type constraint differs in template redeclaration</target>
        </segment>
      </unit>
      <unit id="5104" name="err_template_expansion_into_fixed_list">
        <segment>
          <source>pack expansion used as argument for non-pack parameter of %select{alias template|concept}0</source>
          <target>pack expansion used as argument for non-pack parameter of {$arg0 :select s0=|alias template| s1=|concept|}</target>
        </segment>
      </unit>
      <unit id="5105" name="err_template_id_not_a_type">
        <segment>
          <source>template name refers to non-type template %0</source>
          <target>template name refers to non-type template {$arg0}</target>
        </segment>
      </unit>
      <unit id="5106" name="err_template_inside_local_class">
        <segment>
          <source>templates cannot be declared inside of a local class</source>
          <target>templates cannot be declared inside of a local class</target>
        </segment>
      </unit>
      <unit id="5107" name="err_template_instantiate_undefined">
        <segment>
          <source>%select{implicit|explicit}0 instantiation of undefined template %1</source>
          <target>{$arg0 :select s0=|implicit| s1=|explicit|} instantiation of undefined template {$arg1}</target>
        </segment>
      </unit>
      <unit id="5108" name="err_template_instantiate_within_definition">
        <segment>
          <source>%select{implicit|explicit}0 instantiation of template %1 within its own definition</source>
          <target>{$arg0 :select s0=|implicit| s1=|explicit|} instantiation of template {$arg1} within its own definition</target>
        </segment>
      </unit>
      <unit id="5109" name="err_template_kernel">
        <segment>
          <source>kernel functions cannot be used in a template declaration, instantiation or specialization</source>
          <target>kernel functions cannot be used in a template declaration, instantiation or specialization</target>
        </segment>
      </unit>
      <unit id="5110" name="err_template_kw_missing">
        <segment>
          <source state="initial">missing 'template' keyword prior to dependent template name %0</source>
          <target>missing 'template' keyword prior to dependent template name {$arg0}</target>
        </segment>
      </unit>
      <unit id="5111" name="err_template_kw_refers_to_dependent_non_template">
        <segment>
          <source>%0%select{| following the 'template' keyword}1 cannot refer to a dependent template</source>
          <target>{$arg0}{$arg1 :select s0=|| s1=| following the 'template' keyword|} cannot refer to a dependent template</target>
        </segment>
      </unit>
      <unit id="5112" name="err_template_kw_refers_to_non_template">
        <segment>
          <source>%0%select{| following the 'template' keyword}1 does not refer to a template</source>
          <target>{$arg0}{$arg1 :select s0=|| s1=| following the 'template' keyword|} does not refer to a template</target>
        </segment>
      </unit>
      <unit id="5113" name="err_template_kw_refers_to_type_template">
        <segment>
          <source state="initial">%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template</source>
          <target>{$arg0} is expected to be a non-type template, but instantiated to a {$arg1 :select s0=|class| s1=|type alias|} template</target>
        </segment>
      </unit>
      <unit id="5114" name="err_template_linkage">
        <segment>
          <source>templates must have C++ linkage</source>
          <target>templates must have C++ linkage</target>
        </segment>
      </unit>
      <unit id="5115" name="err_template_member">
        <segment>
          <source state="initial">non-static data member %0 cannot be declared as a template</source>
          <target>non-static data member {$arg0} cannot be declared as a template</target>
        </segment>
      </unit>
      <unit id="5116" name="err_template_member_noparams">
        <segment>
          <source>extraneous 'template&lt;&gt;' in declaration of member %0</source>
          <target>extraneous 'template&lt;&gt;' in declaration of member {$arg0}</target>
        </segment>
      </unit>
      <unit id="5117" name="err_template_missing_args">
        <segment>
          <source>use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments</source>
          <target>use of {$arg0 :select s0=|class template| s1=|function template| s2=|variable template| s3=|alias template| s4=|template template parameter| s5=|concept| s6=|template|} {$arg1} requires template arguments</target>
        </segment>
      </unit>
      <unit id="5118" name="err_template_nontype_parm_bad_structural_type">
        <segment>
          <source>a non-type template parameter cannot have type %0 before C++20</source>
          <target>a non-type template parameter cannot have type {$arg0} before C++20</target>
        </segment>
      </unit>
      <unit id="5119" name="err_template_nontype_parm_bad_type">
        <segment>
          <source>a non-type template parameter cannot have type %0</source>
          <target>a non-type template parameter cannot have type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5120" name="err_template_nontype_parm_different_type">
        <segment>
          <source>template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration</source>
          <target>template non-type parameter has a different type {$arg0} in template {$arg1 :select s0=|| s1=|template parameter |}redeclaration</target>
        </segment>
      </unit>
      <unit id="5121" name="err_template_nontype_parm_incomplete">
        <segment>
          <source>non-type template parameter has incomplete type %0</source>
          <target>non-type template parameter has incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5122" name="err_template_nontype_parm_not_literal">
        <segment>
          <source>non-type template parameter has non-literal type %0</source>
          <target>non-type template parameter has non-literal type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5123" name="err_template_nontype_parm_not_structural">
        <segment>
          <source>type %0 of non-type template parameter is not a structural type</source>
          <target>type {$arg0} of non-type template parameter is not a structural type</target>
        </segment>
      </unit>
      <unit id="5124" name="err_template_nontype_parm_rvalue_ref">
        <segment>
          <source>non-type template parameter has rvalue reference type %0</source>
          <target>non-type template parameter has rvalue reference type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5125" name="err_template_outside_namespace_or_class_scope">
        <segment>
          <source>templates can only be declared in namespace or class scope</source>
          <target>templates can only be declared in namespace or class scope</target>
        </segment>
      </unit>
      <unit id="5126" name="err_template_param_default_arg_inconsistent_redefinition">
        <segment>
          <source>template parameter default argument is inconsistent with previous definition</source>
          <target>template parameter default argument is inconsistent with previous definition</target>
        </segment>
      </unit>
      <unit id="5127" name="err_template_param_default_arg_missing">
        <segment>
          <source>template parameter missing a default argument</source>
          <target>template parameter missing a default argument</target>
        </segment>
      </unit>
      <unit id="5128" name="err_template_param_default_arg_redefinition">
        <segment>
          <source>template parameter redefines default argument</source>
          <target>template parameter redefines default argument</target>
        </segment>
      </unit>
      <unit id="5129" name="err_template_param_different_kind">
        <segment>
          <source>template parameter has a different kind in template %select{|template parameter }0redeclaration</source>
          <target>template parameter has a different kind in template {$arg0 :select s0=|| s1=|template parameter |}redeclaration</target>
        </segment>
      </unit>
      <unit id="5130" name="err_template_param_list_different_arity">
        <segment>
          <source>%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration</source>
          <target>{$arg0 :select s0=|too few| s1=|too many|} template parameters in template {$arg1 :select s0=|| s1=|template parameter |}redeclaration</target>
        </segment>
      </unit>
      <unit id="5131" name="err_template_param_list_matches_nontemplate">
        <segment>
          <source>template parameter list matching the non-templated nested type %0 should be empty ('template&lt;&gt;')</source>
          <target>template parameter list matching the non-templated nested type {$arg0} should be empty ('template&lt;&gt;')</target>
        </segment>
      </unit>
      <unit id="5132" name="err_template_param_pack_default_arg">
        <segment>
          <source>template parameter pack cannot have a default argument</source>
          <target>template parameter pack cannot have a default argument</target>
        </segment>
      </unit>
      <unit id="5133" name="err_template_param_pack_must_be_last_template_parameter">
        <segment>
          <source>template parameter pack must be the last template parameter</source>
          <target>template parameter pack must be the last template parameter</target>
        </segment>
      </unit>
      <unit id="5134" name="err_template_param_shadow">
        <segment>
          <source>declaration of %0 shadows template parameter</source>
          <target>declaration of {$arg0} shadows template parameter</target>
        </segment>
      </unit>
      <unit id="5135" name="err_template_parameter_default_friend_template">
        <segment>
          <source>default template argument not permitted on a friend template</source>
          <target>default template argument not permitted on a friend template</target>
        </segment>
      </unit>
      <unit id="5136" name="err_template_parameter_default_template_member">
        <segment>
          <source>cannot add a default template argument to the definition of a member of a class template</source>
          <target>cannot add a default template argument to the definition of a member of a class template</target>
        </segment>
      </unit>
      <unit id="5137" name="err_template_parameter_pack_non_pack">
        <segment>
          <source>%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1</source>
          <target>{$arg0 :select s0=|template type| s1=|non-type template| s2=|template template|} parameter{$arg1 :select s0=|| s1=| pack|} conflicts with previous {$arg0 :select s0=|template type| s1=|non-type template| s2=|template template|} parameter{$arg1 :select s0=| pack| s1=||}</target>
        </segment>
      </unit>
      <unit id="5138" name="err_template_qualified_declarator_no_match">
        <segment>
          <source state="initial">nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization</source>
          <target>nested name specifier {$arg0} for declaration does not refer into a class, class template or class template partial specialization</target>
        </segment>
      </unit>
      <unit id="5139" name="err_template_recursion_depth_exceeded">
        <segment>
          <source>recursive template instantiation exceeded maximum depth of %0</source>
          <target>recursive template instantiation exceeded maximum depth of {$arg0}</target>
        </segment>
      </unit>
      <unit id="5140" name="err_template_spec_decl_friend">
        <segment>
          <source>cannot declare an explicit specialization in a friend</source>
          <target>cannot declare an explicit specialization in a friend</target>
        </segment>
      </unit>
      <unit id="5141" name="err_template_spec_decl_function_scope">
        <segment>
          <source>explicit specialization of %0 in function scope</source>
          <target>explicit specialization of {$arg0} in function scope</target>
        </segment>
      </unit>
      <unit id="5142" name="err_template_spec_default_arg">
        <segment>
          <source>default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1</source>
          <target>default argument not permitted on an explicit {$arg0 :select s0=|instantiation| s1=|specialization|} of function {$arg1}</target>
        </segment>
      </unit>
      <unit id="5143" name="err_template_spec_extra_headers">
        <segment>
          <source>extraneous template parameter list in template specialization or out-of-line template definition</source>
          <target>extraneous template parameter list in template specialization or out-of-line template definition</target>
        </segment>
      </unit>
      <unit id="5144" name="err_template_spec_friend">
        <segment>
          <source>template specialization declaration cannot be a friend</source>
          <target>template specialization declaration cannot be a friend</target>
        </segment>
      </unit>
      <unit id="5145" name="err_template_spec_needs_header">
        <segment>
          <source>template specialization requires 'template&lt;&gt;'</source>
          <target>template specialization requires 'template&lt;&gt;'</target>
        </segment>
      </unit>
      <unit id="5146" name="err_template_spec_needs_template_parameters">
        <segment>
          <source>template specialization or definition requires a template parameter list corresponding to the nested type %0</source>
          <target>template specialization or definition requires a template parameter list corresponding to the nested type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5147" name="err_template_spec_redecl_global_scope">
        <segment>
          <source>%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope</source>
          <target>{$arg0 :select s0=|class template| s1=|class template partial| s2=|variable template| s3=|variable template partial| s4=|function template| s5=|member function| s6=|static data member| s7=|member class| s8=|member enumeration|} specialization of {$arg1} must occur at global scope</target>
        </segment>
      </unit>
      <unit id="5148" name="err_template_spec_redecl_out_of_scope">
        <segment>
          <source>%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3</source>
          <target>{$arg0 :select s0=|class template| s1=|class template partial| s2=|variable template| s3=|variable template partial| s4=|function template| s5=|member function| s6=|static data member| s7=|member class| s8=|member enumeration|} specialization of {$arg1} not in {$arg3 :select s0=|a namespace enclosing {$arg2}| s1=|class {$arg2} or an enclosing namespace|}</target>
        </segment>
      </unit>
      <unit id="5149" name="err_template_spec_unknown_kind">
        <segment>
          <source>can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template</source>
          <target>can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, {$arg0 :select s0=|or member class| s1=|member class, or member enumeration|} of a class template</target>
        </segment>
      </unit>
      <unit id="5150" name="err_template_tag_noparams">
        <segment>
          <source>extraneous 'template&lt;&gt;' in declaration of %0 %1</source>
          <target>extraneous 'template&lt;&gt;' in declaration of {$arg0} {$arg1}</target>
        </segment>
      </unit>
      <unit id="5151" name="err_template_template_parameter_not_at_least_as_constrained">
        <segment>
          <source>template template argument %0 is more constrained than template template parameter %1</source>
          <target>template template argument {$arg0} is more constrained than template template parameter {$arg1}</target>
        </segment>
      </unit>
      <unit id="5152" name="err_template_template_parm_no_parms">
        <segment>
          <source>template template parameter must have its own template parameters</source>
          <target>template template parameter must have its own template parameters</target>
        </segment>
      </unit>
      <unit id="5153" name="err_template_typedef">
        <segment>
          <source>a typedef cannot be a template</source>
          <target>a typedef cannot be a template</target>
        </segment>
      </unit>
      <unit id="5154" name="err_template_unnamed_class">
        <segment>
          <source>cannot declare a class template with no name</source>
          <target>cannot declare a class template with no name</target>
        </segment>
      </unit>
      <unit id="5155" name="err_template_variable_noparams">
        <segment>
          <source>extraneous 'template&lt;&gt;' in declaration of variable %0</source>
          <target>extraneous 'template&lt;&gt;' in declaration of variable {$arg0}</target>
        </segment>
      </unit>
      <unit id="5156" name="err_tentative_def_incomplete_type">
        <segment>
          <source>tentative definition has type %0 that is never completed</source>
          <target>tentative definition has type {$arg0} that is never completed</target>
        </segment>
      </unit>
      <unit id="5157" name="err_this_capture">
        <segment>
          <source>'this' cannot be %select{implicitly |}0captured in this context</source>
          <target>'this' cannot be {$arg0 :select s0=|implicitly | s1=||}captured in this context</target>
        </segment>
      </unit>
      <unit id="5158" name="err_this_static_member_func">
        <segment>
          <source>'this' cannot be%select{| implicitly}0 used in a static member function declaration</source>
          <target>'this' cannot be{$arg0 :select s0=|| s1=| implicitly|} used in a static member function declaration</target>
        </segment>
      </unit>
      <unit id="5159" name="err_thread_dynamic_init">
        <segment>
          <source>initializer for thread-local variable must be a constant expression</source>
          <target>initializer for thread-local variable must be a constant expression</target>
        </segment>
      </unit>
      <unit id="5160" name="err_thread_non_global">
        <segment>
          <source>'%0' variables must have global storage</source>
          <target>'{$arg0}' variables must have global storage</target>
        </segment>
      </unit>
      <unit id="5161" name="err_thread_non_thread">
        <segment>
          <source>thread-local declaration of %0 follows non-thread-local declaration</source>
          <target>thread-local declaration of {$arg0} follows non-thread-local declaration</target>
        </segment>
      </unit>
      <unit id="5162" name="err_thread_nontrivial_dtor">
        <segment>
          <source>type of thread-local variable has non-trivial destruction</source>
          <target>type of thread-local variable has non-trivial destruction</target>
        </segment>
      </unit>
      <unit id="5163" name="err_thread_thread_different_kind">
        <segment>
          <source>thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization</source>
          <target>thread-local declaration of {$arg0} with {$arg1 :select s0=|static| s1=|dynamic|} initialization follows declaration with {$arg1 :select s0=|dynamic| s1=|static|} initialization</target>
        </segment>
      </unit>
      <unit id="5164" name="err_thread_unsupported">
        <segment>
          <source>thread-local storage is not supported for the current target</source>
          <target>thread-local storage is not supported for the current target</target>
        </segment>
      </unit>
      <unit id="5165" name="err_three_way_vector_comparison">
        <segment>
          <source>three-way comparison between vectors is not supported</source>
          <target>three-way comparison between vectors is not supported</target>
        </segment>
      </unit>
      <unit id="5166" name="err_throw_abstract_type">
        <segment>
          <source>cannot throw an object of abstract type %0</source>
          <target>cannot throw an object of abstract type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5167" name="err_throw_incomplete">
        <segment>
          <source>cannot throw object of incomplete type %0</source>
          <target>cannot throw object of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5168" name="err_throw_incomplete_ptr">
        <segment>
          <source>cannot throw pointer to object of incomplete type %0</source>
          <target>cannot throw pointer to object of incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5169" name="err_throw_object_throwing_dtor">
        <segment>
          <source>cannot throw object of type %0 with a potentially-throwing destructor</source>
          <target>cannot throw object of type {$arg0} with a potentially-throwing destructor</target>
        </segment>
      </unit>
      <unit id="5170" name="err_throw_sizeless">
        <segment>
          <source>cannot throw object of sizeless type %0</source>
          <target>cannot throw object of sizeless type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5171" name="err_tls_var_aligned_over_maximum">
        <segment>
          <source>alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target</source>
          <target>alignment ({$arg0}) of thread-local variable {$arg1} is greater than the maximum supported alignment ({$arg2}) for a thread-local variable on this target</target>
        </segment>
      </unit>
      <unit id="5172" name="err_toomany_element_decls">
        <segment>
          <source>only one element declaration is allowed</source>
          <target>only one element declaration is allowed</target>
        </segment>
      </unit>
      <unit id="5173" name="err_trailing_return_in_parens">
        <segment>
          <source>trailing return type may not be nested within parentheses</source>
          <target>trailing return type may not be nested within parentheses</target>
        </segment>
      </unit>
      <unit id="5174" name="err_trailing_return_without_auto">
        <segment>
          <source>function with trailing return type must specify return type 'auto', not %0</source>
          <target>function with trailing return type must specify return type 'auto', not {$arg0}</target>
        </segment>
      </unit>
      <unit id="5175" name="err_type_attribute_wrong_type">
        <segment>
          <source>'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2</source>
          <target>'{$arg0}' only applies to {$arg1 :select s0=|function| s1=|pointer| s2=|Objective-C object or block pointer|} types; type here is {$arg2}</target>
        </segment>
      </unit>
      <unit id="5176" name="err_type_available_only_in_default_eval_method">
        <segment>
          <source>cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit</source>
          <target>cannot use type '{$arg0}' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit</target>
        </segment>
      </unit>
      <unit id="5177" name="err_type_aware_allocator_missing_matching_operator">
        <segment>
          <source>declaration of type aware %0 in %1 must have matching type aware %2</source>
          <target>declaration of type aware {$arg0} in {$arg1} must have matching type aware {$arg2}</target>
        </segment>
      </unit>
      <unit id="5178" name="err_type_aware_destroying_operator_delete">
        <segment>
          <source>destroying delete is not permitted to be type aware</source>
          <target>destroying delete is not permitted to be type aware</target>
        </segment>
      </unit>
      <unit id="5179" name="err_type_constraint_missing_arguments">
        <segment>
          <source>%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here</source>
          <target>{$arg0} requires more than 1 template argument; provide the remaining arguments explicitly to use it here</target>
        </segment>
      </unit>
      <unit id="5180" name="err_type_constraint_non_type_concept">
        <segment>
          <source>concept named in type constraint is not a type concept</source>
          <target>concept named in type constraint is not a type concept</target>
        </segment>
      </unit>
      <unit id="5181" name="err_type_defined_in_alias_template">
        <segment>
          <source>%0 cannot be defined in a type alias template</source>
          <target>{$arg0} cannot be defined in a type alias template</target>
        </segment>
      </unit>
      <unit id="5182" name="err_type_defined_in_condition">
        <segment>
          <source>%0 cannot be defined in a condition</source>
          <target>{$arg0} cannot be defined in a condition</target>
        </segment>
      </unit>
      <unit id="5183" name="err_type_defined_in_enum">
        <segment>
          <source>%0 cannot be defined in an enumeration</source>
          <target>{$arg0} cannot be defined in an enumeration</target>
        </segment>
      </unit>
      <unit id="5184" name="err_type_defined_in_for_range">
        <segment>
          <source>types may not be defined in a for range declaration</source>
          <target>types may not be defined in a for range declaration</target>
        </segment>
      </unit>
      <unit id="5185" name="err_type_defined_in_param_type">
        <segment>
          <source>%0 cannot be defined in a parameter type</source>
          <target>{$arg0} cannot be defined in a parameter type</target>
        </segment>
      </unit>
      <unit id="5186" name="err_type_defined_in_result_type">
        <segment>
          <source>%0 cannot be defined in the result type of a function</source>
          <target>{$arg0} cannot be defined in the result type of a function</target>
        </segment>
      </unit>
      <unit id="5187" name="err_type_defined_in_type_specifier">
        <segment>
          <source>%0 cannot be defined in a type specifier</source>
          <target>{$arg0} cannot be defined in a type specifier</target>
        </segment>
      </unit>
      <unit id="5188" name="err_type_mismatch_continuation_class">
        <segment>
          <source>type of property %0 in class extension does not match property type in primary class</source>
          <target>type of property {$arg0} in class extension does not match property type in primary class</target>
        </segment>
      </unit>
      <unit id="5189" name="err_type_pack_element_out_of_bounds">
        <segment>
          <source>a parameter pack may not be accessed at an out of bounds index</source>
          <target>a parameter pack may not be accessed at an out of bounds index</target>
        </segment>
      </unit>
      <unit id="5190" name="err_type_tag_for_datatype_not_ice">
        <segment>
          <source>'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression</source>
          <target>'type_tag_for_datatype' attribute requires the initializer to be an {$arg0 :select s0=|integer| s1=|integral|} constant expression</target>
        </segment>
      </unit>
      <unit id="5191" name="err_type_tag_for_datatype_too_large">
        <segment>
          <source>'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer</source>
          <target>'type_tag_for_datatype' attribute requires the initializer to be an {$arg0 :select s0=|integer| s1=|integral|} constant expression that can be represented by a 64 bit integer</target>
        </segment>
      </unit>
      <unit id="5192" name="err_type_unsupported">
        <segment>
          <source>%0 is not supported on this target</source>
          <target>{$arg0} is not supported on this target</target>
        </segment>
      </unit>
      <unit id="5193" name="err_typecheck_address_of">
        <segment>
          <source>address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested</source>
          <target>address of {$arg0 :select s0=|bit-field| s1=|vector element| s2=|property expression| s3=|register variable| s4=|matrix element|} requested</target>
        </segment>
      </unit>
      <unit id="5194" name="err_typecheck_addrof_dtor">
        <segment>
          <source>taking the address of a destructor</source>
          <target>taking the address of a destructor</target>
        </segment>
      </unit>
      <unit id="5195" name="err_typecheck_addrof_temporary">
        <segment>
          <source>taking the address of a temporary object of type %0</source>
          <target>taking the address of a temporary object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5196" name="err_typecheck_ambiguous_condition">
        <segment>
          <source>conversion %diff{from $ to $|between types}0,1 is ambiguous</source>
          <target>conversion %diff{from $ to $|between types}0,1 is ambiguous</target>
        </segment>
      </unit>
      <unit id="5197" name="err_typecheck_arc_assign_externally_retained">
        <segment>
          <source>variable declared with 'objc_externally_retained' cannot be modified in ARC</source>
          <target>variable declared with 'objc_externally_retained' cannot be modified in ARC</target>
        </segment>
      </unit>
      <unit id="5198" name="err_typecheck_arc_assign_self">
        <segment>
          <source>cannot assign to 'self' outside of a method in the init family</source>
          <target>cannot assign to 'self' outside of a method in the init family</target>
        </segment>
      </unit>
      <unit id="5199" name="err_typecheck_arc_assign_self_class_method">
        <segment>
          <source>cannot assign to 'self' in a class method</source>
          <target>cannot assign to 'self' in a class method</target>
        </segment>
      </unit>
      <unit id="5200" name="err_typecheck_arithmetic_incomplete_or_sizeless_type">
        <segment>
          <source>arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1</source>
          <target>arithmetic on a pointer to {$arg0 :select s0=|an incomplete| s1=|sizeless|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5201" name="err_typecheck_arr_assign_enumeration">
        <segment>
          <source>fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this</source>
          <target>fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this</target>
        </segment>
      </unit>
      <unit id="5202" name="err_typecheck_array_not_modifiable_lvalue">
        <segment>
          <source>array type %0 is not assignable</source>
          <target>array type {$arg0} is not assignable</target>
        </segment>
      </unit>
      <unit id="5203" name="err_typecheck_assign_const">
        <segment>
          <source>%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0</source>
          <target>%select{cannot assign to return value because function {$arg1} returns a const value|cannot assign to variable {$arg1} with const-qualified type {$arg2}|cannot assign to {$arg1 :select s0=|non-| s1=||}static data member {$arg2} with const-qualified type {$arg3}|cannot assign to non-static data member within const member function {$arg1}|cannot assign to {$arg1 :select s0=|variable {$arg2}| s1=|non-static data member {$arg2}| s2=|lvalue|} with {$arg0 :select s0=|| s1=|nested }3const-qualified data member {$arg4}| s2=|read-only variable is not assignable|}</target>
        </segment>
      </unit>
      <unit id="5204" name="err_typecheck_bool_condition">
        <segment>
          <source>value of type %0 is not contextually convertible to 'bool'</source>
          <target>value of type {$arg0} is not contextually convertible to 'bool'</target>
        </segment>
      </unit>
      <unit id="5205" name="err_typecheck_call_different_arg_types">
        <segment>
          <source>arguments are of different types%diff{ ($ vs $)|}0,1</source>
          <target>arguments are of different types%diff{ ($ vs $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5206" name="err_typecheck_call_invalid_ordered_compare">
        <segment>
          <source>ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1</source>
          <target>ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5207" name="err_typecheck_call_invalid_unary_fp">
        <segment>
          <source>floating point classification requires argument of floating point type (passed in %0)</source>
          <target>floating point classification requires argument of floating point type (passed in {$arg0})</target>
        </segment>
      </unit>
      <unit id="5208" name="err_typecheck_call_not_function">
        <segment>
          <source>called object type %0 is not a function or function pointer</source>
          <target>called object type {$arg0} is not a function or function pointer</target>
        </segment>
      </unit>
      <unit id="5209" name="err_typecheck_call_requires_real_fp">
        <segment>
          <source>argument type %0 is not a real floating point type</source>
          <target>argument type {$arg0} is not a real floating point type</target>
        </segment>
      </unit>
      <unit id="5210" name="err_typecheck_call_too_few_args">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected {$arg1}, have {$arg2}</target>
        </segment>
      </unit>
      <unit id="5211" name="err_typecheck_call_too_few_args_at_least">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected at least {$arg1}, have {$arg2}</target>
        </segment>
      </unit>
      <unit id="5212" name="err_typecheck_call_too_few_args_at_least_one">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg2 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, at least argument {$arg1} must be specified</target>
        </segment>
      </unit>
      <unit id="5213" name="err_typecheck_call_too_few_args_at_least_suggest">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected at least {$arg1}, have {$arg2}; did you mean {$arg4}?</target>
        </segment>
      </unit>
      <unit id="5214" name="err_typecheck_call_too_few_args_one">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg2 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, single argument {$arg1} was not specified</target>
        </segment>
      </unit>
      <unit id="5215" name="err_typecheck_call_too_few_args_suggest">
        <segment>
          <source>too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?</source>
          <target>too few {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected {$arg1}, have {$arg2}; did you mean {$arg4}?</target>
        </segment>
      </unit>
      <unit id="5216" name="err_typecheck_call_too_many_args">
        <segment>
          <source>too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected {$arg1}, have {$arg2}</target>
        </segment>
      </unit>
      <unit id="5217" name="err_typecheck_call_too_many_args_at_most">
        <segment>
          <source>too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected at most {$arg1}, have {$arg2}</target>
        </segment>
      </unit>
      <unit id="5218" name="err_typecheck_call_too_many_args_at_most_one">
        <segment>
          <source>too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected at most single {$arg3 :select s0=|| s1=|non-object |}argument {$arg1}, have {$arg2}{$arg3 :select s0=|| s1=|non-object|} arguments</target>
        </segment>
      </unit>
      <unit id="5219" name="err_typecheck_call_too_many_args_at_most_suggest">
        <segment>
          <source>too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected at most {$arg1}, have {$arg2}; did you mean {$arg4}?</target>
        </segment>
      </unit>
      <unit id="5220" name="err_typecheck_call_too_many_args_one">
        <segment>
          <source>too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected single argument {$arg1}, have {$arg2} arguments</target>
        </segment>
      </unit>
      <unit id="5221" name="err_typecheck_call_too_many_args_suggest">
        <segment>
          <source>too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?</source>
          <target>too many {$arg0 :select s0=|| s1=|| s2=|| s3=|execution configuration |}{$arg3 :select s0=|| s1=|non-object |}arguments to {$arg0 :select s0=|function| s1=|block| s2=|method| s3=|kernel function|} call, expected {$arg1}, have {$arg2}; did you mean {$arg4}?</target>
        </segment>
      </unit>
      <unit id="5222" name="err_typecheck_cast_to_incomplete">
        <segment>
          <source>cast to incomplete type %0</source>
          <target>cast to incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5223" name="err_typecheck_cast_to_union_no_type">
        <segment>
          <source>cast to union type from type %0 not present in union</source>
          <target>cast to union type from type {$arg0} not present in union</target>
        </segment>
      </unit>
      <unit id="5224" name="err_typecheck_choose_expr_requires_constant">
        <segment>
          <source>'__builtin_choose_expr' requires a constant expression</source>
          <target>'__builtin_choose_expr' requires a constant expression</target>
        </segment>
      </unit>
      <unit id="5225" name="err_typecheck_comparison_of_distinct_blocks">
        <segment>
          <source>comparison of distinct block types%diff{ ($ and $)|}0,1</source>
          <target>comparison of distinct block types%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5226" name="err_typecheck_comparison_of_distinct_pointers">
        <segment>
          <source>comparison of distinct pointer types%diff{ ($ and $)|}0,1</source>
          <target>comparison of distinct pointer types%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5227" name="err_typecheck_comparison_of_fptr_to_void">
        <segment>
          <source>equality comparison between function pointer and void pointer (%0 and %1)</source>
          <target>equality comparison between function pointer and void pointer ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5228" name="err_typecheck_comparison_of_pointer_integer">
        <segment>
          <source>comparison between pointer and integer (%0 and %1)</source>
          <target>comparison between pointer and integer ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5229" name="err_typecheck_cond_expect_int_float">
        <segment>
          <source>used type %0 where integer or floating point type is required</source>
          <target>used type {$arg0} where integer or floating point type is required</target>
        </segment>
      </unit>
      <unit id="5230" name="err_typecheck_cond_expect_nonfloat">
        <segment>
          <source>used type %0 where floating point type is not allowed</source>
          <target>used type {$arg0} where floating point type is not allowed</target>
        </segment>
      </unit>
      <unit id="5231" name="err_typecheck_cond_expect_scalar">
        <segment>
          <source>used type %0 where arithmetic or pointer type is required</source>
          <target>used type {$arg0} where arithmetic or pointer type is required</target>
        </segment>
      </unit>
      <unit id="5232" name="err_typecheck_cond_incompatible_operands">
        <segment>
          <source>incompatible operand types%diff{ ($ and $)|}0,1</source>
          <target>incompatible operand types%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5233" name="err_typecheck_cond_incompatible_operands_null">
        <segment>
          <source>non-pointer operand type %0 incompatible with %select{NULL|nullptr}1</source>
          <target>non-pointer operand type {$arg0} incompatible with {$arg1 :select s0=|NULL| s1=|nullptr|}</target>
        </segment>
      </unit>
      <unit id="5234" name="err_typecheck_cond_incompatible_ptrauth">
        <segment>
          <source>'__ptrauth' qualification mismatch%diff{ ($ and $)|}0,1</source>
          <target>'__ptrauth' qualification mismatch%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5235" name="err_typecheck_convert_discards_qualifiers">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers</target>
        </segment>
      </unit>
      <unit id="5236" name="err_typecheck_convert_incompatible">
        <segment>
          <source>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4</source>
          <target>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters ({$arg5} vs {$arg6})|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers ({$arg5} vs {$arg6})|: different exception specifications}4</target>
        </segment>
      </unit>
      <unit id="5237" name="err_typecheck_convert_incompatible_block_pointer">
        <segment>
          <source>incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</source>
          <target>incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</target>
        </segment>
      </unit>
      <unit id="5238" name="err_typecheck_convert_incompatible_function_pointer">
        <segment>
          <source>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5239" name="err_typecheck_convert_incompatible_pointer">
        <segment>
          <source>incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5240" name="err_typecheck_convert_incompatible_pointer_sign">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types {$arg3 :select s0=|with different sign| s1=|where one is of the unique plain 'char' type and the other is not|}</target>
        </segment>
      </unit>
      <unit id="5241" name="err_typecheck_convert_int_pointer">
        <segment>
          <source>incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5242" name="err_typecheck_convert_pointer_int">
        <segment>
          <source>incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5243" name="err_typecheck_convert_pointer_void_func">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer</target>
        </segment>
      </unit>
      <unit id="5244" name="err_typecheck_converted_constant_expression">
        <segment>
          <source>value of type %0 is not implicitly convertible to %1</source>
          <target>value of type {$arg0} is not implicitly convertible to {$arg1}</target>
        </segment>
      </unit>
      <unit id="5245" name="err_typecheck_converted_constant_expression_disallowed">
        <segment>
          <source>conversion from %0 to %1 is not allowed in a converted constant expression</source>
          <target>conversion from {$arg0} to {$arg1} is not allowed in a converted constant expression</target>
        </segment>
      </unit>
      <unit id="5246" name="err_typecheck_converted_constant_expression_indirect">
        <segment>
          <source>conversion from %0 to %1 in converted constant expression would bind reference to a temporary</source>
          <target>conversion from {$arg0} to {$arg1} in converted constant expression would bind reference to a temporary</target>
        </segment>
      </unit>
      <unit id="5247" name="err_typecheck_decl_incomplete_type">
        <segment>
          <source>variable has incomplete type %0</source>
          <target>variable has incomplete type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5248" name="err_typecheck_deleted_function">
        <segment>
          <source>conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2</source>
          <target>conversion function %diff{from $ to $|between types}0,1 invokes a deleted function{$arg2 :select s0=|| s1=|: {$arg3}|}</target>
        </segment>
      </unit>
      <unit id="5249" name="err_typecheck_duplicate_vector_components_not_mlvalue">
        <segment>
          <source>vector is not assignable (contains duplicate components)</source>
          <target>vector is not assignable (contains duplicate components)</target>
        </segment>
      </unit>
      <unit id="5250" name="err_typecheck_expect_any_scalar_or_vector">
        <segment>
          <source>invalid operand of type %0%select{| where a scalar or vector is required}1</source>
          <target>invalid operand of type {$arg0}{$arg1 :select s0=|| s1=| where a scalar or vector is required|}</target>
        </segment>
      </unit>
      <unit id="5251" name="err_typecheck_expect_flt_or_vector">
        <segment>
          <source>invalid operand of type %0 where floating, complex or a vector of such types is required</source>
          <target>invalid operand of type {$arg0} where floating, complex or a vector of such types is required</target>
        </segment>
      </unit>
      <unit id="5252" name="err_typecheck_expect_hlsl_resource">
        <segment>
          <source>used type %0 where __hlsl_resource_t is required</source>
          <target>used type {$arg0} where __hlsl_resource_t is required</target>
        </segment>
      </unit>
      <unit id="5253" name="err_typecheck_expect_int">
        <segment>
          <source>used type %0 where integer is required</source>
          <target>used type {$arg0} where integer is required</target>
        </segment>
      </unit>
      <unit id="5254" name="err_typecheck_expect_scalar_operand">
        <segment>
          <source>operand of type %0 where arithmetic or pointer type is required</source>
          <target>operand of type {$arg0} where arithmetic or pointer type is required</target>
        </segment>
      </unit>
      <unit id="5255" name="err_typecheck_expect_scalar_or_vector">
        <segment>
          <source>invalid operand of type %0 where %1 or a vector of such type is required</source>
          <target>invalid operand of type {$arg0} where {$arg1} or a vector of such type is required</target>
        </segment>
      </unit>
      <unit id="5256" name="err_typecheck_expression_not_modifiable_lvalue">
        <segment>
          <source>expression is not assignable</source>
          <target>expression is not assignable</target>
        </segment>
      </unit>
      <unit id="5257" name="err_typecheck_field_variable_size">
        <segment>
          <source>fields must have a constant size: 'variable length array in structure' extension will never be supported</source>
          <target>fields must have a constant size: 'variable length array in structure' extension will never be supported</target>
        </segment>
      </unit>
      <unit id="5258" name="err_typecheck_illegal_increment_decrement">
        <segment>
          <source>cannot %select{decrement|increment}1 value of type %0</source>
          <target>cannot {$arg1 :select s0=|decrement| s1=|increment|} value of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5259" name="err_typecheck_incompatible_address_space">
        <segment>
          <source>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer</source>
          <target>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer</target>
        </segment>
      </unit>
      <unit id="5260" name="err_typecheck_incompatible_nested_address_space">
        <segment>
          <source>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer</source>
          <target>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer</target>
        </segment>
      </unit>
      <unit id="5261" name="err_typecheck_incompatible_ownership">
        <segment>
          <source>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer</source>
          <target>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer</target>
        </segment>
      </unit>
      <unit id="5262" name="err_typecheck_incompatible_ptrauth">
        <segment>
          <source>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes pointer authentication of pointee type</source>
          <target>%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes pointer authentication of pointee type</target>
        </segment>
      </unit>
      <unit id="5263" name="err_typecheck_incomplete_array_needs_initializer">
        <segment>
          <source>definition of variable with array type needs an explicit size or an initializer</source>
          <target>definition of variable with array type needs an explicit size or an initializer</target>
        </segment>
      </unit>
      <unit id="5264" name="err_typecheck_incomplete_tag">
        <segment>
          <source>incomplete definition of type %0</source>
          <target>incomplete definition of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5265" name="err_typecheck_incomplete_type_not_modifiable_lvalue">
        <segment>
          <source>incomplete type %0 is not assignable</source>
          <target>incomplete type {$arg0} is not assignable</target>
        </segment>
      </unit>
      <unit id="5266" name="err_typecheck_indirection_requires_pointer">
        <segment>
          <source>indirection requires pointer operand (%0 invalid)</source>
          <target>indirection requires pointer operand ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="5267" name="err_typecheck_indirection_through_void_pointer_cpp">
        <segment>
          <source>indirection not permitted on operand of type %0</source>
          <target>indirection not permitted on operand of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5268" name="err_typecheck_invalid_lvalue_addrof">
        <segment>
          <source>cannot take the address of an rvalue of type %0</source>
          <target>cannot take the address of an rvalue of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5269" name="err_typecheck_invalid_lvalue_addrof_addrof_function">
        <segment>
          <source>extra '&amp;' taking address of overloaded function</source>
          <target>extra '&amp;' taking address of overloaded function</target>
        </segment>
      </unit>
      <unit id="5270" name="err_typecheck_invalid_operands">
        <segment>
          <source>invalid operands to binary expression (%0 and %1)</source>
          <target>invalid operands to binary expression ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5271" name="err_typecheck_invalid_restrict_invalid_pointee">
        <segment>
          <source>pointer to function type %0 may not be 'restrict' qualified</source>
          <target>pointer to function type {$arg0} may not be 'restrict' qualified</target>
        </segment>
      </unit>
      <unit id="5272" name="err_typecheck_invalid_restrict_not_pointer">
        <segment>
          <source>restrict requires a pointer or reference (%0 is invalid)</source>
          <target>restrict requires a pointer or reference ({$arg0} is invalid)</target>
        </segment>
      </unit>
      <unit id="5273" name="err_typecheck_invalid_restrict_not_pointer_noarg">
        <segment>
          <source>restrict requires a pointer or reference</source>
          <target>restrict requires a pointer or reference</target>
        </segment>
      </unit>
      <unit id="5274" name="err_typecheck_ivar_variable_size">
        <segment>
          <source>instance variables must have a constant size</source>
          <target>instance variables must have a constant size</target>
        </segment>
      </unit>
      <unit id="5275" name="err_typecheck_logical_vector_expr_gnu_cpp_restrict">
        <segment>
          <source>logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++</source>
          <target>logical expression with vector {$arg0 :select s0=|type {$arg1} and non-vector type {$arg2}| s1=|types {$arg1} and {$arg2}|} is only supported in C++</target>
        </segment>
      </unit>
      <unit id="5276" name="err_typecheck_lvalue_casts_not_supported">
        <segment>
          <source>assignment to cast is illegal, lvalue casts are not supported</source>
          <target>assignment to cast is illegal, lvalue casts are not supported</target>
        </segment>
      </unit>
      <unit id="5277" name="err_typecheck_member_reference_arrow">
        <segment>
          <source>member reference type %0 is not a pointer</source>
          <target>member reference type {$arg0} is not a pointer</target>
        </segment>
      </unit>
      <unit id="5278" name="err_typecheck_member_reference_ivar">
        <segment>
          <source>%0 does not have a member named %1</source>
          <target>{$arg0} does not have a member named {$arg1}</target>
        </segment>
      </unit>
      <unit id="5279" name="err_typecheck_member_reference_ivar_suggest">
        <segment>
          <source>%0 does not have a member named %1; did you mean %2?</source>
          <target>{$arg0} does not have a member named {$arg1}; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="5280" name="err_typecheck_member_reference_struct_union">
        <segment>
          <source>member reference base type %0 is not a structure or union</source>
          <target>member reference base type {$arg0} is not a structure or union</target>
        </segment>
      </unit>
      <unit id="5281" name="err_typecheck_member_reference_suggestion">
        <segment>
          <source>member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{-&gt;|.}1'?</source>
          <target>member reference type {$arg0} is {$arg1 :select s0=|a| s1=|not a|} pointer; did you mean to use '{$arg1 :select s0=|-&gt;| s1=|.|}'?</target>
        </segment>
      </unit>
      <unit id="5282" name="err_typecheck_member_reference_type">
        <segment>
          <source>cannot refer to type member %0 in %1 with '%select{.|-&gt;}2'</source>
          <target>cannot refer to type member {$arg0} in {$arg1} with '{$arg2 :select s0=|.| s1=|-&gt;|}'</target>
        </segment>
      </unit>
      <unit id="5283" name="err_typecheck_member_reference_unknown">
        <segment>
          <source>cannot refer to member %0 in %1 with '%select{.|-&gt;}2'</source>
          <target>cannot refer to member {$arg0} in {$arg1} with '{$arg2 :select s0=|.| s1=|-&gt;|}'</target>
        </segment>
      </unit>
      <unit id="5284" name="err_typecheck_missing_return_type_incompatible">
        <segment>
          <source>%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type</source>
          <target>%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when {$arg2 :select s0=|block literal| s1=|lambda expression|} has unspecified explicit return type</target>
        </segment>
      </unit>
      <unit id="5285" name="err_typecheck_negative_array_size">
        <segment>
          <source>array size is negative</source>
          <target>array size is negative</target>
        </segment>
      </unit>
      <unit id="5286" name="err_typecheck_non_object_not_modifiable_lvalue">
        <segment>
          <source>non-object type %0 is not assignable</source>
          <target>non-object type {$arg0} is not assignable</target>
        </segment>
      </unit>
      <unit id="5287" name="err_typecheck_nonviable_condition">
        <segment>
          <source>no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0</source>
          <target>no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0</target>
        </segment>
      </unit>
      <unit id="5288" name="err_typecheck_nonviable_condition_incomplete">
        <segment>
          <source>no viable conversion%diff{ from $ to incomplete type $|}0,1</source>
          <target>no viable conversion%diff{ from $ to incomplete type $|}0,1</target>
        </segment>
      </unit>
      <unit id="5289" name="err_typecheck_op_on_nonoverlapping_address_space_pointers">
        <segment>
          <source>%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces</source>
          <target>%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces</target>
        </segment>
      </unit>
      <unit id="5290" name="err_typecheck_ordered_comparison_of_function_pointers">
        <segment>
          <source>ordered comparison of function pointers (%0 and %1)</source>
          <target>ordered comparison of function pointers ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5291" name="err_typecheck_ordered_comparison_of_pointer_and_zero">
        <segment>
          <source>ordered comparison between pointer and zero (%0 and %1)</source>
          <target>ordered comparison between pointer and zero ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5292" name="err_typecheck_pointer_arith_function_type">
        <segment>
          <source>arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2</source>
          <target>arithmetic on{$arg0 :select s0=| a| s1=||} pointer{$arg0 :select s0=|| s1=|s|} to{$arg2 :select s0=| the| s1=||} function type{$arg2 :select s0=|| s1=|s|} {$arg1}{$arg2 :select s0=|| s1=| and {$arg3}|}</target>
        </segment>
      </unit>
      <unit id="5293" name="err_typecheck_pointer_arith_void_type">
        <segment>
          <source>arithmetic on%select{ a|}0 pointer%select{|s}0 to void</source>
          <target>arithmetic on{$arg0 :select s0=| a| s1=||} pointer{$arg0 :select s0=|| s1=|s|} to void</target>
        </segment>
      </unit>
      <unit id="5294" name="err_typecheck_sclass_fscope">
        <segment>
          <source>illegal storage class on file-scoped variable</source>
          <target>illegal storage class on file-scoped variable</target>
        </segment>
      </unit>
      <unit id="5295" name="err_typecheck_sclass_func">
        <segment>
          <source>illegal storage class on function</source>
          <target>illegal storage class on function</target>
        </segment>
      </unit>
      <unit id="5296" name="err_typecheck_statement_requires_integer">
        <segment>
          <source>statement requires expression of integer type (%0 invalid)</source>
          <target>statement requires expression of integer type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="5297" name="err_typecheck_statement_requires_scalar">
        <segment>
          <source>statement requires expression of scalar type (%0 invalid)</source>
          <target>statement requires expression of scalar type ({$arg0} invalid)</target>
        </segment>
      </unit>
      <unit id="5298" name="err_typecheck_sub_ptr_compatible">
        <segment>
          <source>%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1</source>
          <target>%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1</target>
        </segment>
      </unit>
      <unit id="5299" name="err_typecheck_subscript_not_integer">
        <segment>
          <source>array subscript is not an integer</source>
          <target>array subscript is not an integer</target>
        </segment>
      </unit>
      <unit id="5300" name="err_typecheck_subscript_value">
        <segment>
          <source>subscripted value is not an array, pointer, or vector</source>
          <target>subscripted value is not an array, pointer, or vector</target>
        </segment>
      </unit>
      <unit id="5301" name="err_typecheck_sve_rvv_ambiguous">
        <segment>
          <source>cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)</source>
          <target>cannot combine fixed-length and sizeless {$arg0 :select s0=|SVE| s1=|RVV|} vectors in expression, result is ambiguous ({$arg1} and {$arg2})</target>
        </segment>
      </unit>
      <unit id="5302" name="err_typecheck_sve_rvv_gnu_ambiguous">
        <segment>
          <source>cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)</source>
          <target>cannot combine GNU and {$arg0 :select s0=|SVE| s1=|RVV|} vectors in expression, result is ambiguous ({$arg1} and {$arg2})</target>
        </segment>
      </unit>
      <unit id="5303" name="err_typecheck_three_way_comparison_of_pointer_and_zero">
        <segment>
          <source>three-way comparison between pointer and zero</source>
          <target>three-way comparison between pointer and zero</target>
        </segment>
      </unit>
      <unit id="5304" name="err_typecheck_unary_expr">
        <segment>
          <source>invalid argument type %0 to unary expression</source>
          <target>invalid argument type {$arg0} to unary expression</target>
        </segment>
      </unit>
      <unit id="5305" name="err_typecheck_vector_lengths_not_equal">
        <segment>
          <source>vector operands do not have the same number of elements (%0 and %1)</source>
          <target>vector operands do not have the same number of elements ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5306" name="err_typecheck_vector_not_convertable">
        <segment>
          <source>cannot convert between vector values of different size (%0 and %1)</source>
          <target>cannot convert between vector values of different size ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5307" name="err_typecheck_vector_not_convertable_implict_truncation">
        <segment>
          <source>cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation</source>
          <target>cannot convert between {$arg0 :select s0=|scalar| s1=|vector|} type {$arg1} and vector type {$arg2} as implicit conversion would cause truncation</target>
        </segment>
      </unit>
      <unit id="5308" name="err_typecheck_vector_not_convertable_non_scalar">
        <segment>
          <source>cannot convert between vector and non-scalar values (%0 and %1)</source>
          <target>cannot convert between vector and non-scalar values ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5309" name="err_typecheck_wasm_table_must_have_zero_length">
        <segment>
          <source>only zero-length WebAssembly tables are currently supported</source>
          <target>only zero-length WebAssembly tables are currently supported</target>
        </segment>
      </unit>
      <unit id="5310" name="err_typecheck_zero_array_size">
        <segment>
          <source state="initial">zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0</source>
          <target>zero-length arrays are not permitted in {$arg0 :select s0=|C++| s1=|SYCL device code| s2=|HIP device code|}</target>
        </segment>
      </unit>
      <unit id="5311" name="err_typedef_changes_linkage">
        <segment>
          <source>unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition</source>
          <target>unsupported: anonymous type given name for linkage purposes by {$arg0 :select s0=|typedef| s1=|alias|} declaration after its linkage was computed; add a tag name here to establish linkage prior to definition</target>
        </segment>
      </unit>
      <unit id="5312" name="err_typedef_not_bitfield">
        <segment>
          <source>typedef member %0 cannot be a bit-field</source>
          <target>typedef member {$arg0} cannot be a bit-field</target>
        </segment>
      </unit>
      <unit id="5313" name="err_typedef_not_identifier">
        <segment>
          <source>typedef name must be an identifier</source>
          <target>typedef name must be an identifier</target>
        </segment>
      </unit>
      <unit id="5314" name="err_typename_missing">
        <segment>
          <source state="initial">missing 'typename' prior to dependent type name %0</source>
          <target>missing 'typename' prior to dependent type name {$arg0}</target>
        </segment>
      </unit>
      <unit id="5315" name="err_typename_missing_template">
        <segment>
          <source state="initial">missing 'typename' prior to dependent type template name %0</source>
          <target>missing 'typename' prior to dependent type template name {$arg0}</target>
        </segment>
      </unit>
      <unit id="5316" name="err_typename_nested_not_found">
        <segment>
          <source>no type named %0 in %1</source>
          <target>no type named {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="5317" name="err_typename_nested_not_found_enable_if">
        <segment>
          <source>no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration</source>
          <target>no type named 'type' in {$arg0}; 'enable_if' cannot be used to disable this declaration</target>
        </segment>
      </unit>
      <unit id="5318" name="err_typename_nested_not_found_requirement">
        <segment>
          <source>failed requirement '%0'; 'enable_if' cannot be used to disable this declaration</source>
          <target>failed requirement '{$arg0}'; 'enable_if' cannot be used to disable this declaration</target>
        </segment>
      </unit>
      <unit id="5319" name="err_typename_nested_not_type">
        <segment>
          <source>typename specifier refers to non-type member %0 in %1</source>
          <target>typename specifier refers to non-type member {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="5320" name="err_typename_not_type">
        <segment>
          <source>typename specifier refers to non-type %0</source>
          <target>typename specifier refers to non-type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5321" name="err_typename_refers_to_using_value_decl">
        <segment>
          <source>typename specifier refers to a dependent using declaration for a value %0 in %1</source>
          <target>typename specifier refers to a dependent using declaration for a value {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="5322" name="err_unavailable">
        <segment>
          <source>%0 is unavailable</source>
          <target>{$arg0} is unavailable</target>
        </segment>
      </unit>
      <unit id="5323" name="err_unavailable_in_arc">
        <segment>
          <source>%0 is unavailable in ARC</source>
          <target>{$arg0} is unavailable in ARC</target>
        </segment>
      </unit>
      <unit id="5324" name="err_unavailable_message">
        <segment>
          <source>%0 is unavailable: %1</source>
          <target>{$arg0} is unavailable: {$arg1}</target>
        </segment>
      </unit>
      <unit id="5325" name="err_uncasted_call_of_unknown_any">
        <segment>
          <source>%0 has unknown return type; cast the call to its declared return type</source>
          <target>{$arg0} has unknown return type; cast the call to its declared return type</target>
        </segment>
      </unit>
      <unit id="5326" name="err_uncasted_send_to_unknown_any_method">
        <segment>
          <source>no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type</source>
          <target>no known method {$arg0 :select s0=|%objcinstance1| s1=|%objcclass1|}; cast the message send to the method's return type</target>
        </segment>
      </unit>
      <unit id="5327" name="err_uncasted_use_of_unknown_any">
        <segment>
          <source>%0 has unknown type; cast it to its declared type to use it</source>
          <target>{$arg0} has unknown type; cast it to its declared type to use it</target>
        </segment>
      </unit>
      <unit id="5328" name="err_undeclared_boxing_method">
        <segment>
          <source>declaration of %0 is missing in %1 class</source>
          <target>declaration of {$arg0} is missing in {$arg1} class</target>
        </segment>
      </unit>
      <unit id="5329" name="err_undeclared_destructor_name">
        <segment>
          <source>undeclared identifier %0 in destructor name</source>
          <target>undeclared identifier {$arg0} in destructor name</target>
        </segment>
      </unit>
      <unit id="5330" name="err_undeclared_label_use">
        <segment>
          <source>use of undeclared label %0</source>
          <target>use of undeclared label {$arg0}</target>
        </segment>
      </unit>
      <unit id="5331" name="err_undeclared_objc_literal_class">
        <segment>
          <source>definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1</source>
          <target>definition of class {$arg0} must be available to use Objective-C {$arg1 :select s0=|array literals| s1=|dictionary literals| s2=|numeric literals| s3=|boxed expressions| s4=|string literals|}</target>
        </segment>
      </unit>
      <unit id="5332" name="err_undeclared_protocol">
        <segment>
          <source>cannot find protocol declaration for %0</source>
          <target>cannot find protocol declaration for {$arg0}</target>
        </segment>
      </unit>
      <unit id="5333" name="err_undeclared_protocol_suggest">
        <segment>
          <source>cannot find protocol declaration for %0; did you mean %1?</source>
          <target>cannot find protocol declaration for {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5334" name="err_undeclared_use">
        <segment>
          <source>use of undeclared %0</source>
          <target>use of undeclared {$arg0}</target>
        </segment>
      </unit>
      <unit id="5335" name="err_undeclared_use_suggest">
        <segment>
          <source>use of undeclared %0; did you mean %1?</source>
          <target>use of undeclared {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5336" name="err_undeclared_var_use">
        <segment>
          <source>use of undeclared identifier %0</source>
          <target>use of undeclared identifier {$arg0}</target>
        </segment>
      </unit>
      <unit id="5337" name="err_undeclared_var_use_suggest">
        <segment>
          <source>use of undeclared identifier %0; did you mean %1?</source>
          <target>use of undeclared identifier {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5338" name="err_undef_interface">
        <segment>
          <source>cannot find interface declaration for %0</source>
          <target>cannot find interface declaration for {$arg0}</target>
        </segment>
      </unit>
      <unit id="5339" name="err_undef_interface_suggest">
        <segment>
          <source>cannot find interface declaration for %0; did you mean %1?</source>
          <target>cannot find interface declaration for {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5340" name="err_undef_superclass">
        <segment>
          <source>cannot find interface declaration for %0, superclass of %1</source>
          <target>cannot find interface declaration for {$arg0}, superclass of {$arg1}</target>
        </segment>
      </unit>
      <unit id="5341" name="err_undef_superclass_suggest">
        <segment>
          <source>cannot find interface declaration for %0, superclass of %1; did you mean %2?</source>
          <target>cannot find interface declaration for {$arg0}, superclass of {$arg1}; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="5342" name="err_undefined_inline_var">
        <segment>
          <source>inline variable %q0 is not defined</source>
          <target>inline variable {$arg0 :q} is not defined</target>
        </segment>
      </unit>
      <unit id="5343" name="err_undefined_internal_type">
        <segment>
          <source>%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage</source>
          <target>{$arg0 :select s0=|function| s1=|variable|} {$arg1 :q} is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage</target>
        </segment>
      </unit>
      <unit id="5344" name="err_underlying_type_of_incomplete_enum">
        <segment>
          <source>cannot determine underlying type of incomplete enumeration type %0</source>
          <target>cannot determine underlying type of incomplete enumeration type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5345" name="err_unexpanded_parameter_pack">
        <segment>
          <source>%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1</source>
          <target>{$arg0 :select s0=|expression| s1=|base type| s2=|declaration type| s3=|data member type| s4=|bit-field size| s5=|static assertion| s6=|fixed underlying type| s7=|enumerator value| s8=|using declaration| s9=|friend declaration| s10=|qualifier| s11=|initializer| s12=|default argument| s13=|non-type template parameter type| s14=|exception type| s15=|explicit specialization| s16=|partial specialization| s17=|__if_exists name| s18=|__if_not_exists name| s19=|lambda| s20=|block| s21=|type constraint| s22=|requirement| s23=|requires clause|} contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: {$arg2}|2:s {$arg2} and {$arg3}|:s {$arg2}, {$arg3}, ...}1</target>
        </segment>
      </unit>
      <unit id="5346" name="err_unexpected_friend">
        <segment>
          <source>friends can only be classes or functions</source>
          <target>friends can only be classes or functions</target>
        </segment>
      </unit>
      <unit id="5347" name="err_unexpected_interface">
        <segment>
          <source>unexpected interface name %0: expected expression</source>
          <target>unexpected interface name {$arg0}: expected expression</target>
        </segment>
      </unit>
      <unit id="5348" name="err_unexpected_namespace">
        <segment>
          <source>unexpected namespace name %0: expected expression</source>
          <target>unexpected namespace name {$arg0}: expected expression</target>
        </segment>
      </unit>
      <unit id="5349" name="err_unexpected_typedef">
        <segment>
          <source>unexpected type name %0: expected expression</source>
          <target>unexpected type name {$arg0}: expected expression</target>
        </segment>
      </unit>
      <unit id="5350" name="err_uninitialized_member_for_assign">
        <segment>
          <source>cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator</source>
          <target>cannot define the implicit copy assignment operator for {$arg0}, because non-static {$arg1 :select s0=|reference| s1=|const|} member {$arg2} cannot use copy assignment operator</target>
        </segment>
      </unit>
      <unit id="5351" name="err_uninitialized_member_in_ctor">
        <segment>
          <source>%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3</source>
          <target>{$arg0 :select s0=|constructor for {$arg1}| s1=|implicit default constructor for {$arg1}| s2=|cannot use constructor inherited from {$arg1}:|} must explicitly initialize the {$arg2 :select s0=|reference| s1=|const|} member {$arg3}</target>
        </segment>
      </unit>
      <unit id="5352" name="err_union_as_base_class">
        <segment>
          <source>unions cannot be base classes</source>
          <target>unions cannot be base classes</target>
        </segment>
      </unit>
      <unit id="5353" name="err_union_member_of_reference_type">
        <segment>
          <source>union member %0 has reference type %1</source>
          <target>union member {$arg0} has reference type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5354" name="err_unknown_any_addrof">
        <segment>
          <source>the address of a declaration with unknown type can only be cast to a pointer type</source>
          <target>the address of a declaration with unknown type can only be cast to a pointer type</target>
        </segment>
      </unit>
      <unit id="5355" name="err_unknown_any_addrof_call">
        <segment>
          <source>address-of operator cannot be applied to a call to a function with unknown return type</source>
          <target>address-of operator cannot be applied to a call to a function with unknown return type</target>
        </segment>
      </unit>
      <unit id="5356" name="err_unknown_any_function">
        <segment>
          <source>function %0 with unknown type must be given a function type</source>
          <target>function {$arg0} with unknown type must be given a function type</target>
        </segment>
      </unit>
      <unit id="5357" name="err_unknown_any_var_function_type">
        <segment>
          <source>variable %0 with unknown type cannot be given a function type</source>
          <target>variable {$arg0} with unknown type cannot be given a function type</target>
        </segment>
      </unit>
      <unit id="5358" name="err_unknown_arm_state">
        <segment>
          <source>unknown state '%0'</source>
          <target>unknown state '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="5359" name="err_unknown_nested_typename_suggest">
        <segment>
          <source>no type named %0 in %1; did you mean %select{|simply }2%3?</source>
          <target>no type named {$arg0} in {$arg1}; did you mean {$arg2 :select s0=|| s1=|simply |}{$arg3}?</target>
        </segment>
      </unit>
      <unit id="5360" name="err_unknown_receiver_suggest">
        <segment>
          <source>unknown receiver %0; did you mean %1?</source>
          <target>unknown receiver {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5361" name="err_unknown_type_or_class_name_suggest">
        <segment>
          <source>unknown %select{type|class}1 name %0; did you mean %2?</source>
          <target>unknown {$arg1 :select s0=|type| s1=|class|} name {$arg0}; did you mean {$arg2}?</target>
        </segment>
      </unit>
      <unit id="5362" name="err_unknown_typename">
        <segment>
          <source>unknown type name %0</source>
          <target>unknown type name {$arg0}</target>
        </segment>
      </unit>
      <unit id="5363" name="err_unknown_typename_suggest">
        <segment>
          <source>unknown type name %0; did you mean %1?</source>
          <target>unknown type name {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5364" name="err_unqualified_pointer_member_function">
        <segment>
          <source>must explicitly qualify name of member function when taking its address</source>
          <target>must explicitly qualify name of member function when taking its address</target>
        </segment>
      </unit>
      <unit id="5365" name="err_unsupported_placeholder_constraint">
        <segment>
          <source>constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet</source>
          <target>constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet</target>
        </segment>
      </unit>
      <unit id="5366" name="err_unsupported_unknown_any_call">
        <segment>
          <source>call to unsupported expression with unknown type</source>
          <target>call to unsupported expression with unknown type</target>
        </segment>
      </unit>
      <unit id="5367" name="err_unsupported_unknown_any_decl">
        <segment>
          <source>%0 has unknown type, which is not supported for this kind of declaration</source>
          <target>{$arg0} has unknown type, which is not supported for this kind of declaration</target>
        </segment>
      </unit>
      <unit id="5368" name="err_unsupported_unknown_any_expr">
        <segment>
          <source>unsupported expression with unknown type</source>
          <target>unsupported expression with unknown type</target>
        </segment>
      </unit>
      <unit id="5369" name="err_upcast_to_inaccessible_base">
        <segment>
          <source>cannot cast %0 to its %select{private|protected}2 base class %1</source>
          <target>cannot cast {$arg0} to its {$arg2 :select s0=|private| s1=|protected|} base class {$arg1}</target>
        </segment>
      </unit>
      <unit id="5370" name="err_use_continuation_class">
        <segment>
          <source>illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')</source>
          <target>illegal redeclaration of property in class extension {$arg0} (attribute must be 'readwrite', while its primary must be 'readonly')</target>
        </segment>
      </unit>
      <unit id="5371" name="err_use_continuation_class_redeclaration_readwrite">
        <segment>
          <source>illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)</source>
          <target>illegal redeclaration of 'readwrite' property in class extension {$arg0} (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)</target>
        </segment>
      </unit>
      <unit id="5372" name="err_use_of_default_argument_to_function_declared_later">
        <segment>
          <source>use of default argument to function %0 that is declared later in class %1</source>
          <target>use of default argument to function {$arg0} that is declared later in class {$arg1}</target>
        </segment>
      </unit>
      <unit id="5373" name="err_use_of_empty_using_if_exists">
        <segment>
          <source>reference to unresolved using declaration</source>
          <target>reference to unresolved using declaration</target>
        </segment>
      </unit>
      <unit id="5374" name="err_use_of_unaddressable_function">
        <segment>
          <source>taking address of non-addressable standard library function</source>
          <target>taking address of non-addressable standard library function</target>
        </segment>
      </unit>
      <unit id="5375" name="err_use_with_wrong_tag">
        <segment>
          <source>use of %0 with tag type that does not match previous declaration</source>
          <target>use of {$arg0} with tag type that does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="5376" name="err_user_defined_msg_constexpr">
        <segment>
          <source>%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression</source>
          <target>{$arg0 :select s0=|the message| s1=|the expression|} in {$arg0 :select s0=|a static assertion| s1=|this asm operand|} must be produced by a constant expression</target>
        </segment>
      </unit>
      <unit id="5377" name="err_user_defined_msg_invalid">
        <segment>
          <source>%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions</source>
          <target>{$arg0 :select s0=|the message| s1=|the expression|} in {$arg0 :select s0=|a static assertion| s1=|this asm operand|} must be a string literal or an object with 'data()' and 'size()' member functions</target>
        </segment>
      </unit>
      <unit id="5378" name="err_user_defined_msg_invalid_mem_fn_ret_ty">
        <segment>
          <source>%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'</source>
          <target>{$arg0 :select s0=|the message| s1=|the expression|} in {$arg0 :select s0=|a static assertion| s1=|this asm operand|} must have a '{$arg1 :select s0=|size| s1=|data|}()' member function returning an object convertible to '{$arg1 :select s0=|std::size_t| s1=|const char *|}'</target>
        </segment>
      </unit>
      <unit id="5379" name="err_user_defined_msg_missing_member_function">
        <segment>
          <source>the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1</source>
          <target>the {$arg0 :select s0=|message| s1=|string|} object in {$arg0 :select s0=|this static assertion| s1=|this asm operand|} is missing {$arg1 :select s0=|a 'size()' member function| s1=|a 'data()' member function| s2=|'data()' and 'size()' member functions|}</target>
        </segment>
      </unit>
      <unit id="5380" name="err_using_decl_can_not_refer_to_class_member">
        <segment>
          <source>using declaration cannot refer to class member</source>
          <target>using declaration cannot refer to class member</target>
        </segment>
      </unit>
      <unit id="5381" name="err_using_decl_can_not_refer_to_namespace">
        <segment>
          <source>using declaration cannot refer to a namespace</source>
          <target>using declaration cannot refer to a namespace</target>
        </segment>
      </unit>
      <unit id="5382" name="err_using_decl_conflict">
        <segment>
          <source>target of using declaration conflicts with declaration already in scope</source>
          <target>target of using declaration conflicts with declaration already in scope</target>
        </segment>
      </unit>
      <unit id="5383" name="err_using_decl_conflict_reverse">
        <segment>
          <source>declaration conflicts with target of using declaration already in scope</source>
          <target>declaration conflicts with target of using declaration already in scope</target>
        </segment>
      </unit>
      <unit id="5384" name="err_using_decl_constructor">
        <segment>
          <source>using declaration cannot refer to a constructor</source>
          <target>using declaration cannot refer to a constructor</target>
        </segment>
      </unit>
      <unit id="5385" name="err_using_decl_constructor_not_in_direct_base">
        <segment>
          <source>%0 is not a direct base of %1, cannot inherit constructors</source>
          <target>{$arg0} is not a direct base of {$arg1}, cannot inherit constructors</target>
        </segment>
      </unit>
      <unit id="5386" name="err_using_decl_destructor">
        <segment>
          <source>using declaration cannot refer to a destructor</source>
          <target>using declaration cannot refer to a destructor</target>
        </segment>
      </unit>
      <unit id="5387" name="err_using_decl_friend">
        <segment>
          <source>cannot befriend target of using declaration</source>
          <target>cannot befriend target of using declaration</target>
        </segment>
      </unit>
      <unit id="5388" name="err_using_decl_nested_name_specifier_is_current_class">
        <segment>
          <source>using declaration refers to its own class</source>
          <target>using declaration refers to its own class</target>
        </segment>
      </unit>
      <unit id="5389" name="err_using_decl_nested_name_specifier_is_not_base_class">
        <segment>
          <source state="initial">using declaration refers into %0, which is not a base class of %1</source>
          <target>using declaration refers into {$arg0}, which is not a base class of {$arg1}</target>
        </segment>
      </unit>
      <unit id="5390" name="err_using_decl_nested_name_specifier_is_not_class">
        <segment>
          <source state="initial">using declaration in class refers into %0, which is not a class</source>
          <target>using declaration in class refers into {$arg0}, which is not a class</target>
        </segment>
      </unit>
      <unit id="5391" name="err_using_decl_redeclaration">
        <segment>
          <source>redeclaration of using declaration</source>
          <target>redeclaration of using declaration</target>
        </segment>
      </unit>
      <unit id="5392" name="err_using_decl_redeclaration_expansion">
        <segment>
          <source>using declaration pack expansion at block scope produces multiple values</source>
          <target>using declaration pack expansion at block scope produces multiple values</target>
        </segment>
      </unit>
      <unit id="5393" name="err_using_decl_template_id">
        <segment>
          <source>using declaration cannot refer to a template specialization</source>
          <target>using declaration cannot refer to a template specialization</target>
        </segment>
      </unit>
      <unit id="5394" name="err_using_dependent_value_is_type">
        <segment>
          <source>dependent using declaration resolved to type without 'typename'</source>
          <target>dependent using declaration resolved to type without 'typename'</target>
        </segment>
      </unit>
      <unit id="5395" name="err_using_directive_member_suggest">
        <segment>
          <source>no namespace named %0 in %1; did you mean %select{|simply }2%3?</source>
          <target>no namespace named {$arg0} in {$arg1}; did you mean {$arg2 :select s0=|| s1=|simply |}{$arg3}?</target>
        </segment>
      </unit>
      <unit id="5396" name="err_using_directive_suggest">
        <segment>
          <source>no namespace named %0; did you mean %1?</source>
          <target>no namespace named {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="5397" name="err_using_enum_decl_redeclaration">
        <segment>
          <source>redeclaration of using-enum declaration</source>
          <target>redeclaration of using-enum declaration</target>
        </segment>
      </unit>
      <unit id="5398" name="err_using_enum_is_dependent">
        <segment>
          <source>using-enum cannot name a dependent type</source>
          <target>using-enum cannot name a dependent type</target>
        </segment>
      </unit>
      <unit id="5399" name="err_using_enum_not_enum">
        <segment>
          <source>%0 is not an enumerated type</source>
          <target>{$arg0} is not an enumerated type</target>
        </segment>
      </unit>
      <unit id="5400" name="err_using_if_exists_on_ctor">
        <segment>
          <source>'using_if_exists' attribute cannot be applied to an inheriting constructor</source>
          <target>'using_if_exists' attribute cannot be applied to an inheriting constructor</target>
        </segment>
      </unit>
      <unit id="5401" name="err_using_pack_expansion_empty">
        <segment>
          <source>%select{|member}0 using declaration %1 instantiates to an empty pack</source>
          <target>{$arg0 :select s0=|| s1=|member|} using declaration {$arg1} instantiates to an empty pack</target>
        </segment>
      </unit>
      <unit id="5402" name="err_using_placeholder_variable">
        <segment>
          <source>ambiguous reference to placeholder '_', which is defined multiple times</source>
          <target>ambiguous reference to placeholder '_', which is defined multiple times</target>
        </segment>
      </unit>
      <unit id="5403" name="err_using_requires_qualname">
        <segment>
          <source>using declaration requires a qualified name</source>
          <target>using declaration requires a qualified name</target>
        </segment>
      </unit>
      <unit id="5404" name="err_using_typename_non_type">
        <segment>
          <source>'typename' keyword used on a non-type</source>
          <target>'typename' keyword used on a non-type</target>
        </segment>
      </unit>
      <unit id="5405" name="err_uuidof_with_multiple_guids">
        <segment>
          <source>cannot call operator __uuidof on a type with multiple GUIDs</source>
          <target>cannot call operator __uuidof on a type with multiple GUIDs</target>
        </segment>
      </unit>
      <unit id="5406" name="err_uuidof_without_guid">
        <segment>
          <source>cannot call operator __uuidof on a type with no GUID</source>
          <target>cannot call operator __uuidof on a type with no GUID</target>
        </segment>
      </unit>
      <unit id="5407" name="err_va_arg_in_device">
        <segment>
          <source>CUDA device code does not support va_arg</source>
          <target>CUDA device code does not support va_arg</target>
        </segment>
      </unit>
      <unit id="5408" name="err_va_start_captured_stmt">
        <segment>
          <source>'va_start' cannot be used in a captured statement</source>
          <target>'va_start' cannot be used in a captured statement</target>
        </segment>
      </unit>
      <unit id="5409" name="err_va_start_fixed_function">
        <segment>
          <source>'va_start' used in function with fixed args</source>
          <target>'va_start' used in function with fixed args</target>
        </segment>
      </unit>
      <unit id="5410" name="err_va_start_outside_function">
        <segment>
          <source>'va_start' cannot be used outside a function</source>
          <target>'va_start' cannot be used outside a function</target>
        </segment>
      </unit>
      <unit id="5411" name="err_va_start_used_in_wrong_abi_function">
        <segment>
          <source>'va_start' used in %select{System V|Win64}0 ABI function</source>
          <target>'va_start' used in {$arg0 :select s0=|System V| s1=|Win64|} ABI function</target>
        </segment>
      </unit>
      <unit id="5412" name="err_value_init_for_array_type">
        <segment>
          <source>array types cannot be value-initialized</source>
          <target>array types cannot be value-initialized</target>
        </segment>
      </unit>
      <unit id="5413" name="err_var_partial_spec_redeclared">
        <segment>
          <source>variable template partial specialization %0 cannot be redefined</source>
          <target>variable template partial specialization {$arg0} cannot be redefined</target>
        </segment>
      </unit>
      <unit id="5414" name="err_var_spec_no_template">
        <segment>
          <source>no variable template matches%select{| partial}0 specialization</source>
          <target>no variable template matches{$arg0 :select s0=|| s1=| partial|} specialization</target>
        </segment>
      </unit>
      <unit id="5415" name="err_var_spec_no_template_but_method">
        <segment>
          <source>no variable template matches specialization; did you mean to use %0 as function template instead?</source>
          <target>no variable template matches specialization; did you mean to use {$arg0} as function template instead?</target>
        </segment>
      </unit>
      <unit id="5416" name="err_var_template_spec_type_depends_on_self">
        <segment>
          <source>the type of variable template specialization %0 declared with deduced type %1 depends on itself</source>
          <target>the type of variable template specialization {$arg0} declared with deduced type {$arg1} depends on itself</target>
        </segment>
      </unit>
      <unit id="5417" name="err_variable_instantiates_to_function">
        <segment>
          <source>%select{variable|static data member}0 instantiated with function type %1</source>
          <target>{$arg0 :select s0=|variable| s1=|static data member|} instantiated with function type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5418" name="err_variable_object_no_init">
        <segment>
          <source>variable-sized object may not be initialized</source>
          <target>variable-sized object may not be initialized</target>
        </segment>
      </unit>
      <unit id="5419" name="err_variably_modified_new_type">
        <segment>
          <source>'new' cannot allocate object of variably modified type %0</source>
          <target>'new' cannot allocate object of variably modified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5420" name="err_variably_modified_nontype_template_param">
        <segment>
          <source>non-type template parameter of variably modified type %0</source>
          <target>non-type template parameter of variably modified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5421" name="err_variably_modified_template_arg">
        <segment>
          <source>variably modified type %0 cannot be used as a template argument</source>
          <target>variably modified type {$arg0} cannot be used as a template argument</target>
        </segment>
      </unit>
      <unit id="5422" name="err_variably_modified_typeid">
        <segment>
          <source>'typeid' of variably modified type %0</source>
          <target>'typeid' of variably modified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5423" name="err_variadic_device_fn">
        <segment>
          <source>CUDA device code does not support variadic functions</source>
          <target>CUDA device code does not support variadic functions</target>
        </segment>
      </unit>
      <unit id="5424" name="err_vec_builtin_incompatible_vector">
        <segment>
          <source>%select{first two|all}1 arguments to %0 must have the same type</source>
          <target>{$arg1 :select s0=|first two| s1=|all|} arguments to {$arg0} must have the same type</target>
        </segment>
      </unit>
      <unit id="5425" name="err_vec_builtin_non_vector">
        <segment>
          <source>%select{first two|all}1 arguments to %0 must be vectors</source>
          <target>{$arg1 :select s0=|first two| s1=|all|} arguments to {$arg0} must be vectors</target>
        </segment>
      </unit>
      <unit id="5426" name="err_vecstep_non_scalar_vector_type">
        <segment>
          <source>'vec_step' requires built-in scalar or vector type, %0 invalid</source>
          <target>'vec_step' requires built-in scalar or vector type, {$arg0} invalid</target>
        </segment>
      </unit>
      <unit id="5427" name="err_vector_incorrect_bit_count">
        <segment>
          <source>incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)</source>
          <target>incorrect number of bits in vector operand (expected {$arg0 :select s0=|| s1=|a multiple of|} {$arg1} bits, have {$arg2})</target>
        </segment>
      </unit>
      <unit id="5428" name="err_vector_incorrect_num_elements">
        <segment>
          <source>%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)</source>
          <target>{$arg0 :select s0=|too many| s1=|too few|} elements in vector {$arg3 :select s0=|initialization| s1=|operand|} (expected {$arg1} elements, have {$arg2})</target>
        </segment>
      </unit>
      <unit id="5429" name="err_virtual_in_union">
        <segment>
          <source>unions cannot have virtual functions</source>
          <target>unions cannot have virtual functions</target>
        </segment>
      </unit>
      <unit id="5430" name="err_virtual_member_function_template">
        <segment>
          <source>'virtual' cannot be specified on member function templates</source>
          <target>'virtual' cannot be specified on member function templates</target>
        </segment>
      </unit>
      <unit id="5431" name="err_virtual_non_function">
        <segment>
          <source>'virtual' can only appear on non-static member functions</source>
          <target>'virtual' can only appear on non-static member functions</target>
        </segment>
      </unit>
      <unit id="5432" name="err_virtual_out_of_class">
        <segment>
          <source>'virtual' can only be specified inside the class definition</source>
          <target>'virtual' can only be specified inside the class definition</target>
        </segment>
      </unit>
      <unit id="5433" name="err_vla_decl_has_extern_linkage">
        <segment>
          <source>variable length array declaration cannot have 'extern' linkage</source>
          <target>variable length array declaration cannot have 'extern' linkage</target>
        </segment>
      </unit>
      <unit id="5434" name="err_vla_decl_has_static_storage">
        <segment>
          <source>variable length array declaration cannot have 'static' storage duration</source>
          <target>variable length array declaration cannot have 'static' storage duration</target>
        </segment>
      </unit>
      <unit id="5435" name="err_vla_decl_in_file_scope">
        <segment>
          <source>variable length array declaration not allowed at file scope</source>
          <target>variable length array declaration not allowed at file scope</target>
        </segment>
      </unit>
      <unit id="5436" name="err_vla_in_coroutine_unsupported">
        <segment>
          <source>variable length arrays in a coroutine are not supported</source>
          <target>variable length arrays in a coroutine are not supported</target>
        </segment>
      </unit>
      <unit id="5437" name="err_vla_in_sfinae">
        <segment>
          <source>variable length array cannot be formed during template argument deduction</source>
          <target>variable length array cannot be formed during template argument deduction</target>
        </segment>
      </unit>
      <unit id="5438" name="err_vla_unsupported">
        <segment>
          <source>variable length arrays are not supported %select{for the current target|in '%1'}0</source>
          <target>variable length arrays are not supported {$arg0 :select s0=|for the current target| s1=|in '{$arg1}'|}</target>
        </segment>
      </unit>
      <unit id="5439" name="err_vm_decl_has_extern_linkage">
        <segment>
          <source>variably modified type declaration cannot have 'extern' linkage</source>
          <target>variably modified type declaration cannot have 'extern' linkage</target>
        </segment>
      </unit>
      <unit id="5440" name="err_vm_decl_in_file_scope">
        <segment>
          <source>variably modified type declaration not allowed at file scope</source>
          <target>variably modified type declaration not allowed at file scope</target>
        </segment>
      </unit>
      <unit id="5441" name="err_vm_func_decl">
        <segment>
          <source>function declaration cannot have variably modified type</source>
          <target>function declaration cannot have variably modified type</target>
        </segment>
      </unit>
      <unit id="5442" name="err_void_explicit_object_param">
        <segment>
          <source>explicit object parameter cannot have 'void' type</source>
          <target>explicit object parameter cannot have 'void' type</target>
        </segment>
      </unit>
      <unit id="5443" name="err_void_only_param">
        <segment>
          <source>'void' must be the first and only parameter if specified</source>
          <target>'void' must be the first and only parameter if specified</target>
        </segment>
      </unit>
      <unit id="5444" name="err_void_param_qualified">
        <segment>
          <source>'void' as parameter must not have type qualifiers</source>
          <target>'void' as parameter must not have type qualifiers</target>
        </segment>
      </unit>
      <unit id="5445" name="err_volatile_comparison_operator">
        <segment>
          <source>defaulted comparison function must not be volatile</source>
          <target>defaulted comparison function must not be volatile</target>
        </segment>
      </unit>
      <unit id="5446" name="err_vsx_builtin_nonconstant_argument">
        <segment>
          <source>argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)</source>
          <target>argument {$arg0} to {$arg1} must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)</target>
        </segment>
      </unit>
      <unit id="5447" name="err_wasm_builtin_arg_must_be_externref_type">
        <segment>
          <source>%ordinal0 argument must be an externref</source>
          <target>%ordinal0 argument must be an externref</target>
        </segment>
      </unit>
      <unit id="5448" name="err_wasm_builtin_arg_must_be_integer_type">
        <segment>
          <source>%ordinal0 argument must be an integer</source>
          <target>%ordinal0 argument must be an integer</target>
        </segment>
      </unit>
      <unit id="5449" name="err_wasm_builtin_arg_must_be_table_type">
        <segment>
          <source>%ordinal0 argument must be a WebAssembly table</source>
          <target>%ordinal0 argument must be a WebAssembly table</target>
        </segment>
      </unit>
      <unit id="5450" name="err_wasm_builtin_arg_must_match_table_element_type">
        <segment>
          <source>%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument</source>
          <target>%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument</target>
        </segment>
      </unit>
      <unit id="5451" name="err_wasm_ca_reference">
        <segment>
          <source>cannot %select{capture|take address of}0 WebAssembly reference</source>
          <target>cannot {$arg0 :select s0=|capture| s1=|take address of|} WebAssembly reference</target>
        </segment>
      </unit>
      <unit id="5452" name="err_wasm_cast_table">
        <segment>
          <source>cannot cast %select{to|from}0 a WebAssembly table</source>
          <target>cannot cast {$arg0 :select s0=|to| s1=|from|} a WebAssembly table</target>
        </segment>
      </unit>
      <unit id="5453" name="err_wasm_funcref_not_wasm">
        <segment>
          <source>invalid use of '__funcref' keyword outside the WebAssembly triple</source>
          <target>invalid use of '__funcref' keyword outside the WebAssembly triple</target>
        </segment>
      </unit>
      <unit id="5454" name="err_wasm_reference_pr">
        <segment>
          <source>%select{pointer|reference}0 to WebAssembly reference type is not allowed</source>
          <target>{$arg0 :select s0=|pointer| s1=|reference|} to WebAssembly reference type is not allowed</target>
        </segment>
      </unit>
      <unit id="5455" name="err_wasm_reftype_exception_spec">
        <segment>
          <source>WebAssembly reference type not allowed in exception specification</source>
          <target>WebAssembly reference type not allowed in exception specification</target>
        </segment>
      </unit>
      <unit id="5456" name="err_wasm_reftype_multidimensional_array">
        <segment>
          <source>multi-dimensional arrays of WebAssembly references are not allowed</source>
          <target>multi-dimensional arrays of WebAssembly references are not allowed</target>
        </segment>
      </unit>
      <unit id="5457" name="err_wasm_reftype_tc">
        <segment>
          <source>cannot %select{throw|catch}0 a WebAssembly reference type</source>
          <target>cannot {$arg0 :select s0=|throw| s1=|catch|} a WebAssembly reference type</target>
        </segment>
      </unit>
      <unit id="5458" name="err_wasm_table_art">
        <segment>
          <source>cannot %select{assign|return|throw|subscript}0 a WebAssembly table</source>
          <target>cannot {$arg0 :select s0=|assign| s1=|return| s2=|throw| s3=|subscript|} a WebAssembly table</target>
        </segment>
      </unit>
      <unit id="5459" name="err_wasm_table_as_function_parameter">
        <segment>
          <source>cannot use WebAssembly table as a function parameter</source>
          <target>cannot use WebAssembly table as a function parameter</target>
        </segment>
      </unit>
      <unit id="5460" name="err_wasm_table_conditional_expression">
        <segment>
          <source>cannot use a WebAssembly table within a branch of a conditional expression</source>
          <target>cannot use a WebAssembly table within a branch of a conditional expression</target>
        </segment>
      </unit>
      <unit id="5461" name="err_wasm_table_in_function">
        <segment>
          <source>WebAssembly table cannot be declared within a function</source>
          <target>WebAssembly table cannot be declared within a function</target>
        </segment>
      </unit>
      <unit id="5462" name="err_wasm_table_invalid_uett_operand">
        <segment>
          <source>invalid application of '%0' to WebAssembly table</source>
          <target>invalid application of '{$arg0}' to WebAssembly table</target>
        </segment>
      </unit>
      <unit id="5463" name="err_wasm_table_must_be_static">
        <segment>
          <source>WebAssembly table must be static</source>
          <target>WebAssembly table must be static</target>
        </segment>
      </unit>
      <unit id="5464" name="err_wasm_table_pr">
        <segment>
          <source>cannot form a %select{pointer|reference}0 to a WebAssembly table</source>
          <target>cannot form a {$arg0 :select s0=|pointer| s1=|reference|} to a WebAssembly table</target>
        </segment>
      </unit>
      <unit id="5465" name="err_weak_property">
        <segment>
          <source>existing instance variable %1 for __weak property %0 must be __weak</source>
          <target>existing instance variable {$arg1} for __weak property {$arg0} must be __weak</target>
        </segment>
      </unit>
      <unit id="5466" name="err_wrong_sampler_addressspace">
        <segment>
          <source>sampler type cannot be used with the __local and __global address space qualifiers</source>
          <target>sampler type cannot be used with the __local and __global address space qualifiers</target>
        </segment>
      </unit>
      <unit id="5467" name="err_x86_builtin_invalid_rounding">
        <segment>
          <source>invalid rounding argument</source>
          <target>invalid rounding argument</target>
        </segment>
      </unit>
      <unit id="5468" name="err_x86_builtin_invalid_scale">
        <segment>
          <source>scale argument must be 1, 2, 4, or 8</source>
          <target>scale argument must be 1, 2, 4, or 8</target>
        </segment>
      </unit>
      <unit id="5469" name="err_x86_builtin_tile_arg_duplicate">
        <segment>
          <source>tile arguments must refer to different tiles</source>
          <target>tile arguments must refer to different tiles</target>
        </segment>
      </unit>
      <unit id="5470" name="error_cconv_unsupported">
        <segment>
          <source>%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1</source>
          <target>{$arg0} calling convention is not supported {$arg1 :select s0=|for this target| s1=|on variadic function| s2=|on constructor/destructor| s3=|on builtin function|}</target>
        </segment>
      </unit>
      <unit id="5471" name="error_duplicate_asm_operand_name">
        <segment>
          <source>duplicate use of asm operand name "%0"</source>
          <target>duplicate use of asm operand name "{$arg0}"</target>
        </segment>
      </unit>
      <unit id="5472" name="error_hlsl_inout_lvalue">
        <segment>
          <source>cannot bind non-lvalue argument %0 to %select{|in}1out paramemter</source>
          <target>cannot bind non-lvalue argument {$arg0} to {$arg1 :select s0=|| s1=|in|}out paramemter</target>
        </segment>
      </unit>
      <unit id="5473" name="error_hlsl_inout_scalar_extension">
        <segment>
          <source>illegal scalar extension cast on argument %0 to %select{|in}1out paramemter</source>
          <target>illegal scalar extension cast on argument {$arg0} to {$arg1 :select s0=|| s1=|in|}out paramemter</target>
        </segment>
      </unit>
      <unit id="5474" name="error_inoutput_conflict_with_clobber">
        <segment>
          <source>asm-specifier for input or output variable conflicts with asm clobber list</source>
          <target>asm-specifier for input or output variable conflicts with asm clobber list</target>
        </segment>
      </unit>
      <unit id="5475" name="error_subscript_overload">
        <segment>
          <source>overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23</source>
          <target>overloaded {$arg0} cannot have {$arg1 :select s0=|no| s1=|a defaulted| s2=|more than one|} parameter before C++23</target>
        </segment>
      </unit>
      <unit id="5476" name="ext_aggregate_init_not_constant">
        <segment>
          <source>initializer for aggregate is not a compile-time constant</source>
          <target>initializer for aggregate is not a compile-time constant</target>
        </segment>
      </unit>
      <unit id="5477" name="ext_alias_template_in_declarative_nns">
        <segment>
          <source>a declarative nested name specifier cannot name an alias template</source>
          <target>a declarative nested name specifier cannot name an alias template</target>
        </segment>
      </unit>
      <unit id="5478" name="ext_anonymous_record_with_anonymous_type">
        <segment>
          <source>anonymous types declared in an anonymous %select{struct|union}0 are an extension</source>
          <target>anonymous types declared in an anonymous {$arg0 :select s0=|struct| s1=|union|} are an extension</target>
        </segment>
      </unit>
      <unit id="5479" name="ext_anonymous_record_with_type">
        <segment>
          <source>types declared in an anonymous %select{struct|union}0 are a Microsoft extension</source>
          <target>types declared in an anonymous {$arg0 :select s0=|struct| s1=|union|} are a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5480" name="ext_anonymous_struct_union_qualified">
        <segment>
          <source>anonymous %select{struct|union}0 cannot be '%1'</source>
          <target>anonymous {$arg0 :select s0=|struct| s1=|union|} cannot be '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="5481" name="ext_anonymous_union">
        <segment>
          <source>anonymous unions are a C11 extension</source>
          <target>anonymous unions are a C11 extension</target>
        </segment>
      </unit>
      <unit id="5482" name="ext_array_init_copy">
        <segment>
          <source>initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension</source>
          <target>initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5483" name="ext_array_init_parens">
        <segment>
          <source>parenthesized initialization of a member array is a GNU extension</source>
          <target>parenthesized initialization of a member array is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5484" name="ext_array_size_conversion">
        <segment>
          <source>implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension</source>
          <target>implicit conversion from array size expression of type {$arg0} to {$arg1 :select s0=|integral| s1=|enumeration|} type {$arg2} is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="5485" name="ext_assoc_type_incomplete">
        <segment>
          <source>incomplete type %0 in a '_Generic' association is a C2y extension</source>
          <target>incomplete type {$arg0} in a '_Generic' association is a C2y extension</target>
        </segment>
      </unit>
      <unit id="5486" name="ext_auto_new_list_init">
        <segment>
          <source>ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization</source>
          <target>ISO C++ standards before C++17 do not allow new expression for type {$arg0} to use list-initialization</target>
        </segment>
      </unit>
      <unit id="5487" name="ext_auto_type_specifier">
        <segment>
          <source state="initial">'auto' type specifier is a %select{C++11|HLSL 202y}0 extension</source>
          <target>'auto' type specifier is a {$arg0 :select s0=|C++11| s1=|HLSL 202y|} extension</target>
        </segment>
      </unit>
      <unit id="5488" name="ext_bad_cxx_cast_qualifiers_away_incoherent">
        <segment>
          <source>ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated</source>
          <target>ISO C++ does not allow {$arg0 :select s0=|const_cast| s1=|static_cast| s2=|reinterpret_cast| s3=|dynamic_cast| s4=|C-style cast| s5=|functional-style cast| s6=||} from {$arg1} to {$arg2} because it casts away qualifiers, even though the source and destination types are unrelated</target>
        </segment>
      </unit>
      <unit id="5489" name="ext_c2y_alignof_incomplete_array">
        <segment>
          <source>'alignof' on an incomplete array type is a C2y extension</source>
          <target>'alignof' on an incomplete array type is a C2y extension</target>
        </segment>
      </unit>
      <unit id="5490" name="ext_c2y_imaginary_constant">
        <segment>
          <source>imaginary constants are a C2y extension</source>
          <target>imaginary constants are a C2y extension</target>
        </segment>
      </unit>
      <unit id="5491" name="ext_c2y_increment_complex">
        <segment>
          <source>'%select{--|++}0' on an object of complex type is a C2y extension</source>
          <target>'{$arg0 :select s0=|--| s1=|++|}' on an object of complex type is a C2y extension</target>
        </segment>
      </unit>
      <unit id="5492" name="ext_c11_anonymous_struct">
        <segment>
          <source>anonymous structs are a C11 extension</source>
          <target>anonymous structs are a C11 extension</target>
        </segment>
      </unit>
      <unit id="5493" name="ext_c23_auto_non_plain_identifier">
        <segment>
          <source>type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension</source>
          <target>type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension</target>
        </segment>
      </unit>
      <unit id="5494" name="ext_c23_enum_value_not_int">
        <segment>
          <source>%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)</source>
          <target>{$arg0 :select s0=|| s1=|incremented |}enumerator value which exceeds the range of 'int' is a C23 extension ({$arg1} is too {$arg2 :select s0=|small| s1=|large|})</target>
        </segment>
      </unit>
      <unit id="5495" name="ext_c23_non_local_variable_decl_in_for">
        <segment>
          <source>declaration of non-local variable in 'for' loop is a C23 extension</source>
          <target>declaration of non-local variable in 'for' loop is a C23 extension</target>
        </segment>
      </unit>
      <unit id="5496" name="ext_c23_non_variable_decl_in_for">
        <segment>
          <source>non-variable declaration in 'for' loop is a C23 extension</source>
          <target>non-variable declaration in 'for' loop is a C23 extension</target>
        </segment>
      </unit>
      <unit id="5497" name="ext_c99_array_usage">
        <segment>
          <source>%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature</source>
          <target>{$arg0 :select s0=|qualifier in | s1=|static | s2=||}array size {$arg0 :select s0=|| s1=|| s2=|'[*] '|}is a C99 feature</target>
        </segment>
      </unit>
      <unit id="5498" name="ext_c99_flexible_array_member">
        <segment>
          <source>flexible array members are a C99 feature</source>
          <target>flexible array members are a C99 feature</target>
        </segment>
      </unit>
      <unit id="5499" name="ext_cannot_use_trivial_abi">
        <segment>
          <source>'trivial_abi' cannot be applied to %0</source>
          <target>'trivial_abi' cannot be applied to {$arg0}</target>
        </segment>
      </unit>
      <unit id="5500" name="ext_capture_binding">
        <segment>
          <source>captured structured bindings are a C++20 extension</source>
          <target>captured structured bindings are a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5501" name="ext_cast_fn_obj">
        <segment>
          <source>cast between pointer-to-function and pointer-to-object is an extension</source>
          <target>cast between pointer-to-function and pointer-to-object is an extension</target>
        </segment>
      </unit>
      <unit id="5502" name="ext_cce_narrowing">
        <segment>
          <source state="initial">%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1</source>
          <target>{$arg0 :select s0=|case value| s1=|enumerator value| s2=|non-type template argument| s3=|non-type parameter of template template parameter| s4=|array size| s5=|explicit specifier argument| s6=|noexcept specifier argument| s7=|call to 'size()'| s8=|call to 'data()'|} {$arg1 :select s0=|cannot be narrowed from type {$arg2} to {$arg3}| s1=|evaluates to {$arg2}, which cannot be narrowed to type {$arg3}|}</target>
        </segment>
      </unit>
      <unit id="5503" name="ext_compat_template_param_shadow">
        <segment>
          <source>declaration of %0 shadows template parameter</source>
          <target>declaration of {$arg0} shadows template parameter</target>
        </segment>
      </unit>
      <unit id="5504" name="ext_complex_component_init">
        <segment>
          <source>complex initialization specifying real and imaginary components is an extension</source>
          <target>complex initialization specifying real and imaginary components is an extension</target>
        </segment>
      </unit>
      <unit id="5505" name="ext_constexpr_function_never_constant_expr">
        <segment>
          <source>%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression</source>
          <target>{$arg1 :select s0=|constexpr| s1=|consteval|} {$arg0 :select s0=|function| s1=|constructor|} never produces a constant expression</target>
        </segment>
      </unit>
      <unit id="5506" name="ext_constinit_missing">
        <segment>
          <source>'constinit' specifier missing on initializing declaration of %0</source>
          <target>'constinit' specifier missing on initializing declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="5507" name="ext_cxx14_attr">
        <segment>
          <source>use of the %0 attribute is a C++14 extension</source>
          <target>use of the {$arg0} attribute is a C++14 extension</target>
        </segment>
      </unit>
      <unit id="5508" name="ext_cxx17_attr">
        <segment>
          <source>use of the %0 attribute is a C++17 extension</source>
          <target>use of the {$arg0} attribute is a C++17 extension</target>
        </segment>
      </unit>
      <unit id="5509" name="ext_cxx20_attr">
        <segment>
          <source>use of the %0 attribute is a C++20 extension</source>
          <target>use of the {$arg0} attribute is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5510" name="ext_cxx23_attr">
        <segment>
          <source>use of the %0 attribute is a C++23 extension</source>
          <target>use of the {$arg0} attribute is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="5511" name="ext_cxx26_type_aware_allocators">
        <segment>
          <source>type aware allocators are a C++2c extension</source>
          <target>type aware allocators are a C++2c extension</target>
        </segment>
      </unit>
      <unit id="5512" name="ext_cxx_designated_init">
        <segment>
          <source>designated initializers are a C++20 extension</source>
          <target>designated initializers are a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5513" name="ext_default_init_const">
        <segment>
          <source>default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension</source>
          <target>default initialization of an object of const type {$arg0}{$arg1 :select s0=|| s1=| without a user-provided default constructor|} is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5514" name="ext_defaulted_comparison">
        <segment>
          <source>defaulted comparison operators are a C++20 extension</source>
          <target>defaulted comparison operators are a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5515" name="ext_delete_void_ptr_operand">
        <segment>
          <source>cannot delete expression with pointer-to-'void' type %0</source>
          <target>cannot delete expression with pointer-to-'void' type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5516" name="ext_deprecated_string_literal_conversion">
        <segment>
          <source>ISO C++11 does not allow conversion from string literal to %0</source>
          <target>ISO C++11 does not allow conversion from string literal to {$arg0}</target>
        </segment>
      </unit>
      <unit id="5517" name="ext_designated_init">
        <segment>
          <source>designated initializers are a C99 feature</source>
          <target>designated initializers are a C99 feature</target>
        </segment>
      </unit>
      <unit id="5518" name="ext_designated_init_array">
        <segment>
          <source>array designators are a C99 extension</source>
          <target>array designators are a C99 extension</target>
        </segment>
      </unit>
      <unit id="5519" name="ext_designated_init_brace_elision">
        <segment>
          <source>brace elision for designated initializer is a C99 extension</source>
          <target>brace elision for designated initializer is a C99 extension</target>
        </segment>
      </unit>
      <unit id="5520" name="ext_designated_init_mixed">
        <segment>
          <source>mixture of designated and non-designated initializers in the same initializer list is a C99 extension</source>
          <target>mixture of designated and non-designated initializers in the same initializer list is a C99 extension</target>
        </segment>
      </unit>
      <unit id="5521" name="ext_designated_init_nested">
        <segment>
          <source>nested designators are a C99 extension</source>
          <target>nested designators are a C99 extension</target>
        </segment>
      </unit>
      <unit id="5522" name="ext_designated_init_reordered">
        <segment>
          <source>ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0</source>
          <target>ISO C++ requires field designators to be specified in declaration order; field {$arg1} will be initialized after field {$arg0}</target>
        </segment>
      </unit>
      <unit id="5523" name="ext_destructor_typedef_name">
        <segment>
          <source>destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name</source>
          <target>destructor cannot be declared using a {$arg1 :select s0=|typedef| s1=|type alias|} {$arg0} of the class name</target>
        </segment>
      </unit>
      <unit id="5524" name="ext_dtor_name_ambiguous">
        <segment>
          <source>ISO C++ considers this destructor name lookup to be ambiguous</source>
          <target>ISO C++ considers this destructor name lookup to be ambiguous</target>
        </segment>
      </unit>
      <unit id="5525" name="ext_dtor_named_in_wrong_scope">
        <segment>
          <source>ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'</source>
          <target>ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'</target>
        </segment>
      </unit>
      <unit id="5526" name="ext_empty_struct_union">
        <segment>
          <source>empty %select{struct|union}0 is a GNU extension</source>
          <target>empty {$arg0 :select s0=|struct| s1=|union|} is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5527" name="ext_enum_friend">
        <segment>
          <source>elaborated enum specifier cannot be declared as a friend</source>
          <target>elaborated enum specifier cannot be declared as a friend</target>
        </segment>
      </unit>
      <unit id="5528" name="ext_enum_too_large">
        <segment>
          <source>enumeration values exceed range of largest integer</source>
          <target>enumeration values exceed range of largest integer</target>
        </segment>
      </unit>
      <unit id="5529" name="ext_enumerator_increment_too_large">
        <segment>
          <source>incremented enumerator value %0 is not representable in the largest integer type</source>
          <target>incremented enumerator value {$arg0} is not representable in the largest integer type</target>
        </segment>
      </unit>
      <unit id="5530" name="ext_enumerator_too_large">
        <segment>
          <source>enumerator value is not representable in the underlying type %0</source>
          <target>enumerator value is not representable in the underlying type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5531" name="ext_equals_this_lambda_capture_cxx20">
        <segment>
          <source>explicit capture of 'this' with a capture default of '=' is a C++20 extension</source>
          <target>explicit capture of 'this' with a capture default of '=' is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5532" name="ext_equivalent_internal_linkage_decl_in_modules">
        <segment>
          <source>ambiguous use of internal linkage declaration %0 defined in multiple modules</source>
          <target>ambiguous use of internal linkage declaration {$arg0} defined in multiple modules</target>
        </segment>
      </unit>
      <unit id="5533" name="ext_excess_initializers">
        <segment>
          <source>excess elements in %select{array|vector|scalar|union|struct}0 initializer</source>
          <target>excess elements in {$arg0 :select s0=|array| s1=|vector| s2=|scalar| s3=|union| s4=|struct|} initializer</target>
        </segment>
      </unit>
      <unit id="5534" name="ext_excess_initializers_for_sizeless_type">
        <segment>
          <source>excess elements in initializer for indivisible sizeless type %0</source>
          <target>excess elements in initializer for indivisible sizeless type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5535" name="ext_excess_initializers_in_char_array_initializer">
        <segment>
          <source>excess elements in char array initializer</source>
          <target>excess elements in char array initializer</target>
        </segment>
      </unit>
      <unit id="5536" name="ext_explicit_conversion_functions">
        <segment>
          <source>explicit conversion functions are a C++11 extension</source>
          <target>explicit conversion functions are a C++11 extension</target>
        </segment>
      </unit>
      <unit id="5537" name="ext_explicit_instantiation_duplicate">
        <segment>
          <source>duplicate explicit instantiation of %0 ignored as a Microsoft extension</source>
          <target>duplicate explicit instantiation of {$arg0} ignored as a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5538" name="ext_explicit_instantiation_without_qualified_id">
        <segment>
          <source>qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)</source>
          <target>qualifier in explicit instantiation of {$arg0 :q} requires a template-id (a typedef is not permitted)</target>
        </segment>
      </unit>
      <unit id="5539" name="ext_explicit_specialization_storage_class">
        <segment>
          <source>explicit specialization cannot have a storage class</source>
          <target>explicit specialization cannot have a storage class</target>
        </segment>
      </unit>
      <unit id="5540" name="ext_expr_not_ice">
        <segment>
          <source>expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension</source>
          <target>expression is not an {$arg0 :select s0=|integer| s1=|integral|} constant expression; folding it to a constant is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5541" name="ext_flexible_array_empty_aggregate_gnu">
        <segment>
          <source>flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension</source>
          <target>flexible array member {$arg0} in otherwise empty {$arg1 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5542" name="ext_flexible_array_empty_aggregate_ms">
        <segment>
          <source>flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension</source>
          <target>flexible array member {$arg0} in otherwise empty {$arg1 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5543" name="ext_flexible_array_in_array">
        <segment>
          <source>%0 may not be used as an array element due to flexible array member</source>
          <target>{$arg0} may not be used as an array element due to flexible array member</target>
        </segment>
      </unit>
      <unit id="5544" name="ext_flexible_array_in_struct">
        <segment>
          <source>%0 may not be nested in a struct due to flexible array member</source>
          <target>{$arg0} may not be nested in a struct due to flexible array member</target>
        </segment>
      </unit>
      <unit id="5545" name="ext_flexible_array_init">
        <segment>
          <source>flexible array initialization is a GNU extension</source>
          <target>flexible array initialization is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5546" name="ext_flexible_array_union_gnu">
        <segment>
          <source>flexible array member %0 in a union is a GNU extension</source>
          <target>flexible array member {$arg0} in a union is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5547" name="ext_flexible_array_union_ms">
        <segment>
          <source>flexible array member %0 in a union is a Microsoft extension</source>
          <target>flexible array member {$arg0} in a union is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5548" name="ext_for_range_begin_end_types_differ">
        <segment>
          <source>'begin' and 'end' returning different types (%0 and %1) is a C++17 extension</source>
          <target>'begin' and 'end' returning different types ({$arg0} and {$arg1}) is a C++17 extension</target>
        </segment>
      </unit>
      <unit id="5549" name="ext_forward_ref_enum">
        <segment>
          <source>ISO C forbids forward references to 'enum' types</source>
          <target>ISO C forbids forward references to 'enum' types</target>
        </segment>
      </unit>
      <unit id="5550" name="ext_forward_ref_enum_def">
        <segment>
          <source>redeclaration of already-defined enum %0 is a GNU extension</source>
          <target>redeclaration of already-defined enum {$arg0} is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5551" name="ext_found_in_dependent_base">
        <segment>
          <source>use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension</source>
          <target>use of member {$arg0} found via unqualified lookup into dependent bases of class templates is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5552" name="ext_found_later_in_class">
        <segment>
          <source>use of member %0 before its declaration is a Microsoft extension</source>
          <target>use of member {$arg0} before its declaration is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5553" name="ext_freestanding_complex">
        <segment>
          <source>complex numbers are an extension in a freestanding C99 implementation</source>
          <target>complex numbers are an extension in a freestanding C99 implementation</target>
        </segment>
      </unit>
      <unit id="5554" name="ext_friend_tag_redecl_outside_namespace">
        <segment>
          <source>unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier</source>
          <target>unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier</target>
        </segment>
      </unit>
      <unit id="5555" name="ext_gnu_anonymous_struct">
        <segment>
          <source>anonymous structs are a GNU extension</source>
          <target>anonymous structs are a GNU extension</target>
        </segment>
      </unit>
      <unit id="5556" name="ext_gnu_imaginary_constant">
        <segment>
          <source>imaginary constants are a GNU extension</source>
          <target>imaginary constants are a GNU extension</target>
        </segment>
      </unit>
      <unit id="5557" name="ext_gnu_ptr_func_arith">
        <segment>
          <source>arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension</source>
          <target>arithmetic on{$arg0 :select s0=| a| s1=||} pointer{$arg0 :select s0=|| s1=|s|} to{$arg2 :select s0=| the| s1=||} function type{$arg2 :select s0=|| s1=|s|} {$arg1}{$arg2 :select s0=|| s1=| and {$arg3}|} is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5558" name="ext_gnu_subscript_void_type">
        <segment>
          <source>subscript of a pointer to void is a GNU extension</source>
          <target>subscript of a pointer to void is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5559" name="ext_gnu_void_ptr">
        <segment>
          <source>arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension</source>
          <target>arithmetic on{$arg0 :select s0=| a| s1=||} pointer{$arg0 :select s0=|| s1=|s|} to void is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5560" name="ext_goto_into_protected_scope">
        <segment>
          <source>jump from this goto statement to its label is a Microsoft extension</source>
          <target>jump from this goto statement to its label is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5561" name="ext_hlsl_auto_type_specifier">
        <segment>
          <source>'auto' type specifier is a %select{C++11|HLSL 202y}0 extension</source>
          <target>'auto' type specifier is a {$arg0 :select s0=|C++11| s1=|HLSL 202y|} extension</target>
        </segment>
      </unit>
      <unit id="5562" name="ext_implicit_exception_spec_mismatch">
        <segment>
          <source>function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification</source>
          <target>function previously declared with an {$arg0 :select s0=|explicit| s1=|implicit|} exception specification redeclared with an {$arg0 :select s0=|implicit| s1=|explicit|} exception specification</target>
        </segment>
      </unit>
      <unit id="5563" name="ext_implicit_function_decl_c99">
        <segment>
          <source>call to undeclared function %0; ISO C99 and later do not support implicit function declarations</source>
          <target>call to undeclared function {$arg0}; ISO C99 and later do not support implicit function declarations</target>
        </segment>
      </unit>
      <unit id="5564" name="ext_implicit_lib_function_decl">
        <segment>
          <source>implicitly declaring library function '%0' with type %1</source>
          <target>implicitly declaring library function '{$arg0}' with type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5565" name="ext_implicit_lib_function_decl_c99">
        <segment>
          <source>call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations</source>
          <target>call to undeclared library function '{$arg0}' with type {$arg1}; ISO C99 and later do not support implicit function declarations</target>
        </segment>
      </unit>
      <unit id="5566" name="ext_in_class_initializer_float_type">
        <segment>
          <source>in-class initializer for static data member of type %0 is a GNU extension</source>
          <target>in-class initializer for static data member of type {$arg0} is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5567" name="ext_in_class_initializer_float_type_cxx11">
        <segment>
          <source>in-class initializer for static data member of type %0 requires 'constexpr' specifier</source>
          <target>in-class initializer for static data member of type {$arg0} requires 'constexpr' specifier</target>
        </segment>
      </unit>
      <unit id="5568" name="ext_in_class_initializer_non_constant">
        <segment>
          <source>in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension</source>
          <target>in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5569" name="ext_incomplete_in_exception_spec">
        <segment>
          <source>%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification</source>
          <target>{$arg0 :select s0=|| s1=|pointer to | s2=|reference to |}incomplete type {$arg1} is not allowed in exception specification</target>
        </segment>
      </unit>
      <unit id="5570" name="ext_increment_bool">
        <segment>
          <source>ISO C++17 does not allow incrementing expression of type bool</source>
          <target>ISO C++17 does not allow incrementing expression of type bool</target>
        </segment>
      </unit>
      <unit id="5571" name="ext_init_capture">
        <segment>
          <source>initialized lambda captures are a C++14 extension</source>
          <target>initialized lambda captures are a C++14 extension</target>
        </segment>
      </unit>
      <unit id="5572" name="ext_init_capture_pack">
        <segment>
          <source>initialized lambda pack captures are a C++20 extension</source>
          <target>initialized lambda pack captures are a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5573" name="ext_init_from_predefined">
        <segment>
          <source state="initial">initializing an array from a %0 predefined identifier is a Microsoft extension</source>
          <target>initializing an array from a {$arg0} predefined identifier is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5574" name="ext_init_list_constant_narrowing">
        <segment>
          <source>constant expression evaluates to %0 which cannot be narrowed to type %1</source>
          <target>constant expression evaluates to {$arg0} which cannot be narrowed to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5575" name="ext_init_list_constant_narrowing_const_reference">
        <segment>
          <source>constant expression evaluates to %0 which cannot be narrowed to type %1</source>
          <target>constant expression evaluates to {$arg0} which cannot be narrowed to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5576" name="ext_init_list_type_narrowing">
        <segment>
          <source>type %0 cannot be narrowed to %1 in initializer list</source>
          <target>type {$arg0} cannot be narrowed to {$arg1} in initializer list</target>
        </segment>
      </unit>
      <unit id="5577" name="ext_init_list_type_narrowing_const_reference">
        <segment>
          <source>type %0 cannot be narrowed to %1 in initializer list</source>
          <target>type {$arg0} cannot be narrowed to {$arg1} in initializer list</target>
        </segment>
      </unit>
      <unit id="5578" name="ext_init_list_variable_narrowing">
        <segment>
          <source>non-constant-expression cannot be narrowed from type %0 to %1 in initializer list</source>
          <target>non-constant-expression cannot be narrowed from type {$arg0} to {$arg1} in initializer list</target>
        </segment>
      </unit>
      <unit id="5579" name="ext_init_list_variable_narrowing_const_reference">
        <segment>
          <source>non-constant-expression cannot be narrowed from type %0 to %1 in initializer list</source>
          <target>non-constant-expression cannot be narrowed from type {$arg0} to {$arg1} in initializer list</target>
        </segment>
      </unit>
      <unit id="5580" name="ext_initializer_overrides">
        <segment>
          <source>initializer %select{partially |}0overrides prior initialization of this subobject</source>
          <target>initializer {$arg0 :select s0=|partially | s1=||}overrides prior initialization of this subobject</target>
        </segment>
      </unit>
      <unit id="5581" name="ext_initializer_string_for_char_array_too_long">
        <segment>
          <source>initializer-string for char array is too long</source>
          <target>initializer-string for char array is too long</target>
        </segment>
      </unit>
      <unit id="5582" name="ext_initializer_union_overrides">
        <segment>
          <source>initializer %select{partially |}0overrides prior initialization of this subobject</source>
          <target>initializer {$arg0 :select s0=|partially | s1=||}overrides prior initialization of this subobject</target>
        </segment>
      </unit>
      <unit id="5583" name="ext_integer_complement_complex">
        <segment>
          <source>ISO C does not support '~' for complex conjugation of %0</source>
          <target>ISO C does not support '~' for complex conjugation of {$arg0}</target>
        </segment>
      </unit>
      <unit id="5584" name="ext_integer_complex">
        <segment>
          <source>complex integer types are a GNU extension</source>
          <target>complex integer types are a GNU extension</target>
        </segment>
      </unit>
      <unit id="5585" name="ext_internal_in_extern_inline">
        <segment>
          <source>static %select{function|variable}0 %1 is used in an inline function with external linkage</source>
          <target>static {$arg0 :select s0=|function| s1=|variable|} {$arg1} is used in an inline function with external linkage</target>
        </segment>
      </unit>
      <unit id="5586" name="ext_internal_in_extern_inline_quiet">
        <segment>
          <source>static %select{function|variable}0 %1 is used in an inline function with external linkage</source>
          <target>static {$arg0 :select s0=|function| s1=|variable|} {$arg1} is used in an inline function with external linkage</target>
        </segment>
      </unit>
      <unit id="5587" name="ext_main_invalid_linkage_specification">
        <segment>
          <source>'main' should not be 'extern "%select{C|C++}0"'</source>
          <target>'main' should not be 'extern "{$arg0 :select s0=|C| s1=|C++|}"'</target>
        </segment>
      </unit>
      <unit id="5588" name="ext_main_no_return">
        <segment>
          <source>implicit '0' return value from 'main' is a C99 extension</source>
          <target>implicit '0' return value from 'main' is a C99 extension</target>
        </segment>
      </unit>
      <unit id="5589" name="ext_main_returns_nonint">
        <segment>
          <source>return type of 'main' is not 'int'</source>
          <target>return type of 'main' is not 'int'</target>
        </segment>
      </unit>
      <unit id="5590" name="ext_main_used">
        <segment>
          <source>referring to 'main' within an expression is a Clang extension</source>
          <target>referring to 'main' within an expression is a Clang extension</target>
        </segment>
      </unit>
      <unit id="5591" name="ext_many_braces_around_init">
        <segment>
          <source>too many braces around %select{scalar |}0initializer</source>
          <target>too many braces around {$arg0 :select s0=|scalar | s1=||}initializer</target>
        </segment>
      </unit>
      <unit id="5592" name="ext_member_redeclared">
        <segment>
          <source>class member cannot be redeclared</source>
          <target>class member cannot be redeclared</target>
        </segment>
      </unit>
      <unit id="5593" name="ext_mismatched_exception_spec">
        <segment>
          <source>exception specification in declaration does not match previous declaration</source>
          <target>exception specification in declaration does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="5594" name="ext_mismatched_exception_spec_explicit_instantiation">
        <segment>
          <source>exception specification in explicit instantiation does not match instantiated one</source>
          <target>exception specification in explicit instantiation does not match instantiated one</target>
        </segment>
      </unit>
      <unit id="5595" name="ext_missing_exception_specification">
        <segment>
          <source>%0 is missing exception specification '%1'</source>
          <target>{$arg0} is missing exception specification '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="5596" name="ext_missing_type_specifier">
        <segment>
          <source>type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int</source>
          <target>type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int</target>
        </segment>
      </unit>
      <unit id="5597" name="ext_mixed_decls_code">
        <segment>
          <source>mixing declarations and code is a C99 extension</source>
          <target>mixing declarations and code is a C99 extension</target>
        </segment>
      </unit>
      <unit id="5598" name="ext_module_import_in_extern_c">
        <segment>
          <source>import of C++ module '%0' appears within extern "C" language linkage specification</source>
          <target>import of C++ module '{$arg0}' appears within extern "C" language linkage specification</target>
        </segment>
      </unit>
      <unit id="5599" name="ext_module_import_not_at_top_level_noop">
        <segment>
          <source>redundant #include of module '%0' appears within %1</source>
          <target>redundant #include of module '{$arg0}' appears within {$arg1}</target>
        </segment>
      </unit>
      <unit id="5600" name="ext_ms_ambiguous_direct_base">
        <segment>
          <source>accessing inaccessible direct base %0 of %1 is a Microsoft extension</source>
          <target>accessing inaccessible direct base {$arg0} of {$arg1} is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5601" name="ext_ms_anonymous_record">
        <segment>
          <source>anonymous %select{structs|unions}0 are a Microsoft extension</source>
          <target>anonymous {$arg0 :select s0=|structs| s1=|unions|} are a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5602" name="ext_ms_cast_fn_obj">
        <segment>
          <source>static_cast between pointer-to-function and pointer-to-object is a Microsoft extension</source>
          <target>static_cast between pointer-to-function and pointer-to-object is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5603" name="ext_ms_delayed_template_argument">
        <segment>
          <source>using the undeclared type %0 as a default template argument is a Microsoft extension</source>
          <target>using the undeclared type {$arg0} as a default template argument is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5604" name="ext_ms_deref_template_argument">
        <segment>
          <source>non-type template argument containing a dereference operation is a Microsoft extension</source>
          <target>non-type template argument containing a dereference operation is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5605" name="ext_ms_explicit_constructor_call">
        <segment>
          <source>explicit constructor calls are a Microsoft extension</source>
          <target>explicit constructor calls are a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5606" name="ext_ms_forward_ref_enum">
        <segment>
          <source>forward references to 'enum' types are a Microsoft extension</source>
          <target>forward references to 'enum' types are a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5607" name="ext_ms_impcast_fn_obj">
        <segment>
          <source>implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension</source>
          <target>implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5608" name="ext_ms_template_spec_redecl_out_of_scope">
        <segment>
          <source>%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension</source>
          <target>{$arg0 :select s0=|class template| s1=|class template partial| s2=|variable template| s3=|variable template partial| s4=|function template| s5=|member function| s6=|static data member| s7=|member class| s8=|member enumeration|} specialization of {$arg1} not in {$arg3 :select s0=|a namespace enclosing {$arg2}| s1=|class {$arg2} or an enclosing namespace|} is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5609" name="ext_ms_template_type_arg_missing_typename">
        <segment>
          <source>template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension</source>
          <target>template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5610" name="ext_ms_using_declaration_inaccessible">
        <segment>
          <source>using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension</source>
          <target>using declaration referring to inaccessible member '{$arg0}' (which refers to accessible member '{$arg1}') is a Microsoft compatibility extension</target>
        </segment>
      </unit>
      <unit id="5611" name="ext_mutable_reference">
        <segment>
          <source>'mutable' on a reference type is a Microsoft extension</source>
          <target>'mutable' on a reference type is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5612" name="ext_nested_name_member_ref_lookup_ambiguous">
        <segment>
          <source>lookup of %0 in member access expression is ambiguous; using member of %1</source>
          <target>lookup of {$arg0} in member access expression is ambiguous; using member of {$arg1}</target>
        </segment>
      </unit>
      <unit id="5613" name="ext_nested_name_spec_is_enum">
        <segment>
          <source>use of enumeration in a nested name specifier is a C++11 extension</source>
          <target>use of enumeration in a nested name specifier is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="5614" name="ext_nested_pointer_qualifier_mismatch">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types</target>
        </segment>
      </unit>
      <unit id="5615" name="ext_new_paren_array_nonconst">
        <segment>
          <source>when type is in parentheses, array cannot have dynamic size</source>
          <target>when type is in parentheses, array cannot have dynamic size</target>
        </segment>
      </unit>
      <unit id="5616" name="ext_no_declarators">
        <segment>
          <source>declaration does not declare anything</source>
          <target>declaration does not declare anything</target>
        </segment>
      </unit>
      <unit id="5617" name="ext_no_named_members_in_struct_union">
        <segment>
          <source>%select{struct|union}0 without named members is a GNU extension</source>
          <target>{$arg0 :select s0=|struct| s1=|union|} without named members is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5618" name="ext_non_c_like_anon_struct_in_typedef">
        <segment>
          <source>anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here</source>
          <target>anonymous non-C-compatible type given name for linkage purposes by {$arg0 :select s0=|typedef| s1=|alias|} declaration; add a tag name here</target>
        </segment>
      </unit>
      <unit id="5619" name="ext_noreturn_main">
        <segment>
          <source>'main' is not allowed to be declared _Noreturn</source>
          <target>'main' is not allowed to be declared _Noreturn</target>
        </segment>
      </unit>
      <unit id="5620" name="ext_offsetof_non_pod_type">
        <segment>
          <source state="initial">'offsetof' on non-POD type %0</source>
          <target>'offsetof' on non-POD type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5621" name="ext_offsetof_non_standardlayout_type">
        <segment>
          <source state="initial">'offsetof' on non-standard-layout type %0</source>
          <target>'offsetof' on non-standard-layout type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5622" name="ext_omp_loop_not_canonical_init">
        <segment>
          <source>initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')</source>
          <target>initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')</target>
        </segment>
      </unit>
      <unit id="5623" name="ext_opencl_double_without_pragma">
        <segment>
          <source>Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported</source>
          <target>Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported</target>
        </segment>
      </unit>
      <unit id="5624" name="ext_opencl_ext_vector_type_rgba_selector">
        <segment>
          <source>vector component name '%0' is a feature from OpenCL version 3.0 onwards</source>
          <target>vector component name '{$arg0}' is a feature from OpenCL version 3.0 onwards</target>
        </segment>
      </unit>
      <unit id="5625" name="ext_operator_new_delete_declared_inline">
        <segment>
          <source>replacement function %0 cannot be declared 'inline'</source>
          <target>replacement function {$arg0} cannot be declared 'inline'</target>
        </segment>
      </unit>
      <unit id="5626" name="ext_operator_overload_static">
        <segment>
          <source>declaring overloaded %0 as 'static' is a C++23 extension</source>
          <target>declaring overloaded {$arg0} as 'static' is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="5627" name="ext_out_of_line_declaration">
        <segment>
          <source>out-of-line declaration of a member must be a definition</source>
          <target>out-of-line declaration of a member must be a definition</target>
        </segment>
      </unit>
      <unit id="5628" name="ext_out_of_line_qualified_id_type_names_constructor">
        <segment>
          <source>ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword</source>
          <target>ISO C++ specifies that qualified reference to {$arg0} is a constructor name rather than a {$arg1 :select s0=|template name| s1=|type|} in this context, despite preceding {$arg2 :select s0=|'typename'| s1=|'template'|} keyword</target>
        </segment>
      </unit>
      <unit id="5629" name="ext_override_exception_spec">
        <segment>
          <source>exception specification of overriding function is more lax than base version</source>
          <target>exception specification of overriding function is more lax than base version</target>
        </segment>
      </unit>
      <unit id="5630" name="ext_ovl_ambiguous_oper_binary_reversed">
        <segment>
          <source>ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3</source>
          <target>ISO C++20 considers use of overloaded operator '{$arg0}' (with operand types {$arg1} and {$arg2}) to be ambiguous despite there being a unique best viable function{$arg3 :select s0=| with non-reversed arguments| s1=||}</target>
        </segment>
      </unit>
      <unit id="5631" name="ext_ovl_rewrite_equalequal_not_bool">
        <segment>
          <source>ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0</source>
          <target>ISO C++20 requires return type of selected 'operator==' function for rewritten '{$arg1}' comparison to be 'bool', not {$arg0}</target>
        </segment>
      </unit>
      <unit id="5632" name="ext_pack_indexing">
        <segment>
          <source>pack indexing is a C++2c extension</source>
          <target>pack indexing is a C++2c extension</target>
        </segment>
      </unit>
      <unit id="5633" name="ext_param_default_argument_redefinition">
        <segment>
          <source>redefinition of default argument</source>
          <target>redefinition of default argument</target>
        </segment>
      </unit>
      <unit id="5634" name="ext_param_not_declared">
        <segment>
          <source>parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int</source>
          <target>parameter {$arg0} was not declared, defaults to 'int'; ISO C99 and later do not support implicit int</target>
        </segment>
      </unit>
      <unit id="5635" name="ext_param_promoted_not_compatible_with_prototype">
        <segment>
          <source>%diff{promoted type $ of K&amp;R function parameter is not compatible with the parameter type $|promoted type of K&amp;R function parameter is not compatible with parameter type}0,1 declared in a previous prototype</source>
          <target>%diff{promoted type $ of K&amp;R function parameter is not compatible with the parameter type $|promoted type of K&amp;R function parameter is not compatible with parameter type}0,1 declared in a previous prototype</target>
        </segment>
      </unit>
      <unit id="5636" name="ext_parameter_name_omitted_c23">
        <segment>
          <source>omitting the parameter name in a function definition is a C23 extension</source>
          <target>omitting the parameter name in a function definition is a C23 extension</target>
        </segment>
      </unit>
      <unit id="5637" name="ext_partial_spec_not_more_specialized_than_primary">
        <segment>
          <source>%select{class|variable}0 template partial specialization is not more specialized than the primary template</source>
          <target>{$arg0 :select s0=|class| s1=|variable|} template partial specialization is not more specialized than the primary template</target>
        </segment>
      </unit>
      <unit id="5638" name="ext_partial_specs_not_deducible">
        <segment>
          <source>%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used</source>
          <target>{$arg0 :select s0=|class| s1=|variable|} template partial specialization contains {$arg1 :select s0=|a template parameter| s1=|template parameters|} that cannot be deduced; this partial specialization will never be used</target>
        </segment>
      </unit>
      <unit id="5639" name="ext_placeholder_var_definition">
        <segment>
          <source>placeholder variables are a C++2c extension</source>
          <target>placeholder variables are a C++2c extension</target>
        </segment>
      </unit>
      <unit id="5640" name="ext_plain_complex">
        <segment>
          <source>plain '_Complex' requires a type specifier; assuming '_Complex double'</source>
          <target>plain '_Complex' requires a type specifier; assuming '_Complex double'</target>
        </segment>
      </unit>
      <unit id="5641" name="ext_pointer_to_const_ref_member_on_rvalue">
        <segment>
          <source>invoking a pointer to a 'const &amp;' member function on an rvalue is a C++20 extension</source>
          <target>invoking a pointer to a 'const &amp;' member function on an rvalue is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5642" name="ext_predef_outside_function">
        <segment>
          <source>predefined identifier is only valid inside function</source>
          <target>predefined identifier is only valid inside function</target>
        </segment>
      </unit>
      <unit id="5643" name="ext_pseudo_dtor_on_void">
        <segment>
          <source>pseudo-destructors on type void are a Microsoft extension</source>
          <target>pseudo-destructors on type void are a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5644" name="ext_pure_function_definition">
        <segment>
          <source>function definition with pure-specifier is a Microsoft extension</source>
          <target>function definition with pure-specifier is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5645" name="ext_qualified_dtor_named_in_lexical_scope">
        <segment>
          <source>qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup</source>
          <target>qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup</target>
        </segment>
      </unit>
      <unit id="5646" name="ext_redefinition_of_typedef">
        <segment>
          <source>redefinition of typedef %0 is a C11 feature</source>
          <target>redefinition of typedef {$arg0} is a C11 feature</target>
        </segment>
      </unit>
      <unit id="5647" name="ext_register_storage_class">
        <segment>
          <source>ISO C++17 does not allow 'register' storage class specifier</source>
          <target>ISO C++17 does not allow 'register' storage class specifier</target>
        </segment>
      </unit>
      <unit id="5648" name="ext_restrict_on_array_of_pointers_c23">
        <segment>
          <source>'restrict' qualifier on an array of pointers is a C23 extension</source>
          <target>'restrict' qualifier on an array of pointers is a C23 extension</target>
        </segment>
      </unit>
      <unit id="5649" name="ext_retained_language_linkage">
        <segment>
          <source>friend function %0 retaining previous language linkage is an extension</source>
          <target>friend function {$arg0} retaining previous language linkage is an extension</target>
        </segment>
      </unit>
      <unit id="5650" name="ext_return_has_expr">
        <segment>
          <source>%select{void function|void method|constructor|destructor}1 %0 should not return a value</source>
          <target>{$arg1 :select s0=|void function| s1=|void method| s2=|constructor| s3=|destructor|} {$arg0} should not return a value</target>
        </segment>
      </unit>
      <unit id="5651" name="ext_return_has_void_expr">
        <segment>
          <source>void %select{function|method|block}1 %0 should not return void expression</source>
          <target>void {$arg1 :select s0=|function| s1=|method| s2=|block|} {$arg0} should not return void expression</target>
        </segment>
      </unit>
      <unit id="5652" name="ext_return_missing_expr">
        <segment>
          <source>non-void %select{function|method}1 %0 should return a value</source>
          <target>non-void {$arg1 :select s0=|function| s1=|method|} {$arg0} should return a value</target>
        </segment>
      </unit>
      <unit id="5653" name="ext_rvalue_to_reference_access_ctor">
        <segment>
          <source>C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0</source>
          <target>C++98 requires an accessible copy constructor for class {$arg2} when binding a reference to a temporary; was {$arg0 :select s0=|private| s1=|protected|}</target>
        </segment>
      </unit>
      <unit id="5654" name="ext_rvalue_to_reference_temp_copy_no_viable">
        <segment>
          <source>no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary</source>
          <target>no viable constructor {$arg0 :select s0=|copying variable| s1=|copying parameter| s2=|initializing template parameter| s3=|returning object| s4=|initializing statement expression result| s5=|throwing object| s6=|copying member subobject| s7=|copying array element| s8=|allocating object| s9=|copying temporary| s10=|initializing base subobject| s11=|initializing vector element| s12=|capturing value|} of type {$arg1}; C++98 requires a copy constructor when binding a reference to a temporary</target>
        </segment>
      </unit>
      <unit id="5655" name="ext_sizeof_alignof_function_type">
        <segment>
          <source>invalid application of '%0' to a function type</source>
          <target>invalid application of '{$arg0}' to a function type</target>
        </segment>
      </unit>
      <unit id="5656" name="ext_sizeof_alignof_void_type">
        <segment>
          <source>invalid application of '%0' to a void type</source>
          <target>invalid application of '{$arg0}' to a void type</target>
        </segment>
      </unit>
      <unit id="5657" name="ext_standalone_specifier">
        <segment>
          <source>'%0' is not permitted on a declaration of a type</source>
          <target>'{$arg0}' is not permitted on a declaration of a type</target>
        </segment>
      </unit>
      <unit id="5658" name="ext_star_this_lambda_capture_cxx17">
        <segment>
          <source>capture of '*this' by copy is a C++17 extension</source>
          <target>capture of '*this' by copy is a C++17 extension</target>
        </segment>
      </unit>
      <unit id="5659" name="ext_static_non_static">
        <segment>
          <source>redeclaring non-static %0 as static is a Microsoft extension</source>
          <target>redeclaring non-static {$arg0} as static is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5660" name="ext_static_out_of_line">
        <segment>
          <source>'static' can only be specified inside the class definition</source>
          <target>'static' can only be specified inside the class definition</target>
        </segment>
      </unit>
      <unit id="5661" name="ext_string_literal_from_predefined">
        <segment>
          <source>expansion of predefined identifier '%0' to a string literal is a Microsoft extension</source>
          <target>expansion of predefined identifier '{$arg0}' to a string literal is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5662" name="ext_string_literal_operator_template">
        <segment>
          <source>string literal operator templates are a GNU extension</source>
          <target>string literal operator templates are a GNU extension</target>
        </segment>
      </unit>
      <unit id="5663" name="ext_subscript_non_lvalue">
        <segment>
          <source>ISO C90 does not allow subscripting non-lvalue array</source>
          <target>ISO C90 does not allow subscripting non-lvalue array</target>
        </segment>
      </unit>
      <unit id="5664" name="ext_subscript_overload">
        <segment>
          <source>overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension</source>
          <target>overloaded {$arg0} with {$arg1 :select s0=|no| s1=|a defaulted| s2=|more than one|} parameter is a C++23 extension</target>
        </segment>
      </unit>
      <unit id="5665" name="ext_template_after_declarative_nns">
        <segment>
          <source>'template' cannot be used after a declarative nested name specifier</source>
          <target>'template' cannot be used after a declarative nested name specifier</target>
        </segment>
      </unit>
      <unit id="5666" name="ext_template_arg_local_type">
        <segment>
          <source>template argument uses local type %0</source>
          <target>template argument uses local type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5667" name="ext_template_arg_object_internal">
        <segment>
          <source>non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension</source>
          <target>non-type template argument referring to {$arg0 :select s0=|function| s1=|object|} {$arg1} with internal linkage is a C++11 extension</target>
        </segment>
      </unit>
      <unit id="5668" name="ext_template_arg_unnamed_type">
        <segment>
          <source>template argument uses unnamed type</source>
          <target>template argument uses unnamed type</target>
        </segment>
      </unit>
      <unit id="5669" name="ext_template_outside_of_template">
        <segment>
          <source>'template' keyword outside of a template</source>
          <target>'template' keyword outside of a template</target>
        </segment>
      </unit>
      <unit id="5670" name="ext_template_param_shadow">
        <segment>
          <source>declaration of %0 shadows template parameter</source>
          <target>declaration of {$arg0} shadows template parameter</target>
        </segment>
      </unit>
      <unit id="5671" name="ext_template_spec_extra_headers">
        <segment>
          <source>extraneous template parameter list in template specialization</source>
          <target>extraneous template parameter list in template specialization</target>
        </segment>
      </unit>
      <unit id="5672" name="ext_type_defined_in_offsetof">
        <segment>
          <source>defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension</source>
          <target>defining a type within '{$arg0 :select s0=|__builtin_offsetof| s1=|offsetof|}' is a C23 extension</target>
        </segment>
      </unit>
      <unit id="5673" name="ext_typecheck_addrof_temporary">
        <segment>
          <source>taking the address of a temporary object of type %0</source>
          <target>taking the address of a temporary object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5674" name="ext_typecheck_addrof_void">
        <segment>
          <source>ISO C forbids taking the address of an expression of type 'void'</source>
          <target>ISO C forbids taking the address of an expression of type 'void'</target>
        </segment>
      </unit>
      <unit id="5675" name="ext_typecheck_base_super">
        <segment>
          <source>method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1</source>
          <target>method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1</target>
        </segment>
      </unit>
      <unit id="5676" name="ext_typecheck_cast_nonscalar">
        <segment>
          <source>C99 forbids casting nonscalar type %0 to the same type</source>
          <target>C99 forbids casting nonscalar type {$arg0} to the same type</target>
        </segment>
      </unit>
      <unit id="5677" name="ext_typecheck_cast_to_union">
        <segment>
          <source>cast to union type is a GNU extension</source>
          <target>cast to union type is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5678" name="ext_typecheck_compare_complete_incomplete_pointers">
        <segment>
          <source>pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete</source>
          <target>pointer comparisons before C11 need to be between two complete or two incomplete types; {$arg0} is {$arg2 :select s0=|| s1=|in|}complete and {$arg1} is {$arg3 :select s0=|| s1=|in|}complete</target>
        </segment>
      </unit>
      <unit id="5679" name="ext_typecheck_comparison_of_distinct_pointers">
        <segment>
          <source>comparison of distinct pointer types%diff{ ($ and $)|}0,1</source>
          <target>comparison of distinct pointer types%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5680" name="ext_typecheck_comparison_of_fptr_to_void">
        <segment>
          <source>equality comparison between function pointer and void pointer (%0 and %1)</source>
          <target>equality comparison between function pointer and void pointer ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5681" name="ext_typecheck_comparison_of_pointer_integer">
        <segment>
          <source>comparison between pointer and integer (%0 and %1)</source>
          <target>comparison between pointer and integer ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5682" name="ext_typecheck_cond_incompatible_operands">
        <segment>
          <source>incompatible operand types (%0 and %1)</source>
          <target>incompatible operand types ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5683" name="ext_typecheck_cond_incompatible_pointers">
        <segment>
          <source>pointer type mismatch%diff{ ($ and $)|}0,1</source>
          <target>pointer type mismatch%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5684" name="ext_typecheck_cond_one_void">
        <segment>
          <source>C99 forbids conditional expressions with only one void side</source>
          <target>C99 forbids conditional expressions with only one void side</target>
        </segment>
      </unit>
      <unit id="5685" name="ext_typecheck_cond_pointer_integer_mismatch">
        <segment>
          <source>pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1</source>
          <target>pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="5686" name="ext_typecheck_convert_discards_qualifiers">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers</target>
        </segment>
      </unit>
      <unit id="5687" name="ext_typecheck_convert_incompatible_function_pointer">
        <segment>
          <source>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5688" name="ext_typecheck_convert_incompatible_pointer">
        <segment>
          <source>incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5689" name="ext_typecheck_convert_incompatible_pointer_sign">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types {$arg3 :select s0=|with different sign| s1=|where one is of the unique plain 'char' type and the other is not|}</target>
        </segment>
      </unit>
      <unit id="5690" name="ext_typecheck_convert_int_pointer">
        <segment>
          <source>incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5691" name="ext_typecheck_convert_pointer_int">
        <segment>
          <source>incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="5692" name="ext_typecheck_convert_pointer_void_func">
        <segment>
          <source>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer</source>
          <target>%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer</target>
        </segment>
      </unit>
      <unit id="5693" name="ext_typecheck_decl_incomplete_type">
        <segment>
          <source state="initial">tentative definition of variable with internal linkage has incomplete %select{non-array|array}0 type %1</source>
          <target>tentative definition of variable with internal linkage has incomplete {$arg0 :select s0=|non-array| s1=|array|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5694" name="ext_typecheck_function_qualifiers_unspecified">
        <segment>
          <source>'%0' qualifier on function type %1 has no effect and is a Clang extension</source>
          <target>'{$arg0}' qualifier on function type {$arg1} has no effect and is a Clang extension</target>
        </segment>
      </unit>
      <unit id="5695" name="ext_typecheck_indirection_through_void_pointer">
        <segment>
          <source>ISO C does not allow indirection on operand of type %0</source>
          <target>ISO C does not allow indirection on operand of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5696" name="ext_typecheck_ordered_comparison_of_function_pointers">
        <segment>
          <source>ordered comparison of function pointers (%0 and %1)</source>
          <target>ordered comparison of function pointers ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5697" name="ext_typecheck_ordered_comparison_of_pointer_and_zero">
        <segment>
          <source>ordered comparison between pointer and zero (%0 and %1) is an extension</source>
          <target>ordered comparison between pointer and zero ({$arg0} and {$arg1}) is an extension</target>
        </segment>
      </unit>
      <unit id="5698" name="ext_typecheck_ordered_comparison_of_pointer_integer">
        <segment>
          <source>ordered comparison between pointer and integer (%0 and %1)</source>
          <target>ordered comparison between pointer and integer ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="5699" name="ext_typecheck_zero_array_size">
        <segment>
          <source>zero size arrays are an extension</source>
          <target>zero size arrays are an extension</target>
        </segment>
      </unit>
      <unit id="5700" name="ext_typedef_without_a_name">
        <segment>
          <source>typedef requires a name</source>
          <target>typedef requires a name</target>
        </segment>
      </unit>
      <unit id="5701" name="ext_typename_missing">
        <segment>
          <source state="initial">missing 'typename' prior to dependent type name %0</source>
          <target>missing 'typename' prior to dependent type name {$arg0}</target>
        </segment>
      </unit>
      <unit id="5702" name="ext_undeclared_unqual_id_with_dependent_base">
        <segment>
          <source>use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension</source>
          <target>use of undeclared identifier {$arg0}; unqualified lookup into dependent bases of class template {$arg1} is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5703" name="ext_undefined_internal_type">
        <segment>
          <source>ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage</source>
          <target>ISO C++ requires a definition in this translation unit for {$arg0 :select s0=|function| s1=|variable|} {$arg1 :q} because its type does not have linkage</target>
        </segment>
      </unit>
      <unit id="5704" name="ext_unelaborated_friend_type">
        <segment>
          <source>unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1</source>
          <target>unelaborated friend declaration is a C++11 extension; specify '{$arg0 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|}' to befriend {$arg1}</target>
        </segment>
      </unit>
      <unit id="5705" name="ext_union_member_of_reference_type">
        <segment>
          <source>union member %0 has reference type %1, which is a Microsoft extension</source>
          <target>union member {$arg0} has reference type {$arg1}, which is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5706" name="ext_unqualified_base_class">
        <segment>
          <source>unqualified base initializer of class templates is a Microsoft extension</source>
          <target>unqualified base initializer of class templates is a Microsoft extension</target>
        </segment>
      </unit>
      <unit id="5707" name="ext_use_out_of_scope_declaration">
        <segment>
          <source>use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1</source>
          <target>use of out-of-scope declaration of {$arg0}{$arg1 :select s0=|| s1=| whose type is not compatible with that of an implicit declaration|}</target>
        </segment>
      </unit>
      <unit id="5708" name="ext_using_decl_scoped_enumerator">
        <segment>
          <source>using declaration naming a scoped enumerator is a C++20 extension</source>
          <target>using declaration naming a scoped enumerator is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="5709" name="ext_using_undefined_std">
        <segment>
          <source>using directive refers to implicitly-defined namespace 'std'</source>
          <target>using directive refers to implicitly-defined namespace 'std'</target>
        </segment>
      </unit>
      <unit id="5710" name="ext_variable_sized_type_in_struct">
        <segment>
          <source>field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension</source>
          <target>field {$arg0} with variable sized type {$arg1} not at the end of a struct or class is a GNU extension</target>
        </segment>
      </unit>
      <unit id="5711" name="ext_variadic_main">
        <segment>
          <source>'main' is not allowed to be declared variadic</source>
          <target>'main' is not allowed to be declared variadic</target>
        </segment>
      </unit>
      <unit id="5712" name="ext_vla">
        <segment>
          <source>variable length arrays are a C99 feature</source>
          <target>variable length arrays are a C99 feature</target>
        </segment>
      </unit>
      <unit id="5713" name="ext_vla_cxx">
        <segment>
          <source>variable length arrays in C++ are a Clang extension</source>
          <target>variable length arrays in C++ are a Clang extension</target>
        </segment>
      </unit>
      <unit id="5714" name="ext_vla_cxx_in_gnu_mode">
        <segment>
          <source>variable length arrays in C++ are a Clang extension</source>
          <target>variable length arrays in C++ are a Clang extension</target>
        </segment>
      </unit>
      <unit id="5715" name="ext_vla_cxx_in_gnu_mode_static_assert">
        <segment>
          <source>variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?</source>
          <target>variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?</target>
        </segment>
      </unit>
      <unit id="5716" name="ext_vla_cxx_static_assert">
        <segment>
          <source>variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?</source>
          <target>variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?</target>
        </segment>
      </unit>
      <unit id="5717" name="ext_vla_folded_to_constant">
        <segment>
          <source>variable length array folded to constant array as an extension</source>
          <target>variable length array folded to constant array as an extension</target>
        </segment>
      </unit>
      <unit id="5718" name="ext_wchar_t_sign_spec">
        <segment>
          <source>'%0' cannot be signed or unsigned</source>
          <target>'{$arg0}' cannot be signed or unsigned</target>
        </segment>
      </unit>
      <unit id="5719" name="friend_template_decl_malformed_pack_expansion">
        <segment>
          <source>friend declaration expands pack %0 that is declared it its own template parameter list</source>
          <target>friend declaration expands pack {$arg0} that is declared it its own template parameter list</target>
        </segment>
      </unit>
      <unit id="5720" name="note_acc_active_applies_clause_here">
        <segment>
          <source>%select{active|which applies to}0 '%1' clause here</source>
          <target>{$arg0 :select s0=|active| s1=|which applies to|} '{$arg1}' clause here</target>
        </segment>
      </unit>
      <unit id="5721" name="note_acc_active_clause_here">
        <segment>
          <source>active '%0' clause defined here</source>
          <target>active '{$arg0}' clause defined here</target>
        </segment>
      </unit>
      <unit id="5722" name="note_acc_atomic_expected_binop">
        <segment>
          <source>expected binary operation on right hand side of assignment operator</source>
          <target>expected binary operation on right hand side of assignment operator</target>
        </segment>
      </unit>
      <unit id="5723" name="note_acc_atomic_expr_must_be">
        <segment>
          <source>expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression</source>
          <target>expected {$arg0 :select s0=|assignment| s1=|assignment, compound assignment, increment, or decrement|} expression</target>
        </segment>
      </unit>
      <unit id="5724" name="note_acc_atomic_mismatch_compound_operand">
        <segment>
          <source>variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2(%3) must match variable used %select{|in unary expression|on right hand side of assignment|&lt;not possible&gt;|on left hand side of compound assignment|on left hand side of assignment}0(%1) from the first statement</source>
          <target>variable {$arg2 :select s0=|| s1=|in unary expression| s2=|on right hand side of assignment| s3=|on left hand side of assignment| s4=|on left hand side of compound assignment| s5=|on left hand side of assignment|}({$arg3}) must match variable used {$arg0 :select s0=|| s1=|in unary expression| s2=|on right hand side of assignment| s3=|&lt;not possible&gt;| s4=|on left hand side of compound assignment| s5=|on left hand side of assignment|}({$arg1}) from the first statement</target>
        </segment>
      </unit>
      <unit id="5725" name="note_acc_atomic_mismatch_operand">
        <segment>
          <source>left hand side of assignment operation(%0) must match one side of the sub-operation on the right hand side(%1 and %2)</source>
          <target>left hand side of assignment operation({$arg0}) must match one side of the sub-operation on the right hand side({$arg1} and {$arg2})</target>
        </segment>
      </unit>
      <unit id="5726" name="note_acc_atomic_operand_lvalue_scalar">
        <segment>
          <source>%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2</source>
          <target>{$arg0 :select s0=|left | s1=|right | s2=||}operand to {$arg1 :select s0=|assignment| s1=|compound assignment| s2=|increment| s3=|decrement|} expression must be {$arg2 :select s0=|an l-value| s1=|of scalar type (was {$arg3})|}</target>
        </segment>
      </unit>
      <unit id="5727" name="note_acc_atomic_too_many_stmts">
        <segment>
          <source>'atomic capture' with a compound statement only supports two statements</source>
          <target>'atomic capture' with a compound statement only supports two statements</target>
        </segment>
      </unit>
      <unit id="5728" name="note_acc_atomic_unsupported_binary_operator">
        <segment>
          <source>binary operator not supported, only +, *, -, /, &amp;, ^, |, &lt;&lt;, or &gt;&gt; are permitted</source>
          <target>binary operator not supported, only +, *, -, /, &amp;, ^, |, &lt;&lt;, or &gt;&gt; are permitted</target>
        </segment>
      </unit>
      <unit id="5729" name="note_acc_atomic_unsupported_compound_binary_operator">
        <segment>
          <source>compound binary operator not supported, only +=, *=, -=, /=, &amp;=, ^=, |=, &lt;&lt;=, or &gt;&gt;= are permitted</source>
          <target>compound binary operator not supported, only +=, *=, -=, /=, &amp;=, ^=, |=, &lt;&lt;=, or &gt;&gt;= are permitted</target>
        </segment>
      </unit>
      <unit id="5730" name="note_acc_atomic_unsupported_unary_operator">
        <segment>
          <source>unary operator not supported, only increment and decrement operations permitted</source>
          <target>unary operator not supported, only increment and decrement operations permitted</target>
        </segment>
      </unit>
      <unit id="5731" name="note_acc_branch_into_compute_construct">
        <segment>
          <source state="initial">invalid branch into OpenACC Compute/Combined Construct</source>
          <target>invalid branch into OpenACC Compute/Combined Construct</target>
        </segment>
      </unit>
      <unit id="5732" name="note_acc_branch_out_of_compute_construct">
        <segment>
          <source state="initial">invalid branch out of OpenACC Compute/Combined Construct</source>
          <target>invalid branch out of OpenACC Compute/Combined Construct</target>
        </segment>
      </unit>
      <unit id="5733" name="note_acc_construct_here">
        <segment>
          <source>'%0' construct is here</source>
          <target>'{$arg0}' construct is here</target>
        </segment>
      </unit>
      <unit id="5734" name="note_acc_expected_pointer_var">
        <segment>
          <source>expected variable of pointer type</source>
          <target>expected variable of pointer type</target>
        </segment>
      </unit>
      <unit id="5735" name="note_acc_int_expr_conversion">
        <segment>
          <source>conversion to %select{integral|enumeration}0 type %1</source>
          <target>conversion to {$arg0 :select s0=|integral| s1=|enumeration|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5736" name="note_acc_previous_clause_here">
        <segment>
          <source state="initial">previous '%0' clause is here</source>
          <target>previous '{$arg0}' clause is here</target>
        </segment>
      </unit>
      <unit id="5737" name="note_acc_previous_expr_here">
        <segment>
          <source>previous expression is here</source>
          <target>previous expression is here</target>
        </segment>
      </unit>
      <unit id="5738" name="note_acc_previous_reference">
        <segment>
          <source>previous reference is here</source>
          <target>previous reference is here</target>
        </segment>
      </unit>
      <unit id="5739" name="note_acc_reduction_composite_member_loc">
        <segment>
          <source>invalid field is here</source>
          <target>invalid field is here</target>
        </segment>
      </unit>
      <unit id="5740" name="note_access_constrained_by_path">
        <segment>
          <source>constrained by %select{|implicitly }1%select{private|protected}0 inheritance here</source>
          <target>constrained by {$arg1 :select s0=|| s1=|implicitly |}{$arg0 :select s0=|private| s1=|protected|} inheritance here</target>
        </segment>
      </unit>
      <unit id="5741" name="note_access_natural">
        <segment>
          <source>%select{|implicitly }1declared %select{private|protected}0 here</source>
          <target>{$arg1 :select s0=|| s1=|implicitly |}declared {$arg0 :select s0=|private| s1=|protected|} here</target>
        </segment>
      </unit>
      <unit id="5742" name="note_access_protected_restricted_ctordtor">
        <segment>
          <source>protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject</source>
          <target>protected {$arg0 :select s0=|constructor| s1=|destructor|} can only be used to {$arg0 :select s0=|construct| s1=|destroy|} a base class subobject</target>
        </segment>
      </unit>
      <unit id="5743" name="note_access_protected_restricted_noobject">
        <segment>
          <source>must name member using the type of the current context %0</source>
          <target>must name member using the type of the current context {$arg0}</target>
        </segment>
      </unit>
      <unit id="5744" name="note_access_protected_restricted_object">
        <segment>
          <source>can only access this member on an object of type %0</source>
          <target>can only access this member on an object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5745" name="note_add_synthesize_directive">
        <segment>
          <source>add a '@synthesize' directive</source>
          <target>add a '@synthesize' directive</target>
        </segment>
      </unit>
      <unit id="5746" name="note_additional_parens_for_variable_declaration">
        <segment>
          <source>add a pair of parentheses to declare a variable</source>
          <target>add a pair of parentheses to declare a variable</target>
        </segment>
      </unit>
      <unit id="5747" name="note_addrof_ovl_candidate_disabled_by_enable_if_attr">
        <segment>
          <source>candidate function made ineligible by enable_if</source>
          <target>candidate function made ineligible by enable_if</target>
        </segment>
      </unit>
      <unit id="5748" name="note_alignas_on_declaration">
        <segment>
          <source>declared with %0 attribute here</source>
          <target>declared with {$arg0} attribute here</target>
        </segment>
      </unit>
      <unit id="5749" name="note_allocated_here">
        <segment>
          <source>allocated with 'new%select{[]|}0' here</source>
          <target>allocated with 'new{$arg0 :select s0=|[]| s1=||}' here</target>
        </segment>
      </unit>
      <unit id="5750" name="note_ambig_member_ref_object_type">
        <segment>
          <source>lookup in the object type %0 refers here</source>
          <target>lookup in the object type {$arg0} refers here</target>
        </segment>
      </unit>
      <unit id="5751" name="note_ambig_member_ref_scope">
        <segment>
          <source>lookup from the current scope refers here</source>
          <target>lookup from the current scope refers here</target>
        </segment>
      </unit>
      <unit id="5752" name="note_ambiguous_atomic_constraints">
        <segment>
          <source>similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept</source>
          <target>similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept</target>
        </segment>
      </unit>
      <unit id="5753" name="note_ambiguous_atomic_constraints_similar_expression">
        <segment>
          <source>similar constraint expression here</source>
          <target>similar constraint expression here</target>
        </segment>
      </unit>
      <unit id="5754" name="note_ambiguous_candidate">
        <segment>
          <source>candidate found by name lookup is %q0</source>
          <target>candidate found by name lookup is {$arg0 :q}</target>
        </segment>
      </unit>
      <unit id="5755" name="note_ambiguous_inherited_constructor_using">
        <segment>
          <source>inherited from base class %0 here</source>
          <target>inherited from base class {$arg0} here</target>
        </segment>
      </unit>
      <unit id="5756" name="note_ambiguous_member_found">
        <segment>
          <source>member found by ambiguous name lookup</source>
          <target>member found by ambiguous name lookup</target>
        </segment>
      </unit>
      <unit id="5757" name="note_ambiguous_member_type_found">
        <segment>
          <source>member type %0 found by ambiguous name lookup</source>
          <target>member type {$arg0} found by ambiguous name lookup</target>
        </segment>
      </unit>
      <unit id="5758" name="note_ambiguous_type_conversion">
        <segment>
          <source>because of ambiguity in conversion %diff{of $ to $|between types}0,1</source>
          <target>because of ambiguity in conversion %diff{of $ to $|between types}0,1</target>
        </segment>
      </unit>
      <unit id="5759" name="note_amdgcn_load_lds_size_valid_value">
        <segment>
          <source>size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0</source>
          <target>size must be {$arg0 :select s0=|1, 2, or 4| s1=|1, 2, 4, 12 or 16|}</target>
        </segment>
      </unit>
      <unit id="5760" name="note_anonymous_namespace">
        <segment>
          <source>anonymous namespace begins here</source>
          <target>anonymous namespace begins here</target>
        </segment>
      </unit>
      <unit id="5761" name="note_arc_bridge">
        <segment>
          <source>use __bridge to convert directly (no change in ownership)</source>
          <target>use __bridge to convert directly (no change in ownership)</target>
        </segment>
      </unit>
      <unit id="5762" name="note_arc_bridge_retained">
        <segment>
          <source>use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0</source>
          <target>use {$arg1 :select s0=|__bridge_retained| s1=|CFBridgingRetain call|} to make an ARC object available as a +1 {$arg0}</target>
        </segment>
      </unit>
      <unit id="5763" name="note_arc_bridge_transfer">
        <segment>
          <source>use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC</source>
          <target>use {$arg1 :select s0=|__bridge_transfer| s1=|CFBridgingRelease call|} to transfer ownership of a +1 {$arg0} into ARC</target>
        </segment>
      </unit>
      <unit id="5764" name="note_arc_cstyle_bridge">
        <segment>
          <source>use __bridge with C-style cast to convert directly (no change in ownership)</source>
          <target>use __bridge with C-style cast to convert directly (no change in ownership)</target>
        </segment>
      </unit>
      <unit id="5765" name="note_arc_cstyle_bridge_retained">
        <segment>
          <source>use __bridge_retained with C-style cast to make an ARC object available as a +1 %0</source>
          <target>use __bridge_retained with C-style cast to make an ARC object available as a +1 {$arg0}</target>
        </segment>
      </unit>
      <unit id="5766" name="note_arc_cstyle_bridge_transfer">
        <segment>
          <source>use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC</source>
          <target>use __bridge_transfer with C-style cast to transfer ownership of a +1 {$arg0} into ARC</target>
        </segment>
      </unit>
      <unit id="5767" name="note_arc_field_with_ownership">
        <segment>
          <source>field has non-trivial ownership qualification</source>
          <target>field has non-trivial ownership qualification</target>
        </segment>
      </unit>
      <unit id="5768" name="note_arc_forbidden_type">
        <segment>
          <source>declaration uses type that is ill-formed in ARC</source>
          <target>declaration uses type that is ill-formed in ARC</target>
        </segment>
      </unit>
      <unit id="5769" name="note_arc_gained_method_convention">
        <segment>
          <source>declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1</source>
          <target>declaration in interface is not in the '{$arg0 :select s0=|alloc| s1=|copy| s2=|init| s3=|new|}' family because {$arg1 :select s0=|its result type is not an object pointer| s1=|its result type is unrelated to its receiver type|}</target>
        </segment>
      </unit>
      <unit id="5770" name="note_arc_init_returns_unrelated">
        <segment>
          <source>init method must return a type related to its receiver type</source>
          <target>init method must return a type related to its receiver type</target>
        </segment>
      </unit>
      <unit id="5771" name="note_arc_lost_method_convention">
        <segment>
          <source>declaration in interface</source>
          <target>declaration in interface</target>
        </segment>
      </unit>
      <unit id="5772" name="note_arc_retain_cycle_owner">
        <segment>
          <source>block will be retained by %select{the captured object|an object strongly retained by the captured object}0</source>
          <target>block will be retained by {$arg0 :select s0=|the captured object| s1=|an object strongly retained by the captured object|}</target>
        </segment>
      </unit>
      <unit id="5773" name="note_arc_weak_also_accessed_here">
        <segment>
          <source>also accessed here</source>
          <target>also accessed here</target>
        </segment>
      </unit>
      <unit id="5774" name="note_arc_weak_disabled">
        <segment>
          <source>declaration uses __weak, but ARC is disabled</source>
          <target>declaration uses __weak, but ARC is disabled</target>
        </segment>
      </unit>
      <unit id="5775" name="note_arc_weak_no_runtime">
        <segment>
          <source>declaration uses __weak, which the current deployment target does not support</source>
          <target>declaration uses __weak, which the current deployment target does not support</target>
        </segment>
      </unit>
      <unit id="5776" name="note_array_declared_here">
        <segment>
          <source>array %0 declared here</source>
          <target>array {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5777" name="note_array_init_plain_string_into_char8_t">
        <segment>
          <source>add 'u8' prefix to form a 'char8_t' string literal</source>
          <target>add 'u8' prefix to form a 'char8_t' string literal</target>
        </segment>
      </unit>
      <unit id="5778" name="note_array_size_conversion">
        <segment>
          <source>conversion to %select{integral|enumeration}0 type %1 declared here</source>
          <target>conversion to {$arg0 :select s0=|integral| s1=|enumeration|} type {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="5779" name="note_asm_input_duplicate_first">
        <segment>
          <source>constraint '%0' is already present here</source>
          <target>constraint '{$arg0}' is already present here</target>
        </segment>
      </unit>
      <unit id="5780" name="note_asm_missing_constraint_modifier">
        <segment>
          <source>use constraint modifier "%0"</source>
          <target>use constraint modifier "{$arg0}"</target>
        </segment>
      </unit>
      <unit id="5781" name="note_assign_lhs_incomplete">
        <segment>
          <source>type %0 is incomplete</source>
          <target>type {$arg0} is incomplete</target>
        </segment>
      </unit>
      <unit id="5782" name="note_atomic_constraint_evaluated_to_false">
        <segment>
          <source state="initial">%select{and|because}0 %1 evaluated to false</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} evaluated to false</target>
        </segment>
      </unit>
      <unit id="5783" name="note_atomic_constraint_evaluated_to_false_elaborated">
        <segment>
          <source state="initial">%select{and|because}0 %1 (%2 %3 %4) evaluated to false</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} ({$arg2} {$arg3} {$arg4}) evaluated to false</target>
        </segment>
      </unit>
      <unit id="5784" name="note_atomic_property_fixup_suggest">
        <segment>
          <source>setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic</source>
          <target>setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic</target>
        </segment>
      </unit>
      <unit id="5785" name="note_attribute">
        <segment>
          <source>attribute is here</source>
          <target>attribute is here</target>
        </segment>
      </unit>
      <unit id="5786" name="note_attribute_has_no_effect_on_compile_time_if_here">
        <segment>
          <source>annotating the 'if %select{constexpr|consteval}0' statement here</source>
          <target>annotating the 'if {$arg0 :select s0=|constexpr| s1=|consteval|}' statement here</target>
        </segment>
      </unit>
      <unit id="5787" name="note_attribute_has_no_effect_on_infinite_loop_here">
        <segment>
          <source>annotating the infinite loop here</source>
          <target>annotating the infinite loop here</target>
        </segment>
      </unit>
      <unit id="5788" name="note_attribute_overloadable_prev_overload">
        <segment>
          <source>previous %select{unmarked |}0overload of function is here</source>
          <target>previous {$arg0 :select s0=|unmarked | s1=||}overload of function is here</target>
        </segment>
      </unit>
      <unit id="5789" name="note_auto_readonly_iboutlet_fixup_suggest">
        <segment>
          <source>property should be changed to be readwrite</source>
          <target>property should be changed to be readwrite</target>
        </segment>
      </unit>
      <unit id="5790" name="note_availability_specified_here">
        <segment>
          <source>%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here</source>
          <target>{$arg0} has been explicitly marked {$arg1 :select s0=|unavailable| s1=|deleted| s2=|deprecated|} here</target>
        </segment>
      </unit>
      <unit id="5791" name="note_await_ready_no_bool_conversion">
        <segment>
          <source>return type of 'await_ready' is required to be contextually convertible to 'bool'</source>
          <target>return type of 'await_ready' is required to be contextually convertible to 'bool'</target>
        </segment>
      </unit>
      <unit id="5792" name="note_bad_memaccess_silence">
        <segment>
          <source>explicitly cast the pointer to silence this warning</source>
          <target>explicitly cast the pointer to silence this warning</target>
        </segment>
      </unit>
      <unit id="5793" name="note_base_class_specified_here">
        <segment>
          <source>base class %0 specified here</source>
          <target>base class {$arg0} specified here</target>
        </segment>
      </unit>
      <unit id="5794" name="note_bitfield_decl">
        <segment>
          <source>bit-field is declared here</source>
          <target>bit-field is declared here</target>
        </segment>
      </unit>
      <unit id="5795" name="note_bitfield_preferred_type">
        <segment>
          <source>preferred type for bit-field %0 specified here</source>
          <target>preferred type for bit-field {$arg0} specified here</target>
        </segment>
      </unit>
      <unit id="5796" name="note_block_var_fixit_add_initialization">
        <segment>
          <source>did you mean to use __block %0?</source>
          <target>did you mean to use __block {$arg0}?</target>
        </segment>
      </unit>
      <unit id="5797" name="note_building_builtin_dump_struct_call">
        <segment>
          <source>in call to printing function with arguments '(%0)' while dumping struct</source>
          <target>in call to printing function with arguments '({$arg0})' while dumping struct</target>
        </segment>
      </unit>
      <unit id="5798" name="note_building_deduction_guide_here">
        <segment>
          <source>while building implicit deduction guide first needed here</source>
          <target>while building implicit deduction guide first needed here</target>
        </segment>
      </unit>
      <unit id="5799" name="note_called_by">
        <segment>
          <source>called by %0</source>
          <target>called by {$arg0}</target>
        </segment>
      </unit>
      <unit id="5800" name="note_called_once_gets_called_twice">
        <segment>
          <source>previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0</source>
          <target>previous call is here{$arg0 :select s0=|; set to nil to indicate it cannot be called afterwards| s1=||}</target>
        </segment>
      </unit>
      <unit id="5801" name="note_callee_decl">
        <segment>
          <source>%0 declared here</source>
          <target>{$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5802" name="note_callee_static_array">
        <segment>
          <source>callee declares array parameter as static here</source>
          <target>callee declares array parameter as static here</target>
        </segment>
      </unit>
      <unit id="5803" name="note_cannot_use_trivial_abi_reason">
        <segment>
          <source state="initial">'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type|it has an address-discriminated '__ptrauth' field}1</source>
          <target>'trivial_abi' is disallowed on {$arg0} because {$arg1 :select s0=|its copy constructors and move constructors are all deleted| s1=|it is polymorphic| s2=|it has a base of a non-trivial class type| s3=|it has a virtual base| s4=|it has a __weak field| s5=|it has a field of a non-trivial class type| s6=|it has an address-discriminated '__ptrauth' field|}</target>
        </segment>
      </unit>
      <unit id="5804" name="note_carries_dependency_missing_first_decl">
        <segment>
          <source>declaration missing '[[carries_dependency]]' attribute is here</source>
          <target>declaration missing '[[carries_dependency]]' attribute is here</target>
        </segment>
      </unit>
      <unit id="5805" name="note_cast_operand_to_int">
        <segment>
          <source>cast one or both operands to int to silence this warning</source>
          <target>cast one or both operands to int to silence this warning</target>
        </segment>
      </unit>
      <unit id="5806" name="note_cast_to_void">
        <segment>
          <source>cast expression to void to silence warning</source>
          <target>cast expression to void to silence warning</target>
        </segment>
      </unit>
      <unit id="5807" name="note_cat_conform_to_noescape_prot">
        <segment>
          <source>%select{category|class extension}0 conforms to protocol %1 which defines method %2</source>
          <target>{$arg0 :select s0=|category| s1=|class extension|} conforms to protocol {$arg1} which defines method {$arg2}</target>
        </segment>
      </unit>
      <unit id="5808" name="note_change_bitfield_sign">
        <segment>
          <source state="initial">consider making the bit-field type %select{unsigned|signed}0</source>
          <target>consider making the bit-field type {$arg0 :select s0=|unsigned| s1=|signed|}</target>
        </segment>
      </unit>
      <unit id="5809" name="note_change_calling_conv_fixit">
        <segment>
          <source>consider defining %0 with the '%1' calling convention</source>
          <target>consider defining {$arg0} with the '{$arg1}' calling convention</target>
        </segment>
      </unit>
      <unit id="5810" name="note_checking_constraints_for_class_spec_id_here">
        <segment>
          <source>while checking constraint satisfaction for class template partial specialization '%0' required here</source>
          <target>while checking constraint satisfaction for class template partial specialization '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5811" name="note_checking_constraints_for_function_here">
        <segment>
          <source>while checking constraint satisfaction for function '%0' required here</source>
          <target>while checking constraint satisfaction for function '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5812" name="note_checking_constraints_for_template_id_here">
        <segment>
          <source>while checking constraint satisfaction for template '%0' required here</source>
          <target>while checking constraint satisfaction for template '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5813" name="note_checking_constraints_for_var_spec_id_here">
        <segment>
          <source>while checking constraint satisfaction for variable template partial specialization '%0' required here</source>
          <target>while checking constraint satisfaction for variable template partial specialization '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5814" name="note_class_declared">
        <segment>
          <source>class is declared here</source>
          <target>class is declared here</target>
        </segment>
      </unit>
      <unit id="5815" name="note_cocoa_naming_declare_family">
        <segment>
          <source>explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object</source>
          <target>explicitly declare getter %objcinstance0 with '{$arg1}' to return an 'unowned' object</target>
        </segment>
      </unit>
      <unit id="5816" name="note_collapse_loop_count">
        <segment>
          <source>parameter of the 'collapse' clause</source>
          <target>parameter of the 'collapse' clause</target>
        </segment>
      </unit>
      <unit id="5817" name="note_comparison_synthesized_at">
        <segment>
          <source>in defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator for %1 first required here</source>
          <target>in defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator for {$arg1} first required here</target>
        </segment>
      </unit>
      <unit id="5818" name="note_compat_assoc">
        <segment>
          <source>compatible type %0 specified here</source>
          <target>compatible type {$arg0} specified here</target>
        </segment>
      </unit>
      <unit id="5819" name="note_concatenated_string_literal_silence">
        <segment>
          <source>place parentheses around the string literal to silence warning</source>
          <target>place parentheses around the string literal to silence warning</target>
        </segment>
      </unit>
      <unit id="5820" name="note_concept_specialization_constraint_evaluated_to_false">
        <segment>
          <source state="initial">%select{and|because}0 %1 evaluated to false</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} evaluated to false</target>
        </segment>
      </unit>
      <unit id="5821" name="note_concept_specialization_here">
        <segment>
          <source>while checking the satisfaction of concept '%0' requested here</source>
          <target>while checking the satisfaction of concept '{$arg0}' requested here</target>
        </segment>
      </unit>
      <unit id="5822" name="note_condition_assign_silence">
        <segment>
          <source>place parentheses around the assignment to silence this warning</source>
          <target>place parentheses around the assignment to silence this warning</target>
        </segment>
      </unit>
      <unit id="5823" name="note_condition_assign_to_comparison">
        <segment>
          <source>use '==' to turn this assignment into an equality comparison</source>
          <target>use '==' to turn this assignment into an equality comparison</target>
        </segment>
      </unit>
      <unit id="5824" name="note_condition_or_assign_to_comparison">
        <segment>
          <source>use '!=' to turn this compound assignment into an inequality comparison</source>
          <target>use '!=' to turn this compound assignment into an inequality comparison</target>
        </segment>
      </unit>
      <unit id="5825" name="note_conflicting_attribute">
        <segment>
          <source>conflicting attribute is here</source>
          <target>conflicting attribute is here</target>
        </segment>
      </unit>
      <unit id="5826" name="note_conflicting_prototype">
        <segment>
          <source>conflicting prototype is here</source>
          <target>conflicting prototype is here</target>
        </segment>
      </unit>
      <unit id="5827" name="note_conflicting_try_here">
        <segment>
          <source>conflicting %0 here</source>
          <target>conflicting {$arg0} here</target>
        </segment>
      </unit>
      <unit id="5828" name="note_constexpr_assert_failed">
        <segment>
          <source>assertion failed during evaluation of constant expression</source>
          <target>assertion failed during evaluation of constant expression</target>
        </segment>
      </unit>
      <unit id="5829" name="note_constexpr_body_previous_return">
        <segment>
          <source>previous return statement is here</source>
          <target>previous return statement is here</target>
        </segment>
      </unit>
      <unit id="5830" name="note_constexpr_ctor_missing_init">
        <segment>
          <source>member not initialized by constructor</source>
          <target>member not initialized by constructor</target>
        </segment>
      </unit>
      <unit id="5831" name="note_constexpr_dtor_subobject">
        <segment>
          <source>%select{data member %1|base class %2}0 declared here</source>
          <target>{$arg0 :select s0=|data member {$arg1}| s1=|base class {$arg2}|} declared here</target>
        </segment>
      </unit>
      <unit id="5832" name="note_constexpr_virtual_base_here">
        <segment>
          <source>virtual base class declared here</source>
          <target>virtual base class declared here</target>
        </segment>
      </unit>
      <unit id="5833" name="note_constinit_missing_here">
        <segment>
          <source>add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here</source>
          <target>add the {$arg0 :select s0=|'require_constant_initialization' attribute| s1=|'constinit' specifier|} to the initializing declaration here</target>
        </segment>
      </unit>
      <unit id="5834" name="note_constinit_specified_here">
        <segment>
          <source>variable declared constinit here</source>
          <target>variable declared constinit here</target>
        </segment>
      </unit>
      <unit id="5835" name="note_constraint_normalization_here">
        <segment>
          <source state="initial">while calculating associated constraint of template %0 here</source>
          <target>while calculating associated constraint of template {$arg0} here</target>
        </segment>
      </unit>
      <unit id="5836" name="note_constraint_references_error">
        <segment>
          <source>constraint depends on a previously diagnosed expression</source>
          <target>constraint depends on a previously diagnosed expression</target>
        </segment>
      </unit>
      <unit id="5837" name="note_constraint_substitution_here">
        <segment>
          <source>while substituting template arguments into constraint expression here</source>
          <target>while substituting template arguments into constraint expression here</target>
        </segment>
      </unit>
      <unit id="5838" name="note_conv_function_declared_at">
        <segment>
          <source>type conversion function declared here</source>
          <target>type conversion function declared here</target>
        </segment>
      </unit>
      <unit id="5839" name="note_convert_inline_to_static">
        <segment>
          <source>use 'static' to give inline function %0 internal linkage</source>
          <target>use 'static' to give inline function {$arg0} internal linkage</target>
        </segment>
      </unit>
      <unit id="5840" name="note_coroutine_function_declare_noexcept">
        <segment>
          <source>must be declared with 'noexcept'</source>
          <target>must be declared with 'noexcept'</target>
        </segment>
      </unit>
      <unit id="5841" name="note_coroutine_promise_call_implicitly_required">
        <segment>
          <source>call to %0 implicitly required by coroutine function here</source>
          <target>call to {$arg0} implicitly required by coroutine function here</target>
        </segment>
      </unit>
      <unit id="5842" name="note_coroutine_promise_implicit_await_transform_required_here">
        <segment>
          <source>call to 'await_transform' implicitly required by 'co_await' here</source>
          <target>call to 'await_transform' implicitly required by 'co_await' here</target>
        </segment>
      </unit>
      <unit id="5843" name="note_coroutine_promise_suspend_implicitly_required">
        <segment>
          <source>call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0</source>
          <target>call to '{$arg0 :select s0=|initial_suspend| s1=|final_suspend|}' implicitly required by the {$arg0 :select s0=|initial suspend point| s1=|final suspend point|}</target>
        </segment>
      </unit>
      <unit id="5844" name="note_coroutine_unusable_type_aware_allocators">
        <segment>
          <source>type aware %0 will not be used for coroutine allocation</source>
          <target>type aware {$arg0} will not be used for coroutine allocation</target>
        </segment>
      </unit>
      <unit id="5845" name="note_counted_by_consider_completing_pointee_ty">
        <segment>
          <source>consider providing a complete definition for %0</source>
          <target>consider providing a complete definition for {$arg0}</target>
        </segment>
      </unit>
      <unit id="5846" name="note_counted_by_consider_using_sized_by">
        <segment>
          <source>consider using '__sized_by%select{|_or_null}0' instead of '__counted_by%select{|_or_null}0'</source>
          <target>consider using '__sized_by{$arg0 :select s0=|| s1=|_or_null|}' instead of '__counted_by{$arg0 :select s0=|| s1=|_or_null|}'</target>
        </segment>
      </unit>
      <unit id="5847" name="note_cuda_conflicting_device_function_declared_here">
        <segment>
          <source>conflicting __device__ function declared here</source>
          <target>conflicting __device__ function declared here</target>
        </segment>
      </unit>
      <unit id="5848" name="note_cuda_const_var_unpromoted">
        <segment>
          <source>const variable cannot be emitted on device side due to dynamic initialization</source>
          <target>const variable cannot be emitted on device side due to dynamic initialization</target>
        </segment>
      </unit>
      <unit id="5849" name="note_cuda_device_builtin_surftex_cls_should_have_match_arg">
        <segment>
          <source>the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2</source>
          <target>the {$arg1 :select s0=|1st| s1=|2nd| s2=|3rd|} template parameter of {$arg0} needs to be {$arg2 :select s0=|a type| s1=|an integer or enum value|}</target>
        </segment>
      </unit>
      <unit id="5850" name="note_cuda_device_builtin_surftex_cls_should_have_n_args">
        <segment>
          <source>%0 needs to have exactly %1 template parameters</source>
          <target>{$arg0} needs to have exactly {$arg1} template parameters</target>
        </segment>
      </unit>
      <unit id="5851" name="note_cuda_device_builtin_surftex_should_be_template_class">
        <segment>
          <source>%0 needs to be instantiated from a class template with proper template arguments</source>
          <target>{$arg0} needs to be instantiated from a class template with proper template arguments</target>
        </segment>
      </unit>
      <unit id="5852" name="note_cuda_host_var">
        <segment>
          <source>host variable declared here</source>
          <target>host variable declared here</target>
        </segment>
      </unit>
      <unit id="5853" name="note_cuda_ovl_candidate_target_mismatch">
        <segment>
          <source>candidate template ignored: target attributes do not match</source>
          <target>candidate template ignored: target attributes do not match</target>
        </segment>
      </unit>
      <unit id="5854" name="note_cxx20_c23_compat_utf8_string_remove_u8">
        <segment>
          <source>remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8</source>
          <target>remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8</target>
        </segment>
      </unit>
      <unit id="5855" name="note_decl_unguarded_availability_silence">
        <segment>
          <source>annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning</source>
          <target>annotate {$arg0 :select s0=|{$arg1}| s1=|anonymous {$arg1}|} with an availability attribute to silence this warning</target>
        </segment>
      </unit>
      <unit id="5856" name="note_declaration_not_a_prototype">
        <segment>
          <source>this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0</source>
          <target>this declaration is not a prototype; add {$arg0 :select s0=|'void'| s1=|parameter declarations|} to make it {$arg0 :select s0=|a prototype for a zero-parameter function| s1=|one|}</target>
        </segment>
      </unit>
      <unit id="5857" name="note_declare_parameter_strong">
        <segment>
          <source>declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools</source>
          <target>declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools</target>
        </segment>
      </unit>
      <unit id="5858" name="note_declared_coroutine_here">
        <segment>
          <source>function is a coroutine due to use of '%0' here</source>
          <target>function is a coroutine due to use of '{$arg0}' here</target>
        </segment>
      </unit>
      <unit id="5859" name="note_declared_nonnull">
        <segment>
          <source>declared %select{'returns_nonnull'|'nonnull'}0 here</source>
          <target>declared {$arg0 :select s0=|'returns_nonnull'| s1=|'nonnull'|} here</target>
        </segment>
      </unit>
      <unit id="5860" name="note_declared_required_constant_init_here">
        <segment>
          <source>required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here</source>
          <target>required by {$arg0 :select s0=|'require_constant_initialization' attribute| s1=|'constinit' specifier|} here</target>
        </segment>
      </unit>
      <unit id="5861" name="note_deduced_template_arg_substitution_here">
        <segment>
          <source>during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3</source>
          <target>during template argument deduction for {$arg0 :select s0=|class| s1=|variable|} template {$arg1 :select s0=|partial specialization | s1=||}{$arg2} {$arg3}</target>
        </segment>
      </unit>
      <unit id="5862" name="note_deduction_guide_access">
        <segment>
          <source>deduction guide declared %0 by intervening access specifier</source>
          <target>deduction guide declared {$arg0} by intervening access specifier</target>
        </segment>
      </unit>
      <unit id="5863" name="note_deduction_guide_template_access">
        <segment>
          <source>member template declared %0 here</source>
          <target>member template declared {$arg0} here</target>
        </segment>
      </unit>
      <unit id="5864" name="note_default_arg_instantiation_here">
        <segment>
          <source>in instantiation of default argument for '%0' required here</source>
          <target>in instantiation of default argument for '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5865" name="note_default_argument_declared_here">
        <segment>
          <source>default argument declared here</source>
          <target>default argument declared here</target>
        </segment>
      </unit>
      <unit id="5866" name="note_default_constructed_field">
        <segment>
          <source>default constructed field %0 declared here</source>
          <target>default constructed field {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5867" name="note_default_function_arg_instantiation_here">
        <segment>
          <source>in instantiation of default function argument expression for '%0' required here</source>
          <target>in instantiation of default function argument expression for '{$arg0}' required here</target>
        </segment>
      </unit>
      <unit id="5868" name="note_default_init_const_member">
        <segment>
          <source>member %0 declared 'const' here</source>
          <target>member {$arg0} declared 'const' here</target>
        </segment>
      </unit>
      <unit id="5869" name="note_default_member_initializer_not_yet_parsed">
        <segment>
          <source>default member initializer declared here</source>
          <target>default member initializer declared here</target>
        </segment>
      </unit>
      <unit id="5870" name="note_defaulted_comparison_ambiguous">
        <segment>
          <source>defaulted %0 is implicitly deleted because implied %select{|'==' |'&lt;' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous</source>
          <target>defaulted {$arg0} is implicitly deleted because implied {$arg1 :select s0=|| s1=|'==' | s2=|'&lt;' |}comparison {$arg2 :select s0=|| s1=|for member {$arg3} | s2=|for base class {$arg3} |}is ambiguous</target>
        </segment>
      </unit>
      <unit id="5871" name="note_defaulted_comparison_calls_deleted">
        <segment>
          <source>defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1</source>
          <target>defaulted {$arg0} is implicitly deleted because it would invoke a deleted comparison function{$arg1 :select s0=|| s1=| for member {$arg2}| s2=| for base class {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="5872" name="note_defaulted_comparison_cannot_deduce">
        <segment>
          <source>return type of defaulted 'operator&lt;=&gt;' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type</source>
          <target>return type of defaulted 'operator&lt;=&gt;' cannot be deduced because return type {$arg2} of three-way comparison for {$arg0 :select s0=|| s1=|member| s2=|base class|} {$arg1} is not a standard comparison category type</target>
        </segment>
      </unit>
      <unit id="5873" name="note_defaulted_comparison_cannot_deduce_callee">
        <segment>
          <source>selected 'operator&lt;=&gt;' for %select{|member|base class}0 %1 declared here</source>
          <target>selected 'operator&lt;=&gt;' for {$arg0 :select s0=|| s1=|member| s2=|base class|} {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="5874" name="note_defaulted_comparison_cannot_deduce_undeduced_auto">
        <segment>
          <source>%select{|member|base class}0 %1 declared here</source>
          <target>{$arg0 :select s0=|| s1=|member| s2=|base class|} {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="5875" name="note_defaulted_comparison_inaccessible">
        <segment>
          <source>defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1</source>
          <target>defaulted {$arg0} is implicitly deleted because it would invoke a {$arg3 :select s0=|private| s1=|protected|} {$arg4}{$arg1 :select s0=| member of {$arg6}| s1=| member of {$arg6} to compare member {$arg2}| s2=| to compare base class {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="5876" name="note_defaulted_comparison_no_viable_function">
        <segment>
          <source>defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3</source>
          <target>defaulted {$arg0} is implicitly deleted because there is no viable {$arg1 :select s0=|three-way comparison function| s1=|'operator=='|} for {$arg2 :select s0=|| s1=|member | s2=|base class |}{$arg3}</target>
        </segment>
      </unit>
      <unit id="5877" name="note_defaulted_comparison_no_viable_function_synthesized">
        <segment>
          <source>three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'&lt;'}0 comparison</source>
          <target>three-way comparison cannot be synthesized because there is no viable function for {$arg0 :select s0=|'=='| s1=|'&lt;'|} comparison</target>
        </segment>
      </unit>
      <unit id="5878" name="note_defaulted_comparison_not_constexpr">
        <segment>
          <source>non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0</source>
          <target>non-constexpr comparison function would be used to compare {$arg0 :select s0=|| s1=|member {$arg1}| s2=|base class {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="5879" name="note_defaulted_comparison_not_constexpr_here">
        <segment>
          <source>non-constexpr comparison function declared here</source>
          <target>non-constexpr comparison function declared here</target>
        </segment>
      </unit>
      <unit id="5880" name="note_defaulted_comparison_not_rewritten_callee">
        <segment>
          <source>defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison</source>
          <target>defaulted {$arg0} is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison</target>
        </segment>
      </unit>
      <unit id="5881" name="note_defaulted_comparison_not_rewritten_conversion">
        <segment>
          <source>defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison</source>
          <target>defaulted {$arg0} is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison</target>
        </segment>
      </unit>
      <unit id="5882" name="note_defaulted_comparison_reference_member">
        <segment>
          <source>defaulted %0 is implicitly deleted because class %1 has a reference member</source>
          <target>defaulted {$arg0} is implicitly deleted because class {$arg1} has a reference member</target>
        </segment>
      </unit>
      <unit id="5883" name="note_defaulted_comparison_union">
        <segment>
          <source>defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members</source>
          <target>defaulted {$arg0} is implicitly deleted because {$arg2} is a {$arg1 :select s0=|union-like class| s1=|union|} with variant members</target>
        </segment>
      </unit>
      <unit id="5884" name="note_defaulted_comparison_vector_types">
        <segment>
          <source>defaulted %0 is implicitly deleted because defaulted comparison of vector types is not supported</source>
          <target>defaulted {$arg0} is implicitly deleted because defaulted comparison of vector types is not supported</target>
        </segment>
      </unit>
      <unit id="5885" name="note_defined_here">
        <segment>
          <source>%0 defined here</source>
          <target>{$arg0} defined here</target>
        </segment>
      </unit>
      <unit id="5886" name="note_delete_conversion">
        <segment>
          <source>conversion to pointer type %0</source>
          <target>conversion to pointer type {$arg0}</target>
        </segment>
      </unit>
      <unit id="5887" name="note_delete_non_virtual">
        <segment>
          <source>qualify call to silence this warning</source>
          <target>qualify call to silence this warning</target>
        </segment>
      </unit>
      <unit id="5888" name="note_deleted_assign_field">
        <segment>
          <source>%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3</source>
          <target>{$arg0 :select s0=|copy| s1=|move|} assignment operator of {$arg1} is implicitly deleted because field {$arg2} is of {$arg4 :select s0=|reference| s1=|const-qualified|} type {$arg3}</target>
        </segment>
      </unit>
      <unit id="5889" name="note_deleted_copy_ctor_rvalue_reference">
        <segment>
          <source>copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2</source>
          <target>copy constructor of {$arg0} is implicitly deleted because field {$arg1} is of rvalue reference type {$arg2}</target>
        </segment>
      </unit>
      <unit id="5890" name="note_deleted_copy_user_declared_move">
        <segment>
          <source>copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2</source>
          <target>copy {$arg0 :select s0=|constructor| s1=|assignment operator|} is implicitly deleted because {$arg1} has a user-declared move {$arg2 :select s0=|constructor| s1=|assignment operator|}</target>
        </segment>
      </unit>
      <unit id="5891" name="note_deleted_default_ctor_all_const">
        <segment>
          <source>%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified</source>
          <target>{$arg0 :select s0=|default constructor of| s1=|constructor inherited by|} {$arg1} is implicitly deleted because all {$arg2 :select s0=|data members| s1=|data members of an anonymous union member|} are const-qualified</target>
        </segment>
      </unit>
      <unit id="5892" name="note_deleted_default_ctor_uninit_field">
        <segment>
          <source>%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized</source>
          <target>{$arg0 :select s0=|default constructor of| s1=|constructor inherited by|} {$arg1} is implicitly deleted because field {$arg2} of {$arg4 :select s0=|reference| s1=|const-qualified|} type {$arg3} would not be initialized</target>
        </segment>
      </unit>
      <unit id="5893" name="note_deleted_dtor_no_operator_delete">
        <segment>
          <source>virtual destructor requires an unambiguous, accessible 'operator delete'</source>
          <target>virtual destructor requires an unambiguous, accessible 'operator delete'</target>
        </segment>
      </unit>
      <unit id="5894" name="note_deleted_special_member_class_subobject">
        <segment>
          <source state="initial">%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer|has an address-discriminated '__ptrauth' qualifier}6</source>
          <target>{$arg0 :select s0=|default constructor of| s1=|copy constructor of| s2=|move constructor of| s3=|copy assignment operator of| s4=|move assignment operator of| s5=|destructor of| s6=|constructor inherited by|} {$arg1} is implicitly deleted because %select{base class {$arg3}|{$arg2 :select s0=|| s1=|| s2=|| s3=|| s4=|variant }4field {$arg3}|} %select{has {$arg4 :select s0=|no| s1=|a deleted| s2=|multiple| s3=|an inaccessible| s4=|a non-trivial|} %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|{$arg5 :select s0=|default| s1=|corresponding| s2=|default| s3=|default| s4=|default}4 constructor}0| s5=|destructor|}{$arg6 :select s0=|| s1=|| s2=|s| s3=|| s4=|}4| s5=|is an ObjC pointer| s6=|has an address-discriminated '__ptrauth' qualifier|}</target>
        </segment>
      </unit>
      <unit id="5895" name="note_deleted_type_mismatch">
        <segment>
          <source>function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0</source>
          <target>function is implicitly deleted because its declared type does not match the type of an implicit {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|}</target>
        </segment>
      </unit>
      <unit id="5896" name="note_dependent_function_template_spec_discard_reason">
        <segment>
          <source>candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0</source>
          <target>candidate ignored: %select{not a function template|not a member of the enclosing {$arg0 :select s0=|class template| s1=|namespace; did you mean to explicitly qualify the specialization?}1|}</target>
        </segment>
      </unit>
      <unit id="5897" name="note_dependent_member_use">
        <segment>
          <source>must qualify identifier to find this declaration in dependent base class</source>
          <target>must qualify identifier to find this declaration in dependent base class</target>
        </segment>
      </unit>
      <unit id="5898" name="note_dependent_non_type_default_arg_in_partial_spec">
        <segment>
          <source>template parameter is used in default argument declared here</source>
          <target>template parameter is used in default argument declared here</target>
        </segment>
      </unit>
      <unit id="5899" name="note_deprecated_this_capture">
        <segment>
          <source>add an explicit capture of 'this' to capture '*this' by reference</source>
          <target>add an explicit capture of 'this' to capture '*this' by reference</target>
        </segment>
      </unit>
      <unit id="5900" name="note_designated_init_mixed">
        <segment>
          <source>first non-designated initializer is here</source>
          <target>first non-designated initializer is here</target>
        </segment>
      </unit>
      <unit id="5901" name="note_destructor_nontype_here">
        <segment>
          <source>non-type declaration found by destructor name lookup</source>
          <target>non-type declaration found by destructor name lookup</target>
        </segment>
      </unit>
      <unit id="5902" name="note_destructor_type_here">
        <segment>
          <source>type %0 found by destructor name lookup</source>
          <target>type {$arg0} found by destructor name lookup</target>
        </segment>
      </unit>
      <unit id="5903" name="note_direct_member_here">
        <segment>
          <source>direct member declared here</source>
          <target>direct member declared here</target>
        </segment>
      </unit>
      <unit id="5904" name="note_direct_method_declared_at">
        <segment>
          <source>direct method %0 declared here</source>
          <target>direct method {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5905" name="note_due_to_dllexported_class">
        <segment>
          <source>due to %0 being dllexported%select{|; try compiling in C++11 mode}1</source>
          <target>due to {$arg0} being dllexported{$arg1 :select s0=|| s1=|; try compiling in C++11 mode|}</target>
        </segment>
      </unit>
      <unit id="5906" name="note_duplicate_asm_operand_name">
        <segment>
          <source>asm operand name "%0" first referenced here</source>
          <target>asm operand name "{$arg0}" first referenced here</target>
        </segment>
      </unit>
      <unit id="5907" name="note_duplicate_element">
        <segment>
          <source>element %0 also has value %1</source>
          <target>element {$arg0} also has value {$arg1}</target>
        </segment>
      </unit>
      <unit id="5908" name="note_empty_body_on_separate_line">
        <segment>
          <source>put the semicolon on a separate line to silence this warning</source>
          <target>put the semicolon on a separate line to silence this warning</target>
        </segment>
      </unit>
      <unit id="5909" name="note_empty_parens_default_ctor">
        <segment>
          <source>remove parentheses to declare a variable</source>
          <target>remove parentheses to declare a variable</target>
        </segment>
      </unit>
      <unit id="5910" name="note_empty_parens_function_call">
        <segment>
          <source>change this ',' to a ';' to call %0</source>
          <target>change this ',' to a ';' to call {$arg0}</target>
        </segment>
      </unit>
      <unit id="5911" name="note_empty_parens_zero_initialize">
        <segment>
          <source>replace parentheses with an initializer to declare a variable</source>
          <target>replace parentheses with an initializer to declare a variable</target>
        </segment>
      </unit>
      <unit id="5912" name="note_empty_using_if_exists_here">
        <segment>
          <source>using declaration annotated with 'using_if_exists' here</source>
          <target>using declaration annotated with 'using_if_exists' here</target>
        </segment>
      </unit>
      <unit id="5913" name="note_enforce_read_only_placement">
        <segment>
          <source>type was declared read-only here</source>
          <target>type was declared read-only here</target>
        </segment>
      </unit>
      <unit id="5914" name="note_enters_block_captures_cxx_obj">
        <segment>
          <source>jump enters lifetime of block which captures a destructible C++ object</source>
          <target>jump enters lifetime of block which captures a destructible C++ object</target>
        </segment>
      </unit>
      <unit id="5915" name="note_enters_block_captures_non_trivial_c_struct">
        <segment>
          <source>jump enters lifetime of block which captures a C struct that is non-trivial to destroy</source>
          <target>jump enters lifetime of block which captures a C struct that is non-trivial to destroy</target>
        </segment>
      </unit>
      <unit id="5916" name="note_enters_block_captures_strong">
        <segment>
          <source>jump enters lifetime of block which strongly captures a variable</source>
          <target>jump enters lifetime of block which strongly captures a variable</target>
        </segment>
      </unit>
      <unit id="5917" name="note_enters_block_captures_weak">
        <segment>
          <source>jump enters lifetime of block which weakly captures a variable</source>
          <target>jump enters lifetime of block which weakly captures a variable</target>
        </segment>
      </unit>
      <unit id="5918" name="note_enters_compound_literal_scope">
        <segment>
          <source>jump enters lifetime of a compound literal that is non-trivial to destruct</source>
          <target>jump enters lifetime of a compound literal that is non-trivial to destruct</target>
        </segment>
      </unit>
      <unit id="5919" name="note_enters_statement_expression">
        <segment>
          <source>jump enters a statement expression</source>
          <target>jump enters a statement expression</target>
        </segment>
      </unit>
      <unit id="5920" name="note_entity_declared_at">
        <segment>
          <source>%0 declared here</source>
          <target>{$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5921" name="note_enum_friend">
        <segment>
          <source>remove 'enum%select{| struct| class}0' to befriend an enum</source>
          <target>remove 'enum{$arg0 :select s0=|| s1=| struct| s2=| class|}' to befriend an enum</target>
        </segment>
      </unit>
      <unit id="5922" name="note_enum_specialized_here">
        <segment>
          <source>enum %0 was explicitly specialized here</source>
          <target>enum {$arg0} was explicitly specialized here</target>
        </segment>
      </unit>
      <unit id="5923" name="note_equality_comparison_silence">
        <segment>
          <source>remove extraneous parentheses around the comparison to silence this warning</source>
          <target>remove extraneous parentheses around the comparison to silence this warning</target>
        </segment>
      </unit>
      <unit id="5924" name="note_equality_comparison_to_assign">
        <segment>
          <source>use '=' to turn this equality comparison into an assignment</source>
          <target>use '=' to turn this equality comparison into an assignment</target>
        </segment>
      </unit>
      <unit id="5925" name="note_equivalent_internal_linkage_decl">
        <segment>
          <source>declared here%select{ in module '%1'|}0</source>
          <target>declared here{$arg0 :select s0=| in module '{$arg1}'| s1=||}</target>
        </segment>
      </unit>
      <unit id="5926" name="note_evaluate_comparison_first">
        <segment>
          <source>place parentheses around comparison expression to evaluate it first</source>
          <target>place parentheses around comparison expression to evaluate it first</target>
        </segment>
      </unit>
      <unit id="5927" name="note_evaluating_exception_spec_here">
        <segment>
          <source>in evaluation of exception specification for %q0 needed here</source>
          <target>in evaluation of exception specification for {$arg0 :q} needed here</target>
        </segment>
      </unit>
      <unit id="5928" name="note_exits___block">
        <segment>
          <source>jump exits scope of __block variable</source>
          <target>jump exits scope of __block variable</target>
        </segment>
      </unit>
      <unit id="5929" name="note_exits_block_captures_cxx_obj">
        <segment>
          <source>jump exits lifetime of block which captures a destructible C++ object</source>
          <target>jump exits lifetime of block which captures a destructible C++ object</target>
        </segment>
      </unit>
      <unit id="5930" name="note_exits_block_captures_non_trivial_c_struct">
        <segment>
          <source>jump exits lifetime of block which captures a C struct that is non-trivial to destroy</source>
          <target>jump exits lifetime of block which captures a C struct that is non-trivial to destroy</target>
        </segment>
      </unit>
      <unit id="5931" name="note_exits_block_captures_strong">
        <segment>
          <source>jump exits lifetime of block which strongly captures a variable</source>
          <target>jump exits lifetime of block which strongly captures a variable</target>
        </segment>
      </unit>
      <unit id="5932" name="note_exits_block_captures_weak">
        <segment>
          <source>jump exits lifetime of block which weakly captures a variable</source>
          <target>jump exits lifetime of block which weakly captures a variable</target>
        </segment>
      </unit>
      <unit id="5933" name="note_exits_cleanup">
        <segment>
          <source>jump exits scope of variable with __attribute__((cleanup))</source>
          <target>jump exits scope of variable with __attribute__((cleanup))</target>
        </segment>
      </unit>
      <unit id="5934" name="note_exits_compound_literal_scope">
        <segment>
          <source>jump exits lifetime of a compound literal that is non-trivial to destruct</source>
          <target>jump exits lifetime of a compound literal that is non-trivial to destruct</target>
        </segment>
      </unit>
      <unit id="5935" name="note_exits_cxx_catch">
        <segment>
          <source>jump exits catch block</source>
          <target>jump exits catch block</target>
        </segment>
      </unit>
      <unit id="5936" name="note_exits_cxx_try">
        <segment>
          <source>jump exits try block</source>
          <target>jump exits try block</target>
        </segment>
      </unit>
      <unit id="5937" name="note_exits_dtor">
        <segment>
          <source>jump exits scope of variable with non-trivial destructor</source>
          <target>jump exits scope of variable with non-trivial destructor</target>
        </segment>
      </unit>
      <unit id="5938" name="note_exits_objc_autoreleasepool">
        <segment>
          <source>jump exits autoreleasepool block</source>
          <target>jump exits autoreleasepool block</target>
        </segment>
      </unit>
      <unit id="5939" name="note_exits_objc_catch">
        <segment>
          <source>jump exits @catch block</source>
          <target>jump exits @catch block</target>
        </segment>
      </unit>
      <unit id="5940" name="note_exits_objc_finally">
        <segment>
          <source>jump exits @finally block</source>
          <target>jump exits @finally block</target>
        </segment>
      </unit>
      <unit id="5941" name="note_exits_objc_strong">
        <segment>
          <source>jump exits scope of __strong variable</source>
          <target>jump exits scope of __strong variable</target>
        </segment>
      </unit>
      <unit id="5942" name="note_exits_objc_synchronized">
        <segment>
          <source>jump exits @synchronized block</source>
          <target>jump exits @synchronized block</target>
        </segment>
      </unit>
      <unit id="5943" name="note_exits_objc_try">
        <segment>
          <source>jump exits @try block</source>
          <target>jump exits @try block</target>
        </segment>
      </unit>
      <unit id="5944" name="note_exits_objc_weak">
        <segment>
          <source>jump exits scope of __weak variable</source>
          <target>jump exits scope of __weak variable</target>
        </segment>
      </unit>
      <unit id="5945" name="note_exits_seh_except">
        <segment>
          <source>jump exits __except block</source>
          <target>jump exits __except block</target>
        </segment>
      </unit>
      <unit id="5946" name="note_exits_seh_finally">
        <segment>
          <source>jump exits __finally block</source>
          <target>jump exits __finally block</target>
        </segment>
      </unit>
      <unit id="5947" name="note_exits_seh_try">
        <segment>
          <source>jump exits __try block</source>
          <target>jump exits __try block</target>
        </segment>
      </unit>
      <unit id="5948" name="note_exits_temporary_dtor">
        <segment>
          <source>jump exits scope of lifetime-extended temporary with non-trivial destructor</source>
          <target>jump exits scope of lifetime-extended temporary with non-trivial destructor</target>
        </segment>
      </unit>
      <unit id="5949" name="note_explicit_ctor_deduction_guide_here">
        <segment>
          <source>explicit %select{constructor|deduction guide}0 declared here</source>
          <target>explicit {$arg0 :select s0=|constructor| s1=|deduction guide|} declared here</target>
        </segment>
      </unit>
      <unit id="5950" name="note_explicit_instantiation_candidate">
        <segment>
          <source>explicit instantiation candidate function %q0 template here %1</source>
          <target>explicit instantiation candidate function {$arg0 :q} template here {$arg1}</target>
        </segment>
      </unit>
      <unit id="5951" name="note_explicit_instantiation_definition_here">
        <segment>
          <source>explicit instantiation definition is here</source>
          <target>explicit instantiation definition is here</target>
        </segment>
      </unit>
      <unit id="5952" name="note_explicit_instantiation_here">
        <segment>
          <source>explicit instantiation refers here</source>
          <target>explicit instantiation refers here</target>
        </segment>
      </unit>
      <unit id="5953" name="note_explicit_template_arg_substitution_here">
        <segment>
          <source>while substituting explicitly-specified template arguments into function template %0 %1</source>
          <target>while substituting explicitly-specified template arguments into function template {$arg0} {$arg1}</target>
        </segment>
      </unit>
      <unit id="5954" name="note_explicit_template_spec_does_not_need_header">
        <segment>
          <source>'template&lt;&gt;' header not required for explicitly-specialized class %0 declared here</source>
          <target>'template&lt;&gt;' header not required for explicitly-specialized class {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5955" name="note_export">
        <segment>
          <source>export block begins here</source>
          <target>export block begins here</target>
        </segment>
      </unit>
      <unit id="5956" name="note_expr_evaluates_to">
        <segment>
          <source>expression evaluates to '%0 %1 %2'</source>
          <target>expression evaluates to '{$arg0} {$arg1} {$arg2}'</target>
        </segment>
      </unit>
      <unit id="5957" name="note_expr_requirement_constraints_not_satisfied">
        <segment>
          <source state="initial">%select{and|because}0 type constraint %1 was not satisfied:</source>
          <target>{$arg0 :select s0=|and| s1=|because|} type constraint {$arg1} was not satisfied:</target>
        </segment>
      </unit>
      <unit id="5958" name="note_expr_requirement_constraints_not_satisfied_simple">
        <segment>
          <source>%select{and|because}0 %1 does not satisfy %2:</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} does not satisfy {$arg2}:</target>
        </segment>
      </unit>
      <unit id="5959" name="note_expr_requirement_expr_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid: %2</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid: {$arg2}</target>
        </segment>
      </unit>
      <unit id="5960" name="note_expr_requirement_expr_unknown_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid</target>
        </segment>
      </unit>
      <unit id="5961" name="note_expr_requirement_noexcept_not_met">
        <segment>
          <source state="initial">%select{and|because}0 %1 may throw an exception</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} may throw an exception</target>
        </segment>
      </unit>
      <unit id="5962" name="note_expr_requirement_type_requirement_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid: %2</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid: {$arg2}</target>
        </segment>
      </unit>
      <unit id="5963" name="note_expr_requirement_type_requirement_unknown_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid</target>
        </segment>
      </unit>
      <unit id="5964" name="note_extern_c_begins_here">
        <segment>
          <source>extern "C" language linkage specification begins here</source>
          <target>extern "C" language linkage specification begins here</target>
        </segment>
      </unit>
      <unit id="5965" name="note_extern_c_global_conflict">
        <segment>
          <source>declared %select{in global scope|with C language linkage}0 here</source>
          <target>declared {$arg0 :select s0=|in global scope| s1=|with C language linkage|} here</target>
        </segment>
      </unit>
      <unit id="5966" name="note_fallthrough_insert_semi_fixit">
        <segment>
          <source>did you forget ';'?</source>
          <target>did you forget ';'?</target>
        </segment>
      </unit>
      <unit id="5967" name="note_field_designator_found">
        <segment>
          <source>field designator refers here</source>
          <target>field designator refers here</target>
        </segment>
      </unit>
      <unit id="5968" name="note_final_dtor_non_final_class_silence">
        <segment>
          <source>mark %0 as '%select{final|sealed}1' to silence this warning</source>
          <target>mark {$arg0} as '{$arg1 :select s0=|final| s1=|sealed|}' to silence this warning</target>
        </segment>
      </unit>
      <unit id="5969" name="note_final_overrider">
        <segment>
          <source>final overrider of %q0 in %1</source>
          <target>final overrider of {$arg0 :q} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="5970" name="note_flexible_array_counted_by_attr_field">
        <segment>
          <source>field %0 declared here</source>
          <target>field {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="5971" name="note_flexible_array_member">
        <segment>
          <source>initialized flexible array member %0 is here</source>
          <target>initialized flexible array member {$arg0} is here</target>
        </segment>
      </unit>
      <unit id="5972" name="note_for_range_begin_end">
        <segment>
          <source>selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3</source>
          <target>selected '{$arg0 :select s0=|begin| s1=|end|}' {$arg1 :select s0=|function| s1=|template |}{$arg2} with iterator type {$arg3}</target>
        </segment>
      </unit>
      <unit id="5973" name="note_for_range_invalid_iterator">
        <segment>
          <source>in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1</source>
          <target>in implicit call to 'operator{$arg0 :select s0=|!=| s1=|*| s2=|++|}' for iterator of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="5974" name="note_for_range_member_begin_end_ignored">
        <segment>
          <source>member is not a candidate because range type %0 has no '%select{end|begin}1' member</source>
          <target>member is not a candidate because range type {$arg0} has no '{$arg1 :select s0=|end| s1=|begin|}' member</target>
        </segment>
      </unit>
      <unit id="5975" name="note_format_cmp_with">
        <segment>
          <source>comparing with this %select{specifier|format string}0</source>
          <target>comparing with this {$arg0 :select s0=|specifier| s1=|format string|}</target>
        </segment>
      </unit>
      <unit id="5976" name="note_format_fix_specifier">
        <segment>
          <source>did you mean to use '%0'?</source>
          <target>did you mean to use '{$arg0}'?</target>
        </segment>
      </unit>
      <unit id="5977" name="note_format_security_fixit">
        <segment>
          <source>treat the string as an argument to avoid this</source>
          <target>treat the string as an argument to avoid this</target>
        </segment>
      </unit>
      <unit id="5978" name="note_format_string_defined">
        <segment>
          <source>format string is defined here</source>
          <target>format string is defined here</target>
        </segment>
      </unit>
      <unit id="5979" name="note_forward_class">
        <segment>
          <source>forward declaration of class here</source>
          <target>forward declaration of class here</target>
        </segment>
      </unit>
      <unit id="5980" name="note_forward_class_conversion">
        <segment>
          <source>%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1</source>
          <target>{$arg0} is not defined, but forward declared here; conversion would be valid if it was derived from {$arg1}</target>
        </segment>
      </unit>
      <unit id="5981" name="note_forward_template_decl">
        <segment>
          <source>forward declaration of template entity is here</source>
          <target>forward declaration of template entity is here</target>
        </segment>
      </unit>
      <unit id="5982" name="note_found_mutex_near_match">
        <segment>
          <source>found near match '%0'</source>
          <target>found near match '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="5983" name="note_from_diagnose_if">
        <segment>
          <source>from 'diagnose_if' attribute on %0:</source>
          <target>from 'diagnose_if' attribute on {$arg0}:</target>
        </segment>
      </unit>
      <unit id="5984" name="note_func_effect_call_disallows_inference">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block|} does not permit inference of '{$arg1}' because it is declared '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="5985" name="note_func_effect_call_extern">
        <segment>
          <source>declaration cannot be inferred '%0' because it has no definition in this translation unit</source>
          <target>declaration cannot be inferred '{$arg0}' because it has no definition in this translation unit</target>
        </segment>
      </unit>
      <unit id="5986" name="note_func_effect_call_indirect">
        <segment>
          <source>%select{virtual method|function pointer}0 cannot be inferred '%1'</source>
          <target>{$arg0 :select s0=|virtual method| s1=|function pointer|} cannot be inferred '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="5987" name="note_func_effect_calls_func_without_effect">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block| s5=|member initializer|} cannot be inferred '{$arg1}' because it calls non-'{$arg1}' {$arg2 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block|} '{$arg3}'</target>
        </segment>
      </unit>
      <unit id="5988" name="note_func_effect_from_template">
        <segment>
          <source>in template expansion here</source>
          <target>in template expansion here</target>
        </segment>
      </unit>
      <unit id="5989" name="note_func_effect_in_constructor">
        <segment>
          <source>in%select{| implicit}0 constructor here</source>
          <target>in{$arg0 :select s0=|| s1=| implicit|} constructor here</target>
        </segment>
      </unit>
      <unit id="5990" name="note_func_effect_violation">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block| s5=|member initializer|} cannot be inferred '{$arg1}' because it {$arg2 :select s0=|allocates or deallocates memory| s1=|throws or catches exceptions| s2=|has a static local variable| s3=|uses a thread-local variable| s4=|accesses an ObjC method or property|}</target>
        </segment>
      </unit>
      <unit id="5991" name="note_function_member_spec_matched">
        <segment>
          <source>member function specialization matches %0</source>
          <target>member function specialization matches {$arg0}</target>
        </segment>
      </unit>
      <unit id="5992" name="note_function_style_cast_add_parentheses">
        <segment>
          <source>add enclosing parentheses to perform a function-style cast</source>
          <target>add enclosing parentheses to perform a function-style cast</target>
        </segment>
      </unit>
      <unit id="5993" name="note_function_suggestion">
        <segment>
          <source>did you mean %0?</source>
          <target>did you mean {$arg0}?</target>
        </segment>
      </unit>
      <unit id="5994" name="note_function_template_deduction_instantiation_here">
        <segment>
          <source>while substituting deduced template arguments into function template %0 %1</source>
          <target>while substituting deduced template arguments into function template {$arg0} {$arg1}</target>
        </segment>
      </unit>
      <unit id="5995" name="note_function_template_spec_here">
        <segment>
          <source>in instantiation of function template specialization %q0 requested here</source>
          <target>in instantiation of function template specialization {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="5996" name="note_function_template_spec_matched">
        <segment>
          <source>function template %q0 matches specialization %1</source>
          <target>function template {$arg0 :q} matches specialization {$arg1}</target>
        </segment>
      </unit>
      <unit id="5997" name="note_function_to_function_call">
        <segment>
          <source>suffix with parentheses to turn this into a function call</source>
          <target>suffix with parentheses to turn this into a function call</target>
        </segment>
      </unit>
      <unit id="5998" name="note_function_warning_silence">
        <segment>
          <source>prefix with the address-of operator to silence this warning</source>
          <target>prefix with the address-of operator to silence this warning</target>
        </segment>
      </unit>
      <unit id="5999" name="note_getter_unavailable">
        <segment>
          <source>or because setter is declared here, but no getter method %0 is found</source>
          <target>or because setter is declared here, but no getter method {$arg0} is found</target>
        </segment>
      </unit>
      <unit id="6000" name="note_global_module_introducer_missing">
        <segment>
          <source>add 'module;' to the start of the file to introduce a global module fragment</source>
          <target>add 'module;' to the start of the file to introduce a global module fragment</target>
        </segment>
      </unit>
      <unit id="6001" name="note_goto_ms_asm_label">
        <segment>
          <source>inline assembly label %0 declared here</source>
          <target>inline assembly label {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6002" name="note_guarded_by_declared_here">
        <segment>
          <source>guarded_by declared here</source>
          <target>guarded_by declared here</target>
        </segment>
      </unit>
      <unit id="6003" name="note_hidden_overloaded_virtual_declared_here">
        <segment>
          <source>hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1</source>
          <target>hidden overloaded virtual function {$arg0 :q} declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters ({$arg2} vs {$arg3})|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers ({$arg2} vs {$arg3})|: different exception specifications}1</target>
        </segment>
      </unit>
      <unit id="6004" name="note_hidden_tag">
        <segment>
          <source>type declaration hidden</source>
          <target>type declaration hidden</target>
        </segment>
      </unit>
      <unit id="6005" name="note_hiding_object">
        <segment>
          <source>declaration hides type</source>
          <target>declaration hides type</target>
        </segment>
      </unit>
      <unit id="6006" name="note_ice_conversion_here">
        <segment>
          <source>conversion to %select{integral|enumeration}0 type %1 declared here</source>
          <target>conversion to {$arg0 :select s0=|integral| s1=|enumeration|} type {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="6007" name="note_illegal_field_declared_here">
        <segment>
          <source>field of illegal %select{type|pointer type}0 %1 declared here</source>
          <target>field of illegal {$arg0 :select s0=|type| s1=|pointer type|} {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="6008" name="note_immediate_function_reason">
        <segment>
          <source>%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3</source>
          <target>{$arg0} is an immediate {$arg5 :select s0=|function| s1=|constructor|} because %select{its body|the{$arg6 :select s0=|| s1=| default}7 initializer of {$arg8}|} %select{evaluates the address of {$arg2 :select s0=|an immediate| s1=|a consteval|} function {$arg1}|contains a call to {$arg2 :select s0=|an immediate| s1=|a consteval|} {$arg3 :select s0=|function| s1=|constructor}4 {$arg1} and that call is not a constant expression|}</target>
        </segment>
      </unit>
      <unit id="6009" name="note_implementation_declared">
        <segment>
          <source>class implementation is declared here</source>
          <target>class implementation is declared here</target>
        </segment>
      </unit>
      <unit id="6010" name="note_implemented_by_class">
        <segment>
          <source>when implemented by class %0</source>
          <target>when implemented by class {$arg0}</target>
        </segment>
      </unit>
      <unit id="6011" name="note_implicit_deduction_guide">
        <segment>
          <source>implicit deduction guide declared as '%0'</source>
          <target>implicit deduction guide declared as '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="6012" name="note_implicit_delete_this_in_destructor_here">
        <segment>
          <source>while checking implicit 'delete this' for virtual destructor</source>
          <target>while checking implicit 'delete this' for virtual destructor</target>
        </segment>
      </unit>
      <unit id="6013" name="note_implicit_member_target_infer_collision">
        <segment>
          <source>implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members</source>
          <target>implicit {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} inferred target collision: call to both {$arg1 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} and {$arg2 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} members</target>
        </segment>
      </unit>
      <unit id="6014" name="note_implicit_param_decl">
        <segment>
          <source>%0 is an implicit parameter</source>
          <target>{$arg0} is an implicit parameter</target>
        </segment>
      </unit>
      <unit id="6015" name="note_implicitly_deleted">
        <segment>
          <source>explicitly defaulted function was implicitly deleted here</source>
          <target>explicitly defaulted function was implicitly deleted here</target>
        </segment>
      </unit>
      <unit id="6016" name="note_in_binding_decl_init">
        <segment>
          <source>in implicit initialization of binding declaration %0</source>
          <target>in implicit initialization of binding declaration {$arg0}</target>
        </segment>
      </unit>
      <unit id="6017" name="note_in_class_initializer_float_type_cxx11">
        <segment>
          <source>add 'constexpr'</source>
          <target>add 'constexpr'</target>
        </segment>
      </unit>
      <unit id="6018" name="note_in_declaration_of_implicit_equality_comparison">
        <segment>
          <source>while declaring the corresponding implicit 'operator==' for this defaulted 'operator&lt;=&gt;'</source>
          <target>while declaring the corresponding implicit 'operator==' for this defaulted 'operator&lt;=&gt;'</target>
        </segment>
      </unit>
      <unit id="6019" name="note_in_declaration_of_implicit_special_member">
        <segment>
          <source>while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0</source>
          <target>while declaring the implicit {$arg1 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} for {$arg0}</target>
        </segment>
      </unit>
      <unit id="6020" name="note_in_evaluating_default_argument">
        <segment>
          <source>in evaluating default argument here</source>
          <target>in evaluating default argument here</target>
        </segment>
      </unit>
      <unit id="6021" name="note_in_for_range">
        <segment>
          <source>when looking up '%select{begin|end}0' function for range expression of type %1</source>
          <target>when looking up '{$arg0 :select s0=|begin| s1=|end|}' function for range expression of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6022" name="note_in_omitted_aggregate_initializer">
        <segment>
          <source>in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0</source>
          <target>in implicit initialization of {$arg0 :select s0=|array element {$arg1} with omitted initializer| s1=|field {$arg1} with omitted initializer| s2=|trailing array elements in runtime-sized array new|}</target>
        </segment>
      </unit>
      <unit id="6023" name="note_in_reference_temporary_list_initializer">
        <segment>
          <source>in initialization of temporary of type %0 created to list-initialize this reference</source>
          <target>in initialization of temporary of type {$arg0} created to list-initialize this reference</target>
        </segment>
      </unit>
      <unit id="6024" name="note_include_header_or_declare">
        <segment>
          <source>include the header &lt;%0&gt; or explicitly provide a declaration for '%1'</source>
          <target>include the header &lt;{$arg0}&gt; or explicitly provide a declaration for '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6025" name="note_incomplete_class_and_qualified_id">
        <segment>
          <source state="initial">conformance of forward class %0 to protocol %1 cannot be confirmed</source>
          <target>conformance of forward class {$arg0} to protocol {$arg1} cannot be confirmed</target>
        </segment>
      </unit>
      <unit id="6026" name="note_indirect_goto_target">
        <segment>
          <source>possible target of %select{indirect|asm}0 goto statement</source>
          <target>possible target of {$arg0 :select s0=|indirect| s1=|asm|} goto statement</target>
        </segment>
      </unit>
      <unit id="6027" name="note_indirection_through_null">
        <segment>
          <source>consider using __builtin_trap() or qualifying pointer with 'volatile'</source>
          <target>consider using __builtin_trap() or qualifying pointer with 'volatile'</target>
        </segment>
      </unit>
      <unit id="6028" name="note_inequality_comparison_to_or_assign">
        <segment>
          <source>use '|=' to turn this inequality comparison into an or-assignment</source>
          <target>use '|=' to turn this inequality comparison into an or-assignment</target>
        </segment>
      </unit>
      <unit id="6029" name="note_init_list_narrowing_silence">
        <segment>
          <source>insert an explicit cast to silence this issue</source>
          <target>insert an explicit cast to silence this issue</target>
        </segment>
      </unit>
      <unit id="6030" name="note_init_with_default_argument">
        <segment>
          <source>initializing parameter %0 with default argument</source>
          <target>initializing parameter {$arg0} with default argument</target>
        </segment>
      </unit>
      <unit id="6031" name="note_init_with_default_member_initializer">
        <segment>
          <source>initializing field %0 with default member initializer</source>
          <target>initializing field {$arg0} with default member initializer</target>
        </segment>
      </unit>
      <unit id="6032" name="note_initializer_out_of_order">
        <segment>
          <source>%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3</source>
          <target>{$arg0 :select s0=|field| s1=|base class|} {$arg1} will be initialized after {$arg2 :select s0=|field| s1=|base|} {$arg3}</target>
        </segment>
      </unit>
      <unit id="6033" name="note_insert_break_fixit">
        <segment>
          <source>insert 'break;' to avoid fall-through</source>
          <target>insert 'break;' to avoid fall-through</target>
        </segment>
      </unit>
      <unit id="6034" name="note_insert_fallthrough_fixit">
        <segment>
          <source>insert '%0;' to silence this warning</source>
          <target>insert '{$arg0};' to silence this warning</target>
        </segment>
      </unit>
      <unit id="6035" name="note_inst_declaration_hint">
        <segment>
          <source>add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit</source>
          <target>add an explicit instantiation declaration to suppress this warning if {$arg0 :q} is explicitly instantiated in another translation unit</target>
        </segment>
      </unit>
      <unit id="6036" name="note_instantiation_contexts_suppressed">
        <segment>
          <source>(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)</source>
          <target>(skipping {$arg0} context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)</target>
        </segment>
      </unit>
      <unit id="6037" name="note_instantiation_required_here">
        <segment>
          <source>%select{implicit|explicit}0 instantiation first required here</source>
          <target>{$arg0 :select s0=|implicit| s1=|explicit|} instantiation first required here</target>
        </segment>
      </unit>
      <unit id="6038" name="note_invalid_consteval_initializer">
        <segment>
          <source>in the default initializer of %0</source>
          <target>in the default initializer of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6039" name="note_invalid_consteval_initializer_here">
        <segment>
          <source>initialized here %0</source>
          <target>initialized here {$arg0}</target>
        </segment>
      </unit>
      <unit id="6040" name="note_is_deducible_constraint_evaluated_to_false">
        <segment>
          <source>cannot deduce template arguments for %0 from %1</source>
          <target>cannot deduce template arguments for {$arg0} from {$arg1}</target>
        </segment>
      </unit>
      <unit id="6041" name="note_it_delegates_to">
        <segment>
          <source>it delegates to</source>
          <target>it delegates to</target>
        </segment>
      </unit>
      <unit id="6042" name="note_ivar_decl">
        <segment>
          <source>instance variable is declared here</source>
          <target>instance variable is declared here</target>
        </segment>
      </unit>
      <unit id="6043" name="note_lambda_capture_initializer">
        <segment>
          <source>%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1</source>
          <target>{$arg2 :select s0=|implicitly | s1=||}captured{$arg3 :select s0=|| s1=| by reference|}%select{{$arg1 :select s0=| due to use| s1=|}2 here| s2=| via initialization of lambda capture {$arg0}|}</target>
        </segment>
      </unit>
      <unit id="6044" name="note_lambda_decl">
        <segment>
          <source>lambda expression begins here</source>
          <target>lambda expression begins here</target>
        </segment>
      </unit>
      <unit id="6045" name="note_lambda_default_capture_fixit">
        <segment>
          <source>default capture by %select{value|reference}0</source>
          <target>default capture by {$arg0 :select s0=|value| s1=|reference|}</target>
        </segment>
      </unit>
      <unit id="6046" name="note_lambda_substitution_here">
        <segment>
          <source>while substituting into a lambda expression here</source>
          <target>while substituting into a lambda expression here</target>
        </segment>
      </unit>
      <unit id="6047" name="note_lambda_this_capture_fixit">
        <segment>
          <source>explicitly capture 'this'</source>
          <target>explicitly capture 'this'</target>
        </segment>
      </unit>
      <unit id="6048" name="note_lambda_to_block_conv">
        <segment>
          <source>implicit capture of lambda object due to conversion to block pointer here</source>
          <target>implicit capture of lambda object due to conversion to block pointer here</target>
        </segment>
      </unit>
      <unit id="6049" name="note_lambda_variable_capture_fixit">
        <segment>
          <source>capture %0 by %select{value|reference}1</source>
          <target>capture {$arg0} by {$arg1 :select s0=|value| s1=|reference|}</target>
        </segment>
      </unit>
      <unit id="6050" name="note_lifetime_extending_member_declared_here">
        <segment>
          <source>%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here</source>
          <target>%select{{$arg0 :select s0=|reference| s1=|'std::initializer_list'|} member|member with {$arg1 :select s0=|reference| s1=|'std::initializer_list'}0 subobject|} declared here</target>
        </segment>
      </unit>
      <unit id="6051" name="note_local_decl_close_match">
        <segment>
          <source>local declaration nearly matches</source>
          <target>local declaration nearly matches</target>
        </segment>
      </unit>
      <unit id="6052" name="note_local_decl_close_param_match">
        <segment>
          <source>type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2</source>
          <target>type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6053" name="note_local_var_initializer">
        <segment>
          <source>%select{via initialization of|binding reference}0 variable %select{%2 |}1here</source>
          <target>{$arg0 :select s0=|via initialization of| s1=|binding reference|} variable {$arg1 :select s0=|{$arg2} | s1=||}here</target>
        </segment>
      </unit>
      <unit id="6054" name="note_lock_exclusive_and_shared">
        <segment>
          <source>the other acquisition of %0 '%1' is here</source>
          <target>the other acquisition of {$arg0} '{$arg1}' is here</target>
        </segment>
      </unit>
      <unit id="6055" name="note_locked_here">
        <segment>
          <source>%0 acquired here</source>
          <target>{$arg0} acquired here</target>
        </segment>
      </unit>
      <unit id="6056" name="note_logical_instead_of_bitwise_change_operator">
        <segment>
          <source>use '%0' for a bitwise operation</source>
          <target>use '{$arg0}' for a bitwise operation</target>
        </segment>
      </unit>
      <unit id="6057" name="note_logical_instead_of_bitwise_remove_constant">
        <segment>
          <source>remove constant to silence this warning</source>
          <target>remove constant to silence this warning</target>
        </segment>
      </unit>
      <unit id="6058" name="note_logical_not_fix">
        <segment>
          <source>add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first</source>
          <target>add parentheses after the '!' to evaluate the {$arg0 :select s0=|comparison| s1=|bitwise operator|} first</target>
        </segment>
      </unit>
      <unit id="6059" name="note_logical_not_silence_with_parens">
        <segment>
          <source>add parentheses around left hand side expression to silence this warning</source>
          <target>add parentheses around left hand side expression to silence this warning</target>
        </segment>
      </unit>
      <unit id="6060" name="note_loop_iteration_here">
        <segment>
          <source>%select{decremented|incremented}0 here</source>
          <target>{$arg0 :select s0=|decremented| s1=|incremented|} here</target>
        </segment>
      </unit>
      <unit id="6061" name="note_main_change_return_type">
        <segment>
          <source>change return type to 'int'</source>
          <target>change return type to 'int'</target>
        </segment>
      </unit>
      <unit id="6062" name="note_main_remove_noreturn">
        <segment>
          <source>remove '_Noreturn'</source>
          <target>remove '_Noreturn'</target>
        </segment>
      </unit>
      <unit id="6063" name="note_managed_mismatch_here_for_param">
        <segment>
          <source>see attribute on parameter here</source>
          <target>see attribute on parameter here</target>
        </segment>
      </unit>
      <unit id="6064" name="note_marked_here">
        <segment>
          <source>marked %0 here</source>
          <target>marked {$arg0} here</target>
        </segment>
      </unit>
      <unit id="6065" name="note_member_declared_at">
        <segment>
          <source>member is declared here</source>
          <target>member is declared here</target>
        </segment>
      </unit>
      <unit id="6066" name="note_member_declared_here">
        <segment>
          <source>member %0 declared here</source>
          <target>member {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6067" name="note_member_def_close_const_match">
        <segment>
          <source>member declaration does not match because it %select{is|is not}0 const qualified</source>
          <target>member declaration does not match because it {$arg0 :select s0=|is| s1=|is not|} const qualified</target>
        </segment>
      </unit>
      <unit id="6068" name="note_member_def_close_match">
        <segment>
          <source>member declaration nearly matches</source>
          <target>member declaration nearly matches</target>
        </segment>
      </unit>
      <unit id="6069" name="note_member_def_close_param_match">
        <segment>
          <source>type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2</source>
          <target>type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6070" name="note_member_first_declared_here">
        <segment>
          <source>member %0 first declared here</source>
          <target>member {$arg0} first declared here</target>
        </segment>
      </unit>
      <unit id="6071" name="note_member_reference_arrow_from_operator_arrow">
        <segment>
          <source>'-&gt;' applied to return value of the operator-&gt;() declared here</source>
          <target>'-&gt;' applied to return value of the operator-&gt;() declared here</target>
        </segment>
      </unit>
      <unit id="6072" name="note_member_synthesized_at">
        <segment>
          <source>in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here</source>
          <target>in {$arg0 :select s0=|implicit| s1=|defaulted|} {$arg1 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} for {$arg2} first required here</target>
        </segment>
      </unit>
      <unit id="6073" name="note_memsize_comparison_cast_silence">
        <segment>
          <source>explicitly cast the argument to size_t to silence this warning</source>
          <target>explicitly cast the argument to size_t to silence this warning</target>
        </segment>
      </unit>
      <unit id="6074" name="note_memsize_comparison_paren">
        <segment>
          <source>did you mean to compare the result of %0 instead?</source>
          <target>did you mean to compare the result of {$arg0} instead?</target>
        </segment>
      </unit>
      <unit id="6075" name="note_method_declared_at">
        <segment>
          <source>method %0 declared here</source>
          <target>method {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6076" name="note_method_return_type_change">
        <segment>
          <source>compiler has implicitly changed method %0 return type</source>
          <target>compiler has implicitly changed method {$arg0} return type</target>
        </segment>
      </unit>
      <unit id="6077" name="note_method_sent_forward_class">
        <segment>
          <source>method %0 is used for the forward class</source>
          <target>method {$arg0} is used for the forward class</target>
        </segment>
      </unit>
      <unit id="6078" name="note_misaligned_member_used_here">
        <segment>
          <source>passing byval argument %0 with potentially incompatible alignment here</source>
          <target>passing byval argument {$arg0} with potentially incompatible alignment here</target>
        </segment>
      </unit>
      <unit id="6079" name="note_module_import_not_at_top_level">
        <segment>
          <source>%0 begins here</source>
          <target>{$arg0} begins here</target>
        </segment>
      </unit>
      <unit id="6080" name="note_ms_bitfield_mismatched_storage_size_previous">
        <segment>
          <source>preceding bit-field %0 declared here with type %1</source>
          <target>preceding bit-field {$arg0} declared here with type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6081" name="note_multiversioning_caused_here">
        <segment>
          <source>function multiversioning caused by this declaration</source>
          <target>function multiversioning caused by this declaration</target>
        </segment>
      </unit>
      <unit id="6082" name="note_musttail_callconv_mismatch">
        <segment>
          <source>target function has calling convention %1 (expected %0)</source>
          <target>target function has calling convention {$arg1} (expected {$arg0})</target>
        </segment>
      </unit>
      <unit id="6083" name="note_musttail_callee_defined_here">
        <segment>
          <source>%0 declared here</source>
          <target>{$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6084" name="note_musttail_disabled_by_not_tail_called">
        <segment>
          <source>'not_tail_called' attribute prevents being called as a tail call</source>
          <target>'not_tail_called' attribute prevents being called as a tail call</target>
        </segment>
      </unit>
      <unit id="6085" name="note_musttail_fix_non_prototype">
        <segment>
          <source>add 'void' to the parameter list to turn an old-style K&amp;R function declaration into a prototype</source>
          <target>add 'void' to the parameter list to turn an old-style K&amp;R function declaration into a prototype</target>
        </segment>
      </unit>
      <unit id="6086" name="note_musttail_mismatch">
        <segment>
          <source>target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0</source>
          <target>target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected {$arg1} but has {$arg2})|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0</target>
        </segment>
      </unit>
      <unit id="6087" name="note_musttail_structors_forbidden">
        <segment>
          <source>target %select{constructor|destructor}0 is declared here</source>
          <target>target {$arg0 :select s0=|constructor| s1=|destructor|} is declared here</target>
        </segment>
      </unit>
      <unit id="6088" name="note_namespace_defined_here">
        <segment>
          <source>namespace %0 defined here</source>
          <target>namespace {$arg0} defined here</target>
        </segment>
      </unit>
      <unit id="6089" name="note_namespace_using_decl">
        <segment>
          <source>did you mean 'using namespace'?</source>
          <target>did you mean 'using namespace'?</target>
        </segment>
      </unit>
      <unit id="6090" name="note_neon_vector_initializer_non_portable">
        <segment>
          <source>consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant</source>
          <target>consider using vld1_{$arg0}{$arg1}() to initialize a vector from memory, or vcreate_{$arg0}{$arg1}() to initialize from an integer constant</target>
        </segment>
      </unit>
      <unit id="6091" name="note_neon_vector_initializer_non_portable_q">
        <segment>
          <source>consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants</source>
          <target>consider using vld1q_{$arg0}{$arg1}() to initialize a vector from memory, or vcombine_{$arg0}{$arg1}(vcreate_{$arg0}{$arg1}(), vcreate_{$arg0}{$arg1}()) to initialize from integer constants</target>
        </segment>
      </unit>
      <unit id="6092" name="note_nested_requirement_here">
        <segment>
          <source>while checking the satisfaction of nested requirement requested here</source>
          <target>while checking the satisfaction of nested requirement requested here</target>
        </segment>
      </unit>
      <unit id="6093" name="note_nested_requirement_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid%2</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid{$arg2}</target>
        </segment>
      </unit>
      <unit id="6094" name="note_nested_requirement_unknown_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid</target>
        </segment>
      </unit>
      <unit id="6095" name="note_next_field_declaration">
        <segment>
          <source>next field declaration is here</source>
          <target>next field declaration is here</target>
        </segment>
      </unit>
      <unit id="6096" name="note_next_ivar_declaration">
        <segment>
          <source>next %select{instance variable declaration|synthesized instance variable}0 is here</source>
          <target>next {$arg0 :select s0=|instance variable declaration| s1=|synthesized instance variable|} is here</target>
        </segment>
      </unit>
      <unit id="6097" name="note_non_c_like_anon_struct">
        <segment>
          <source>type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0</source>
          <target>type is not C-compatible due to this {$arg0 :select s0=|base class| s1=|default member initializer| s2=|lambda expression| s3=|friend declaration| s4=|member declaration|}</target>
        </segment>
      </unit>
      <unit id="6098" name="note_non_deducible_parameter">
        <segment>
          <source>non-deducible template parameter %0</source>
          <target>non-deducible template parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="6099" name="note_non_instantiated_member_here">
        <segment>
          <source>not-yet-instantiated member is declared here</source>
          <target>not-yet-instantiated member is declared here</target>
        </segment>
      </unit>
      <unit id="6100" name="note_non_literal_base_class">
        <segment>
          <source>%0 is not literal because it has base class %1 of non-literal type</source>
          <target>{$arg0} is not literal because it has base class {$arg1} of non-literal type</target>
        </segment>
      </unit>
      <unit id="6101" name="note_non_literal_field">
        <segment>
          <source>%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2</source>
          <target>{$arg0} is not literal because it has data member {$arg1} of {$arg3 :select s0=|non-literal| s1=|volatile|} type {$arg2}</target>
        </segment>
      </unit>
      <unit id="6102" name="note_non_literal_incomplete">
        <segment>
          <source>incomplete type %0 is not a literal type</source>
          <target>incomplete type {$arg0} is not a literal type</target>
        </segment>
      </unit>
      <unit id="6103" name="note_non_literal_lambda">
        <segment>
          <source>lambda closure types are non-literal types before C++17</source>
          <target>lambda closure types are non-literal types before C++17</target>
        </segment>
      </unit>
      <unit id="6104" name="note_non_literal_no_constexpr_ctors">
        <segment>
          <source>%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors</source>
          <target>{$arg0} is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors</target>
        </segment>
      </unit>
      <unit id="6105" name="note_non_literal_non_constexpr_dtor">
        <segment>
          <source>%0 is not literal because its destructor is not constexpr</source>
          <target>{$arg0} is not literal because its destructor is not constexpr</target>
        </segment>
      </unit>
      <unit id="6106" name="note_non_literal_nontrivial_dtor">
        <segment>
          <source>%0 is not literal because it has a non-trivial destructor</source>
          <target>{$arg0} is not literal because it has a non-trivial destructor</target>
        </segment>
      </unit>
      <unit id="6107" name="note_non_literal_user_provided_dtor">
        <segment>
          <source>%0 is not literal because it has a user-provided destructor</source>
          <target>{$arg0} is not literal because it has a user-provided destructor</target>
        </segment>
      </unit>
      <unit id="6108" name="note_non_literal_virtual_base">
        <segment>
          <source>%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type</source>
          <target>{$arg0 :select s0=|struct| s1=|interface| s2=|class|} with virtual base %plural{1:class|:classes}1 is not a literal type</target>
        </segment>
      </unit>
      <unit id="6109" name="note_non_template_in_template_id_found">
        <segment>
          <source>non-template declaration found by name lookup</source>
          <target>non-template declaration found by name lookup</target>
        </segment>
      </unit>
      <unit id="6110" name="note_non_trivial_c_union">
        <segment>
          <source>%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1</source>
          <target>{$arg0 :select s0=|{$arg2} has subobjects that are| s1=|{$arg3} has type {$arg2} that is|} non-trivial to {$arg1 :select s0=|default-initialize| s1=|destruct| s2=|copy|}</target>
        </segment>
      </unit>
      <unit id="6111" name="note_non_usual_function_declared_here">
        <segment>
          <source>non-usual %0 declared here</source>
          <target>non-usual {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6112" name="note_nontemplate_decl_here">
        <segment>
          <source>non-templated declaration is here</source>
          <target>non-templated declaration is here</target>
        </segment>
      </unit>
      <unit id="6113" name="note_nontrivial_default_arg">
        <segment>
          <source>because it has a default argument</source>
          <target>because it has a default argument</target>
        </segment>
      </unit>
      <unit id="6114" name="note_nontrivial_default_member_init">
        <segment>
          <source>because field %0 has an initializer</source>
          <target>because field {$arg0} has an initializer</target>
        </segment>
      </unit>
      <unit id="6115" name="note_nontrivial_field">
        <segment>
          <source>field is non-trivial to %select{copy|default-initialize}0</source>
          <target>field is non-trivial to {$arg0 :select s0=|copy| s1=|default-initialize|}</target>
        </segment>
      </unit>
      <unit id="6116" name="note_nontrivial_has_virtual">
        <segment>
          <source>because type %0 has a virtual %select{member function|base class}1</source>
          <target>because type {$arg0} has a virtual {$arg1 :select s0=|member function| s1=|base class|}</target>
        </segment>
      </unit>
      <unit id="6117" name="note_nontrivial_no_copy">
        <segment>
          <source>because no %select{&lt;&lt;ERROR&gt;&gt;|constructor|constructor|assignment operator|assignment operator|&lt;&lt;ERROR&gt;&gt;}2 can be used to %select{&lt;&lt;ERROR&gt;&gt;|copy|move|copy|move|&lt;&lt;ERROR&gt;&gt;}2 %select{base class|field|an object}0 of type %3</source>
          <target>because no {$arg2 :select s0=|&lt;&lt;ERROR&gt;&gt;| s1=|constructor| s2=|constructor| s3=|assignment operator| s4=|assignment operator| s5=|&lt;&lt;ERROR&gt;&gt;|} can be used to {$arg2 :select s0=|&lt;&lt;ERROR&gt;&gt;| s1=|copy| s2=|move| s3=|copy| s4=|move| s5=|&lt;&lt;ERROR&gt;&gt;|} {$arg0 :select s0=|base class| s1=|field| s2=|an object|} of type {$arg3}</target>
        </segment>
      </unit>
      <unit id="6118" name="note_nontrivial_no_def_ctor">
        <segment>
          <source>because %select{base class of |field of |}0type %1 has no default constructor</source>
          <target>because {$arg0 :select s0=|base class of | s1=|field of | s2=||}type {$arg1} has no default constructor</target>
        </segment>
      </unit>
      <unit id="6119" name="note_nontrivial_objc_ownership">
        <segment>
          <source>because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership</source>
          <target>because type {$arg0} has a member with {$arg1 :select s0=|no| s1=|no| s2=|__strong| s3=|__weak| s4=|__autoreleasing|} ownership</target>
        </segment>
      </unit>
      <unit id="6120" name="note_nontrivial_param_type">
        <segment>
          <source>because its parameter is %diff{of type $, not $|of the wrong type}2,3</source>
          <target>because its parameter is %diff{of type $, not $|of the wrong type}2,3</target>
        </segment>
      </unit>
      <unit id="6121" name="note_nontrivial_subobject">
        <segment>
          <source>because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial</source>
          <target>because the function selected to {$arg2 :select s0=|construct| s1=|copy| s2=|move| s3=|copy| s4=|move| s5=|destroy|} {$arg0 :select s0=|base class| s1=|field|} of type {$arg1} is not trivial</target>
        </segment>
      </unit>
      <unit id="6122" name="note_nontrivial_user_provided">
        <segment>
          <source>because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2</source>
          <target>because {$arg0 :select s0=|base class of | s1=|field of | s2=||}type {$arg1} has a user-provided {$arg2 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|}</target>
        </segment>
      </unit>
      <unit id="6123" name="note_nontrivial_variadic">
        <segment>
          <source>because it is a variadic function</source>
          <target>because it is a variadic function</target>
        </segment>
      </unit>
      <unit id="6124" name="note_nontrivial_virtual_dtor">
        <segment>
          <source>destructor for %0 is not trivial because it is virtual</source>
          <target>destructor for {$arg0} is not trivial because it is virtual</target>
        </segment>
      </unit>
      <unit id="6125" name="note_not_found_by_two_phase_lookup">
        <segment>
          <source>%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1</source>
          <target>{$arg0} should be declared prior to the call site{$arg1 :select s0=|| s1=| or in {$arg2}| s2=| or in an associated namespace of one of its arguments|}</target>
        </segment>
      </unit>
      <unit id="6126" name="note_not_module_interface_add_export">
        <segment>
          <source>add 'export' here if this is intended to be a module interface unit</source>
          <target>add 'export' here if this is intended to be a module interface unit</target>
        </segment>
      </unit>
      <unit id="6127" name="note_not_structural_mutable_field">
        <segment>
          <source>%0 is not a structural type because it has a mutable non-static data member</source>
          <target>{$arg0} is not a structural type because it has a mutable non-static data member</target>
        </segment>
      </unit>
      <unit id="6128" name="note_not_structural_non_public">
        <segment>
          <source>%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public</source>
          <target>{$arg0} is not a structural type because it has a {$arg1 :select s0=|non-static data member| s1=|base class|} that is not public</target>
        </segment>
      </unit>
      <unit id="6129" name="note_not_structural_rvalue_ref_field">
        <segment>
          <source>%0 is not a structural type because it has a non-static data member of rvalue reference type</source>
          <target>{$arg0} is not a structural type because it has a non-static data member of rvalue reference type</target>
        </segment>
      </unit>
      <unit id="6130" name="note_not_structural_subobject">
        <segment>
          <source>%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2</source>
          <target>{$arg0} is not a structural type because it has a {$arg1 :select s0=|non-static data member| s1=|base class|} of non-structural type {$arg2}</target>
        </segment>
      </unit>
      <unit id="6131" name="note_nsdictionary_duplicate_key_here">
        <segment>
          <source>previous equal key is here</source>
          <target>previous equal key is here</target>
        </segment>
      </unit>
      <unit id="6132" name="note_nullability_fix_it">
        <segment>
          <source>insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0</source>
          <target>insert '{$arg0 :select s0=|_Nonnull| s1=|_Nullable| s2=|_Null_unspecified|}' if the {$arg1 :select s0=|pointer| s1=|block pointer| s2=|member pointer| s3=|array parameter|} {$arg0 :select s0=|should never be null| s1=|may be null| s2=|should not declare nullability|}</target>
        </segment>
      </unit>
      <unit id="6133" name="note_nullability_here">
        <segment>
          <source>%0 specified here</source>
          <target>{$arg0} specified here</target>
        </segment>
      </unit>
      <unit id="6134" name="note_nullability_type_specifier">
        <segment>
          <source>use nullability type specifier %0 to affect the innermost pointer type of %1</source>
          <target>use nullability type specifier {$arg0} to affect the innermost pointer type of {$arg1}</target>
        </segment>
      </unit>
      <unit id="6135" name="note_objc_circular_container_declared_here">
        <segment>
          <source>%0 declared here</source>
          <target>{$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6136" name="note_objc_designated_init_marked_here">
        <segment>
          <source>method marked as designated initializer of the class here</source>
          <target>method marked as designated initializer of the class here</target>
        </segment>
      </unit>
      <unit id="6137" name="note_objc_literal_comparison_isequal">
        <segment>
          <source>use 'isEqual:' instead</source>
          <target>use 'isEqual:' instead</target>
        </segment>
      </unit>
      <unit id="6138" name="note_objc_literal_method_param">
        <segment>
          <source>%select{first|second|third}0 parameter has unexpected type %1 (should be %2)</source>
          <target>{$arg0 :select s0=|first| s1=|second| s2=|third|} parameter has unexpected type {$arg1} (should be {$arg2})</target>
        </segment>
      </unit>
      <unit id="6139" name="note_objc_literal_method_return">
        <segment>
          <source>method returns unexpected type %0 (should be an object type)</source>
          <target>method returns unexpected type {$arg0} (should be an object type)</target>
        </segment>
      </unit>
      <unit id="6140" name="note_objc_needs_superclass">
        <segment>
          <source>add a super class to fix this problem</source>
          <target>add a super class to fix this problem</target>
        </segment>
      </unit>
      <unit id="6141" name="note_objc_type_param_here">
        <segment>
          <source>type parameter %0 declared here</source>
          <target>type parameter {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6142" name="note_objc_unsafe_perform_selector_method_declared_here">
        <segment>
          <source>method %0 that returns %1 declared here</source>
          <target>method {$arg0} that returns {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="6143" name="note_omp_atomic_capture">
        <segment>
          <source>%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0</source>
          <target>{$arg0 :select s0=|expected assignment expression| s1=|expected compound statement| s2=|expected exactly two expression statements| s3=|expected in right hand side of the first expression|}</target>
        </segment>
      </unit>
      <unit id="6144" name="note_omp_atomic_compare">
        <segment>
          <source>%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '&lt;', '&gt;' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0</source>
          <target>{$arg0 :select s0=|expected compound statement| s1=|expected exactly one expression statement| s2=|expected assignment statement| s3=|expected conditional operator| s4=|expect result value to be at false expression| s5=|expect binary operator in conditional expression| s6=|expect '&lt;', '&gt;' or '==' as order operator| s7=|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'| s8=|expect lvalue for result value| s9=|expect scalar value| s10=|expect integer value| s11=|unexpected 'else' statement| s12=|expect '==' operator| s13=|expect an assignment statement 'v = x'| s14=|expect a 'if' statement| s15=|expect no more than two statements| s16=|expect a compound statement| s17=|expect 'else' statement| s18=|expect a form 'r = x == e; if (r) ...'|}</target>
        </segment>
      </unit>
      <unit id="6145" name="note_omp_atomic_read_write">
        <segment>
          <source>%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0</source>
          <target>{$arg0 :select s0=|expected an expression statement| s1=|expected built-in assignment operator| s2=|expected expression of scalar type| s3=|expected lvalue expression|}</target>
        </segment>
      </unit>
      <unit id="6146" name="note_omp_atomic_update">
        <segment>
          <source>%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&amp;', '^', '%|', '&lt;&lt;', or '&gt;&gt;' built-in operations|expected in right hand side of expression}0</source>
          <target>{$arg0 :select s0=|expected an expression statement| s1=|expected built-in binary or unary operator| s2=|expected unary decrement/increment operation| s3=|expected expression of scalar type| s4=|expected assignment expression| s5=|expected built-in binary operator| s6=|expected one of '+', '*', '-', '/', '&amp;', '^', '%| s7=|', '&lt;&lt;', or '&gt;&gt;' built-in operations| s8=|expected in right hand side of expression|}</target>
        </segment>
      </unit>
      <unit id="6147" name="note_omp_collapse_ordered_expr">
        <segment>
          <source>as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0</source>
          <target>as specified in {$arg0 :select s0=|'collapse'| s1=|'ordered'| s2=|'collapse' and 'ordered'|} clause{$arg0 :select s0=|| s1=|| s2=|s|}</target>
        </segment>
      </unit>
      <unit id="6148" name="note_omp_conversion_here">
        <segment>
          <source>conversion to %select{integral|enumeration}0 type %1 declared here</source>
          <target>conversion to {$arg0 :select s0=|integral| s1=|enumeration|} type {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="6149" name="note_omp_critical_hint_here">
        <segment>
          <source>%select{|previous }0'hint' clause with value '%1'</source>
          <target>{$arg0 :select s0=|| s1=|previous |}'hint' clause with value '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6150" name="note_omp_critical_no_hint">
        <segment>
          <source>%select{|previous }0directive with no 'hint' clause specified</source>
          <target>{$arg0 :select s0=|| s1=|previous |}directive with no 'hint' clause specified</target>
        </segment>
      </unit>
      <unit id="6151" name="note_omp_default_dsa_none">
        <segment>
          <source>explicit data sharing attribute requested here</source>
          <target>explicit data sharing attribute requested here</target>
        </segment>
      </unit>
      <unit id="6152" name="note_omp_defaultmap_attr_none">
        <segment>
          <source>explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here</source>
          <target>explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here</target>
        </segment>
      </unit>
      <unit id="6153" name="note_omp_directive_here">
        <segment>
          <source>'%0' directive found here</source>
          <target>'{$arg0}' directive found here</target>
        </segment>
      </unit>
      <unit id="6154" name="note_omp_exits_structured_block">
        <segment>
          <source>jump exits scope of OpenMP structured block</source>
          <target>jump exits scope of OpenMP structured block</target>
        </segment>
      </unit>
      <unit id="6155" name="note_omp_explicit_dsa">
        <segment>
          <source>defined as %0</source>
          <target>defined as {$arg0}</target>
        </segment>
      </unit>
      <unit id="6156" name="note_omp_flush_order_clause_here">
        <segment>
          <source>memory order clause '%0' is specified here</source>
          <target>memory order clause '{$arg0}' is specified here</target>
        </segment>
      </unit>
      <unit id="6157" name="note_omp_implicit_dsa">
        <segment>
          <source>implicitly determined as %0</source>
          <target>implicitly determined as {$arg0}</target>
        </segment>
      </unit>
      <unit id="6158" name="note_omp_invalid_length_on_this_ptr_mapping">
        <segment>
          <source>expected length on mapping of 'this' array section expression to be '1'</source>
          <target>expected length on mapping of 'this' array section expression to be '1'</target>
        </segment>
      </unit>
      <unit id="6159" name="note_omp_invalid_lower_bound_on_this_ptr_mapping">
        <segment>
          <source>expected lower bound on mapping of 'this' array section expression to be '0' or not specified</source>
          <target>expected lower bound on mapping of 'this' array section expression to be '0' or not specified</target>
        </segment>
      </unit>
      <unit id="6160" name="note_omp_invalid_subscript_on_this_ptr_map">
        <segment>
          <source>expected 'this' subscript expression on map clause to be 'this[0]'</source>
          <target>expected 'this' subscript expression on map clause to be 'this[0]'</target>
        </segment>
      </unit>
      <unit id="6161" name="note_omp_loop_cond_requires_compatible_incr">
        <segment>
          <source>loop step is expected to be %select{negative|positive}0 due to this condition</source>
          <target>loop step is expected to be {$arg0 :select s0=|negative| s1=|positive|} due to this condition</target>
        </segment>
      </unit>
      <unit id="6162" name="note_omp_marked_declare_variant_here">
        <segment>
          <source>marked as 'declare variant' here</source>
          <target>marked as 'declare variant' here</target>
        </segment>
      </unit>
      <unit id="6163" name="note_omp_marked_device_type_here">
        <segment>
          <source>marked as 'device_type(%0)' here</source>
          <target>marked as 'device_type({$arg0})' here</target>
        </segment>
      </unit>
      <unit id="6164" name="note_omp_nested_statement_here">
        <segment>
          <source>%select{statement|directive}0 outside teams construct here</source>
          <target>{$arg0 :select s0=|statement| s1=|directive|} outside teams construct here</target>
        </segment>
      </unit>
      <unit id="6165" name="note_omp_nested_teams_construct_here">
        <segment>
          <source>nested teams construct here</source>
          <target>nested teams construct here</target>
        </segment>
      </unit>
      <unit id="6166" name="note_omp_nowait_clause_here">
        <segment>
          <source>'nowait' clause is here</source>
          <target>'nowait' clause is here</target>
        </segment>
      </unit>
      <unit id="6167" name="note_omp_ordered_param">
        <segment>
          <source>'ordered' clause%select{| with specified parameter}0</source>
          <target>'ordered' clause{$arg0 :select s0=|| s1=| with specified parameter|}</target>
        </segment>
      </unit>
      <unit id="6168" name="note_omp_predefined_allocator">
        <segment>
          <source>predefined trait '%0' used here</source>
          <target>predefined trait '{$arg0}' used here</target>
        </segment>
      </unit>
      <unit id="6169" name="note_omp_predetermined_dsa">
        <segment>
          <source>%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1</source>
          <target>{$arg0 :select s0=|static data member is predetermined as shared| s1=|variable with static storage duration is predetermined as shared| s2=|loop iteration variable is predetermined as private| s3=|loop iteration variable is predetermined as linear| s4=|loop iteration variable is predetermined as lastprivate| s5=|constant variable is predetermined as shared| s6=|global variable is predetermined as shared| s7=|non-shared variable in a task construct is predetermined as firstprivate| s8=|variable with automatic storage duration is predetermined as private|}{$arg1 :select s0=|| s1=|; perhaps you forget to enclose 'omp {$arg2}' directive into a parallel or another task region?|}</target>
        </segment>
      </unit>
      <unit id="6170" name="note_omp_previous_allocator">
        <segment>
          <source>previous allocator is specified here</source>
          <target>previous allocator is specified here</target>
        </segment>
      </unit>
      <unit id="6171" name="note_omp_previous_clause">
        <segment>
          <source>'%0' clause is specified here</source>
          <target>'{$arg0}' clause is specified here</target>
        </segment>
      </unit>
      <unit id="6172" name="note_omp_previous_critical_region">
        <segment>
          <source>previous 'critical' region starts here</source>
          <target>previous 'critical' region starts here</target>
        </segment>
      </unit>
      <unit id="6173" name="note_omp_previous_directive">
        <segment>
          <source>previous '%0' directive used here</source>
          <target>previous '{$arg0}' directive used here</target>
        </segment>
      </unit>
      <unit id="6174" name="note_omp_previous_inscan_reduction">
        <segment>
          <source>'reduction' clause with 'inscan' modifier is used here</source>
          <target>'reduction' clause with 'inscan' modifier is used here</target>
        </segment>
      </unit>
      <unit id="6175" name="note_omp_previous_mem_order_clause">
        <segment>
          <source>'%0' clause used here</source>
          <target>'{$arg0}' clause used here</target>
        </segment>
      </unit>
      <unit id="6176" name="note_omp_previous_named_if_clause">
        <segment>
          <source>previous clause with directive name modifier specified here</source>
          <target>previous clause with directive name modifier specified here</target>
        </segment>
      </unit>
      <unit id="6177" name="note_omp_previous_reduction_identifier">
        <segment>
          <source>previously marked as task_reduction with different reduction operation</source>
          <target>previously marked as task_reduction with different reduction operation</target>
        </segment>
      </unit>
      <unit id="6178" name="note_omp_protected_structured_block">
        <segment>
          <source>jump bypasses OpenMP structured block</source>
          <target>jump bypasses OpenMP structured block</target>
        </segment>
      </unit>
      <unit id="6179" name="note_omp_referenced">
        <segment>
          <source>previously referenced here</source>
          <target>previously referenced here</target>
        </segment>
      </unit>
      <unit id="6180" name="note_omp_requires_encountered_directive">
        <segment>
          <source>'%0' previously encountered here</source>
          <target>'{$arg0}' previously encountered here</target>
        </segment>
      </unit>
      <unit id="6181" name="note_omp_requires_previous_clause">
        <segment>
          <source>%0 clause previously used here</source>
          <target>{$arg0} clause previously used here</target>
        </segment>
      </unit>
      <unit id="6182" name="note_omp_task_predetermined_firstprivate_here">
        <segment>
          <source>predetermined as a firstprivate in a task construct here</source>
          <target>predetermined as a firstprivate in a task construct here</target>
        </segment>
      </unit>
      <unit id="6183" name="note_opencl_typedef_access_qualifier">
        <segment>
          <source>previously declared '%0' here</source>
          <target>previously declared '{$arg0}' here</target>
        </segment>
      </unit>
      <unit id="6184" name="note_operator_arrow_depth">
        <segment>
          <source>use -foperator-arrow-depth=N to increase 'operator-&gt;' limit</source>
          <target>use -foperator-arrow-depth=N to increase 'operator-&gt;' limit</target>
        </segment>
      </unit>
      <unit id="6185" name="note_operator_arrow_here">
        <segment>
          <source>'operator-&gt;' declared here produces an object of type %0</source>
          <target>'operator-&gt;' declared here produces an object of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="6186" name="note_operator_arrows_suppressed">
        <segment>
          <source>(skipping %0 'operator-&gt;'%s0 in backtrace)</source>
          <target>(skipping {$arg0} 'operator-&gt;'%s0 in backtrace)</target>
        </segment>
      </unit>
      <unit id="6187" name="note_overridden_marked_noescape">
        <segment>
          <source>parameter of overridden method is annotated with __attribute__((noescape))</source>
          <target>parameter of overridden method is annotated with __attribute__((noescape))</target>
        </segment>
      </unit>
      <unit id="6188" name="note_overridden_method">
        <segment>
          <source>overridden method is here</source>
          <target>overridden method is here</target>
        </segment>
      </unit>
      <unit id="6189" name="note_overridden_virtual_function">
        <segment>
          <source>overridden virtual function is here</source>
          <target>overridden virtual function is here</target>
        </segment>
      </unit>
      <unit id="6190" name="note_ovl_ambiguous_eqeq_reversed_self_non_const">
        <segment>
          <source>mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity</source>
          <target>mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity</target>
        </segment>
      </unit>
      <unit id="6191" name="note_ovl_ambiguous_oper_binary_reversed_candidate">
        <segment>
          <source>ambiguous candidate function with reversed arguments</source>
          <target>ambiguous candidate function with reversed arguments</target>
        </segment>
      </unit>
      <unit id="6192" name="note_ovl_ambiguous_oper_binary_reversed_self">
        <segment>
          <source>ambiguity is between a regular call to this operator and a call with the argument order reversed</source>
          <target>ambiguity is between a regular call to this operator and a call with the argument order reversed</target>
        </segment>
      </unit>
      <unit id="6193" name="note_ovl_ambiguous_oper_binary_selected_candidate">
        <segment>
          <source>candidate function with non-reversed arguments</source>
          <target>candidate function with non-reversed arguments</target>
        </segment>
      </unit>
      <unit id="6194" name="note_ovl_builtin_candidate">
        <segment>
          <source>built-in candidate %0</source>
          <target>built-in candidate {$arg0}</target>
        </segment>
      </unit>
      <unit id="6195" name="note_ovl_candidate">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg3}|}%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected {$arg5} but has {$arg6})| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected {$arg5} but found {$arg6})| has different exception specification}4</target>
        </segment>
      </unit>
      <unit id="6196" name="note_ovl_candidate_arity">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: requires{$arg3 :select s0=| at least| s1=| at most| s2=||} {$arg4} {$arg6 :select s0=|| s1=|non-object |}argument%s4, but {$arg5} %plural{1:was|:were}5 provided</target>
        </segment>
      </unit>
      <unit id="6197" name="note_ovl_candidate_arity_one">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: {$arg3 :select s0=|requires at least| s1=|allows at most single| s2=|requires single|} {$arg6 :select s0=|| s1=|non-object |}argument {$arg4}, but %plural{0:no|:{$arg5}}5 arguments were provided</target>
        </segment>
      </unit>
      <unit id="6198" name="note_ovl_candidate_bad_addrspace">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: cannot {$arg5 :select s0=|pass pointer to| s1=|bind reference in|} {$arg3} {$arg5 :select s0=|as a pointer to| s1=|to object in|} {$arg4} in %ordinal6 argument</target>
        </segment>
      </unit>
      <unit id="6199" name="note_ovl_candidate_bad_addrspace_this">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: 'this' object is in {$arg3}, but method expects object in {$arg4}</target>
        </segment>
      </unit>
      <unit id="6200" name="note_ovl_candidate_bad_arc_conv">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for {$arg5 :select s0=|%ordinal6 argument| s1=|object argument|} under ARC</target>
        </segment>
      </unit>
      <unit id="6201" name="note_ovl_candidate_bad_base_to_derived_conv">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: cannot {$arg3 :select s0=|convert from| s1=|convert from| s2=|bind|} {$arg3 :select s0=|base class pointer| s1=|superclass| s2=|base class object of type|} {$arg4} to {$arg3 :select s0=|derived class pointer| s1=|subclass| s2=|derived class reference|} {$arg5} for %ordinal6 argument</target>
        </segment>
      </unit>
      <unit id="6202" name="note_ovl_candidate_bad_conv">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &amp;|; remove *|; remove &amp;}7</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for {$arg5 :select s0=|%ordinal6 argument| s1=|object argument|}{$arg7 :select s0=|| s1=|; dereference the argument with *| s2=|; take the address of the argument with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="6203" name="note_ovl_candidate_bad_conv_incomplete">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &amp;|; remove *|; remove &amp;}7</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for {$arg5 :select s0=|%ordinal6 argument| s1=|object argument|}{$arg7 :select s0=|| s1=|; dereference the argument with *| s2=|; take the address of the argument with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="6204" name="note_ovl_candidate_bad_cvr">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: %ordinal5 argument ({$arg3}) would lose {$arg4 :select s0=|const| s1=|restrict| s2=|const and restrict| s3=|volatile| s4=|const and volatile| s5=|volatile and restrict| s6=|const, volatile, and restrict|} qualifier{$arg4 :select s0=|| s1=|| s2=|s| s3=|| s4=|s| s5=|s| s6=|s|}</target>
        </segment>
      </unit>
      <unit id="6205" name="note_ovl_candidate_bad_cvr_this">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: 'this' argument has type {$arg3}, but method is not marked {$arg4 :select s0=|const| s1=|restrict| s2=|const or restrict| s3=|volatile| s4=|const or volatile| s5=|volatile or restrict| s6=|const, volatile, or restrict|}</target>
        </segment>
      </unit>
      <unit id="6206" name="note_ovl_candidate_bad_deduction">
        <segment>
          <source>candidate template ignored: failed template argument deduction</source>
          <target>candidate template ignored: failed template argument deduction</target>
        </segment>
      </unit>
      <unit id="6207" name="note_ovl_candidate_bad_gc">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: {$arg6 :select s0=|%ordinal7| s1=|'this'|} argument ({$arg3}) has {$arg4 :select s0=|no| s1=|__weak| s2=|__strong|} ownership, but parameter has {$arg5 :select s0=|no| s1=|__weak| s2=|__strong|} ownership</target>
        </segment>
      </unit>
      <unit id="6208" name="note_ovl_candidate_bad_list_argument">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: {$arg7 :select s0=|cannot convert initializer list| s1=|too few initializers in list| s2=|too many initializers in list|} argument to {$arg4}</target>
        </segment>
      </unit>
      <unit id="6209" name="note_ovl_candidate_bad_overload">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: no overload of {$arg4} matching {$arg3} for %ordinal5 argument</target>
        </segment>
      </unit>
      <unit id="6210" name="note_ovl_candidate_bad_ownership">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: {$arg6 :select s0=|%ordinal7| s1=|'this'|} argument ({$arg3}) has {$arg4 :select s0=|no| s1=|__unsafe_unretained| s2=|__strong| s3=|__weak| s4=|__autoreleasing|} ownership, but parameter has {$arg5 :select s0=|no| s1=|__unsafe_unretained| s2=|__strong| s3=|__weak| s4=|__autoreleasing|} ownership</target>
        </segment>
      </unit>
      <unit id="6211" name="note_ovl_candidate_bad_ptrauth">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal8 argument (%3) has %select{no '__ptrauth'|%5}4 qualifier, but parameter has %select{no '__ptrauth'|%7}6 qualifier</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: %ordinal8 argument ({$arg3}) has {$arg4 :select s0=|no '__ptrauth'| s1=|{$arg5}|} qualifier, but parameter has {$arg6 :select s0=|no '__ptrauth'| s1=|{$arg7}|} qualifier</target>
        </segment>
      </unit>
      <unit id="6212" name="note_ovl_candidate_bad_target">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: call to {$arg3 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__| s4=|invalid|} function from {$arg4 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__| s4=|invalid|} function</target>
        </segment>
      </unit>
      <unit id="6213" name="note_ovl_candidate_bad_value_category">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: expects an {$arg5 :select s0=|lvalue| s1=|rvalue|} for {$arg3 :select s0=|%ordinal4 argument| s1=|object argument|}</target>
        </segment>
      </unit>
      <unit id="6214" name="note_ovl_candidate_constraints_not_satisfied">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} not viable: constraints not satisfied</target>
        </segment>
      </unit>
      <unit id="6215" name="note_ovl_candidate_deduced_mismatch">
        <segment>
          <source>candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3</source>
          <target>candidate template ignored: deduced type %diff{$ of {$arg4 :select s0=|| s1=|element of |}%ordinal0 parameter does not match adjusted type $ of {$arg4 :select s0=|| s1=|element of |}argument|of {$arg4 :select s0=|| s1=|element of |}%ordinal0 parameter does not match adjusted type of {$arg1 :select s0=|| s1=|element of }4argument|},2{$arg3}</target>
        </segment>
      </unit>
      <unit id="6216" name="note_ovl_candidate_deleted">
        <segment>
          <source>candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3</source>
          <target>candidate {$arg0 :select s0=|function| s1=|function| s2=|function (with reversed parameter order)| s3=|constructor| s4=|constructor (the implicit default constructor)| s5=|constructor (the implicit copy constructor)| s6=|constructor (the implicit move constructor)| s7=|function (the implicit copy assignment operator)| s8=|function (the implicit move assignment operator)| s9=|function (the implicit 'operator==' for this 'operator&lt;=&gt;)'| s10=|inherited constructor|}{$arg1 :select s0=|| s1=| template| s2=| {$arg2}|} has been {$arg3 :select s0=|explicitly made unavailable| s1=|explicitly deleted| s2=|implicitly deleted|}</target>
        </segment>
      </unit>
      <unit id="6217" name="note_ovl_candidate_disabled_by_enable_if">
        <segment>
          <source>candidate template ignored: disabled by %0%1</source>
          <target>candidate template ignored: disabled by {$arg0}{$arg1}</target>
        </segment>
      </unit>
      <unit id="6218" name="note_ovl_candidate_disabled_by_function_cond_attr">
        <segment>
          <source>candidate disabled: %0</source>
          <target>candidate disabled: {$arg0}</target>
        </segment>
      </unit>
      <unit id="6219" name="note_ovl_candidate_disabled_by_requirement">
        <segment>
          <source>candidate template ignored: requirement '%0' was not satisfied%1</source>
          <target>candidate template ignored: requirement '{$arg0}' was not satisfied{$arg1}</target>
        </segment>
      </unit>
      <unit id="6220" name="note_ovl_candidate_explicit">
        <segment>
          <source>explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1</source>
          <target>explicit {$arg0 :select s0=|constructor| s1=|conversion function| s2=|deduction guide|} is not a candidate{$arg1 :select s0=|| s1=| (explicit specifier evaluates to true)|}</target>
        </segment>
      </unit>
      <unit id="6221" name="note_ovl_candidate_explicit_arg_mismatch_named">
        <segment>
          <source>candidate template ignored: invalid explicitly-specified argument for template parameter %0</source>
          <target>candidate template ignored: invalid explicitly-specified argument for template parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="6222" name="note_ovl_candidate_explicit_arg_mismatch_unnamed">
        <segment>
          <source>candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter</source>
          <target>candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter</target>
        </segment>
      </unit>
      <unit id="6223" name="note_ovl_candidate_has_pass_object_size_params">
        <segment>
          <source>candidate address cannot be taken because parameter %0 has pass_object_size attribute</source>
          <target>candidate address cannot be taken because parameter {$arg0} has pass_object_size attribute</target>
        </segment>
      </unit>
      <unit id="6224" name="note_ovl_candidate_illegal_constructor">
        <segment>
          <source>candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value</source>
          <target>candidate {$arg0 :select s0=|constructor| s1=|template|} ignored: instantiation {$arg0 :select s0=|takes| s1=|would take|} its own class type by value</target>
        </segment>
      </unit>
      <unit id="6225" name="note_ovl_candidate_illegal_constructor_adrspace_mismatch">
        <segment>
          <source>candidate constructor ignored: cannot be used to construct an object in address space %0</source>
          <target>candidate constructor ignored: cannot be used to construct an object in address space {$arg0}</target>
        </segment>
      </unit>
      <unit id="6226" name="note_ovl_candidate_incomplete_deduction">
        <segment>
          <source>candidate template ignored: couldn't infer template argument %0</source>
          <target>candidate template ignored: couldn't infer template argument {$arg0}</target>
        </segment>
      </unit>
      <unit id="6227" name="note_ovl_candidate_incomplete_deduction_pack">
        <segment>
          <source>candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2</source>
          <target>candidate template ignored: deduced too few arguments for expanded pack {$arg0}; no argument for %ordinal1 expanded parameter in deduced argument pack {$arg2}</target>
        </segment>
      </unit>
      <unit id="6228" name="note_ovl_candidate_inconsistent_deduction">
        <segment>
          <source>candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3</source>
          <target>candidate template ignored: deduced {$arg0 :select s0=|conflicting types| s1=|conflicting values| s2=|conflicting templates| s3=|packs of different lengths|} for parameter {$arg1}%diff{ ($ vs. $)|}2,3</target>
        </segment>
      </unit>
      <unit id="6229" name="note_ovl_candidate_inconsistent_deduction_types">
        <segment>
          <source>candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4</source>
          <target>candidate template ignored: deduced values %diff{of conflicting types for parameter {$arg0} ({$arg1} of type $ vs. {$arg3} of type $)|{$arg1} and {$arg3} of conflicting types for parameter {$arg0}}2,4</target>
        </segment>
      </unit>
      <unit id="6230" name="note_ovl_candidate_inherited_constructor">
        <segment>
          <source>constructor from base class %0 inherited here</source>
          <target>constructor from base class {$arg0} inherited here</target>
        </segment>
      </unit>
      <unit id="6231" name="note_ovl_candidate_inherited_constructor_slice">
        <segment>
          <source>candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object</source>
          <target>candidate {$arg0 :select s0=|constructor| s1=|template|} ignored: inherited constructor cannot be used to {$arg1 :select s0=|copy| s1=|move|} object</target>
        </segment>
      </unit>
      <unit id="6232" name="note_ovl_candidate_instantiation_depth">
        <segment>
          <source>candidate template ignored: substitution exceeded maximum template instantiation depth</source>
          <target>candidate template ignored: substitution exceeded maximum template instantiation depth</target>
        </segment>
      </unit>
      <unit id="6233" name="note_ovl_candidate_non_deduced_mismatch">
        <segment>
          <source>candidate template ignored: could not match %diff{$ against $|types}0,1</source>
          <target>candidate template ignored: could not match %diff{$ against $|types}0,1</target>
        </segment>
      </unit>
      <unit id="6234" name="note_ovl_candidate_non_deduced_mismatch_qualified">
        <segment>
          <source>candidate template ignored: could not match %q0 against %q1</source>
          <target>candidate template ignored: could not match {$arg0 :q} against {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="6235" name="note_ovl_candidate_substitution_failure">
        <segment>
          <source>candidate template ignored: substitution failure%0%1</source>
          <target>candidate template ignored: substitution failure{$arg0}{$arg1}</target>
        </segment>
      </unit>
      <unit id="6236" name="note_ovl_candidate_underqualified">
        <segment>
          <source>candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1</source>
          <target>candidate template ignored: cannot deduce a type for {$arg0} that would make {$arg2} equal {$arg1}</target>
        </segment>
      </unit>
      <unit id="6237" name="note_ovl_candidate_unsatisfied_constraints">
        <segment>
          <source>candidate template ignored: constraints not satisfied%0</source>
          <target>candidate template ignored: constraints not satisfied{$arg0}</target>
        </segment>
      </unit>
      <unit id="6238" name="note_ovl_surrogate_cand">
        <segment>
          <source>conversion candidate of type %0</source>
          <target>conversion candidate of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="6239" name="note_ovl_surrogate_constraints_not_satisfied">
        <segment>
          <source>conversion candidate %0 not viable: constraints not satisfied</source>
          <target>conversion candidate {$arg0} not viable: constraints not satisfied</target>
        </segment>
      </unit>
      <unit id="6240" name="note_ovl_too_many_candidates">
        <segment>
          <source>remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them</source>
          <target>remaining {$arg0} candidate%s0 omitted; pass -fshow-overloads=all to show them</target>
        </segment>
      </unit>
      <unit id="6241" name="note_ownership_returns_index_mismatch">
        <segment>
          <source>declared with index %0 here</source>
          <target>declared with index {$arg0} here</target>
        </segment>
      </unit>
      <unit id="6242" name="note_ownership_takes_class_mismatch">
        <segment>
          <source>declared with class '%0' here</source>
          <target>declared with class '{$arg0}' here</target>
        </segment>
      </unit>
      <unit id="6243" name="note_parameter_here">
        <segment>
          <source>passing argument to parameter here</source>
          <target>passing argument to parameter here</target>
        </segment>
      </unit>
      <unit id="6244" name="note_parameter_mapping_substitution_here">
        <segment>
          <source>while substituting into concept arguments here; substitution failures not allowed in concept arguments</source>
          <target>while substituting into concept arguments here; substitution failures not allowed in concept arguments</target>
        </segment>
      </unit>
      <unit id="6245" name="note_parameter_named_here">
        <segment>
          <source>passing argument to parameter %0 here</source>
          <target>passing argument to parameter {$arg0} here</target>
        </segment>
      </unit>
      <unit id="6246" name="note_parameter_pack_here">
        <segment>
          <source>parameter pack %0 declared here</source>
          <target>parameter pack {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6247" name="note_parameter_type">
        <segment>
          <source>parameter of type %0 is declared here</source>
          <target>parameter of type {$arg0} is declared here</target>
        </segment>
      </unit>
      <unit id="6248" name="note_partial_availability_specified_here">
        <segment>
          <source>%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4</source>
          <target>{$arg0} has been marked as being introduced in {$arg1} {$arg2} {$arg4 :select s0=|| s1=|in {$arg5} environment |}here, but the deployment target is {$arg1} {$arg3}{$arg4 :select s0=|| s1=| {$arg6} environment |}</target>
        </segment>
      </unit>
      <unit id="6249" name="note_partial_spec_match">
        <segment>
          <source>partial specialization matches %0</source>
          <target>partial specialization matches {$arg0}</target>
        </segment>
      </unit>
      <unit id="6250" name="note_partial_spec_not_more_specialized_than_primary">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="6251" name="note_performs_forbidden_arc_conversion">
        <segment>
          <source>inline function performs a conversion which is forbidden in ARC</source>
          <target>inline function performs a conversion which is forbidden in ARC</target>
        </segment>
      </unit>
      <unit id="6252" name="note_pointer_declared_here">
        <segment>
          <source>pointer %0 declared here</source>
          <target>pointer {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6253" name="note_possible_target_of_call">
        <segment>
          <source>possible target for call</source>
          <target>possible target for call</target>
        </segment>
      </unit>
      <unit id="6254" name="note_pragma_attribute_applied_decl_here">
        <segment>
          <source>when applied to this declaration</source>
          <target>when applied to this declaration</target>
        </segment>
      </unit>
      <unit id="6255" name="note_pragma_attribute_region_ends_here">
        <segment>
          <source>'#pragma clang attribute push' regions ends here</source>
          <target>'#pragma clang attribute push' regions ends here</target>
        </segment>
      </unit>
      <unit id="6256" name="note_pragma_pack_here">
        <segment>
          <source>previous '#pragma pack' directive that modifies alignment is here</source>
          <target>previous '#pragma pack' directive that modifies alignment is here</target>
        </segment>
      </unit>
      <unit id="6257" name="note_pragma_pack_pop_instead_reset">
        <segment>
          <source>did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?</source>
          <target>did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?</target>
        </segment>
      </unit>
      <unit id="6258" name="note_precedence_bitwise_first">
        <segment>
          <source>place parentheses around the %0 expression to evaluate it first</source>
          <target>place parentheses around the {$arg0} expression to evaluate it first</target>
        </segment>
      </unit>
      <unit id="6259" name="note_precedence_conditional_first">
        <segment>
          <source>place parentheses around the '?:' expression to evaluate it first</source>
          <target>place parentheses around the '?:' expression to evaluate it first</target>
        </segment>
      </unit>
      <unit id="6260" name="note_precedence_silence">
        <segment>
          <source state="initial">place parentheses around the %quoted0 expression to silence this warning</source>
          <target>place parentheses around the %quoted0 expression to silence this warning</target>
        </segment>
      </unit>
      <unit id="6261" name="note_prev_module_declaration">
        <segment>
          <source>previous module declaration is here</source>
          <target>previous module declaration is here</target>
        </segment>
      </unit>
      <unit id="6262" name="note_prev_module_definition">
        <segment>
          <source>previously defined here</source>
          <target>previously defined here</target>
        </segment>
      </unit>
      <unit id="6263" name="note_prev_module_definition_from_ast_file">
        <segment>
          <source>module loaded from '%0'</source>
          <target>module loaded from '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="6264" name="note_prev_partial_spec_here">
        <segment>
          <source>previous declaration of class template partial specialization %0 is here</source>
          <target>previous declaration of class template partial specialization {$arg0} is here</target>
        </segment>
      </unit>
      <unit id="6265" name="note_previous_access_declaration">
        <segment>
          <source>previously declared '%1' here</source>
          <target>previously declared '{$arg1}' here</target>
        </segment>
      </unit>
      <unit id="6266" name="note_previous_attribute">
        <segment>
          <source>previous attribute is here</source>
          <target>previous attribute is here</target>
        </segment>
      </unit>
      <unit id="6267" name="note_previous_builtin_declaration">
        <segment>
          <source>%0 is a builtin with type %1</source>
          <target>{$arg0} is a builtin with type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6268" name="note_previous_decl">
        <segment>
          <source>%0 declared here</source>
          <target>{$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6269" name="note_previous_declaration_as">
        <segment>
          <source>previously declared as %0 here</source>
          <target>previously declared as {$arg0} here</target>
        </segment>
      </unit>
      <unit id="6270" name="note_previous_exception_handler">
        <segment>
          <source>for type %0</source>
          <target>for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="6271" name="note_previous_explicit_instantiation">
        <segment>
          <source>previous explicit instantiation is here</source>
          <target>previous explicit instantiation is here</target>
        </segment>
      </unit>
      <unit id="6272" name="note_previous_field_init">
        <segment>
          <source>previous initialization for field %0 is here</source>
          <target>previous initialization for field {$arg0} is here</target>
        </segment>
      </unit>
      <unit id="6273" name="note_previous_initializer">
        <segment>
          <source>previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0</source>
          <target>previous initialization {$arg0 :select s0=|| s1=|with side effects |}is here{$arg0 :select s0=|| s1=| (side effects will not occur at run time)|}</target>
        </segment>
      </unit>
      <unit id="6274" name="note_previous_ms_inheritance">
        <segment>
          <source>previous inheritance model specified here</source>
          <target>previous inheritance model specified here</target>
        </segment>
      </unit>
      <unit id="6275" name="note_previous_namespace_alias">
        <segment>
          <source>previously defined as an alias for %0</source>
          <target>previously defined as an alias for {$arg0}</target>
        </segment>
      </unit>
      <unit id="6276" name="note_previous_template_specialization">
        <segment>
          <source>previous template specialization is here</source>
          <target>previous template specialization is here</target>
        </segment>
      </unit>
      <unit id="6277" name="note_previous_uuid">
        <segment>
          <source>previous uuid specified here</source>
          <target>previous uuid specified here</target>
        </segment>
      </unit>
      <unit id="6278" name="note_printf_c_str">
        <segment>
          <source>did you mean to call the %0 method?</source>
          <target>did you mean to call the {$arg0} method?</target>
        </segment>
      </unit>
      <unit id="6279" name="note_prior_template_arg_substitution">
        <segment>
          <source>while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2</source>
          <target>while substituting prior template arguments into {$arg0 :select s0=|non-type| s1=|template|} template parameter{$arg1} {$arg2}</target>
        </segment>
      </unit>
      <unit id="6280" name="note_private_extern">
        <segment>
          <source>use __attribute__((visibility("hidden"))) attribute instead</source>
          <target>use __attribute__((visibility("hidden"))) attribute instead</target>
        </segment>
      </unit>
      <unit id="6281" name="note_private_module_fragment">
        <segment>
          <source>private module fragment begins here</source>
          <target>private module fragment begins here</target>
        </segment>
      </unit>
      <unit id="6282" name="note_property_attribute">
        <segment>
          <source>property %0 is declared %select{deprecated|unavailable|partial}1 here</source>
          <target>property {$arg0} is declared {$arg1 :select s0=|deprecated| s1=|unavailable| s2=|partial|} here</target>
        </segment>
      </unit>
      <unit id="6283" name="note_property_declare">
        <segment>
          <source>property declared here</source>
          <target>property declared here</target>
        </segment>
      </unit>
      <unit id="6284" name="note_property_synthesize">
        <segment>
          <source>property synthesized here</source>
          <target>property synthesized here</target>
        </segment>
      </unit>
      <unit id="6285" name="note_protected_by___block">
        <segment>
          <source>jump bypasses setup of __block variable</source>
          <target>jump bypasses setup of __block variable</target>
        </segment>
      </unit>
      <unit id="6286" name="note_protected_by_cleanup">
        <segment>
          <source>jump bypasses initialization of variable with __attribute__((cleanup))</source>
          <target>jump bypasses initialization of variable with __attribute__((cleanup))</target>
        </segment>
      </unit>
      <unit id="6287" name="note_protected_by_consteval_if">
        <segment>
          <source>jump enters controlled statement of consteval if</source>
          <target>jump enters controlled statement of consteval if</target>
        </segment>
      </unit>
      <unit id="6288" name="note_protected_by_constexpr_if">
        <segment>
          <source>jump enters controlled statement of constexpr if</source>
          <target>jump enters controlled statement of constexpr if</target>
        </segment>
      </unit>
      <unit id="6289" name="note_protected_by_cxx_catch">
        <segment>
          <source>jump bypasses initialization of catch block</source>
          <target>jump bypasses initialization of catch block</target>
        </segment>
      </unit>
      <unit id="6290" name="note_protected_by_cxx_try">
        <segment>
          <source>jump bypasses initialization of try block</source>
          <target>jump bypasses initialization of try block</target>
        </segment>
      </unit>
      <unit id="6291" name="note_protected_by_if_available">
        <segment>
          <source>jump enters controlled statement of if available</source>
          <target>jump enters controlled statement of if available</target>
        </segment>
      </unit>
      <unit id="6292" name="note_protected_by_non_trivial_c_struct_init">
        <segment>
          <source>jump bypasses initialization of variable of non-trivial C struct type</source>
          <target>jump bypasses initialization of variable of non-trivial C struct type</target>
        </segment>
      </unit>
      <unit id="6293" name="note_protected_by_objc_autoreleasepool">
        <segment>
          <source>jump bypasses auto release push of @autoreleasepool block</source>
          <target>jump bypasses auto release push of @autoreleasepool block</target>
        </segment>
      </unit>
      <unit id="6294" name="note_protected_by_objc_catch">
        <segment>
          <source>jump bypasses initialization of @catch block</source>
          <target>jump bypasses initialization of @catch block</target>
        </segment>
      </unit>
      <unit id="6295" name="note_protected_by_objc_fast_enumeration">
        <segment>
          <source>jump enters Objective-C fast enumeration loop</source>
          <target>jump enters Objective-C fast enumeration loop</target>
        </segment>
      </unit>
      <unit id="6296" name="note_protected_by_objc_finally">
        <segment>
          <source>jump bypasses initialization of @finally block</source>
          <target>jump bypasses initialization of @finally block</target>
        </segment>
      </unit>
      <unit id="6297" name="note_protected_by_objc_strong_init">
        <segment>
          <source>jump bypasses initialization of __strong variable</source>
          <target>jump bypasses initialization of __strong variable</target>
        </segment>
      </unit>
      <unit id="6298" name="note_protected_by_objc_synchronized">
        <segment>
          <source>jump bypasses initialization of @synchronized block</source>
          <target>jump bypasses initialization of @synchronized block</target>
        </segment>
      </unit>
      <unit id="6299" name="note_protected_by_objc_try">
        <segment>
          <source>jump bypasses initialization of @try block</source>
          <target>jump bypasses initialization of @try block</target>
        </segment>
      </unit>
      <unit id="6300" name="note_protected_by_objc_weak_init">
        <segment>
          <source>jump bypasses initialization of __weak variable</source>
          <target>jump bypasses initialization of __weak variable</target>
        </segment>
      </unit>
      <unit id="6301" name="note_protected_by_seh_except">
        <segment>
          <source>jump bypasses initialization of __except block</source>
          <target>jump bypasses initialization of __except block</target>
        </segment>
      </unit>
      <unit id="6302" name="note_protected_by_seh_finally">
        <segment>
          <source>jump bypasses initialization of __finally block</source>
          <target>jump bypasses initialization of __finally block</target>
        </segment>
      </unit>
      <unit id="6303" name="note_protected_by_seh_try">
        <segment>
          <source>jump bypasses initialization of __try block</source>
          <target>jump bypasses initialization of __try block</target>
        </segment>
      </unit>
      <unit id="6304" name="note_protected_by_variable_init">
        <segment>
          <source>jump bypasses variable initialization</source>
          <target>jump bypasses variable initialization</target>
        </segment>
      </unit>
      <unit id="6305" name="note_protected_by_variable_non_pod">
        <segment>
          <source>jump bypasses initialization of non-POD variable</source>
          <target>jump bypasses initialization of non-POD variable</target>
        </segment>
      </unit>
      <unit id="6306" name="note_protected_by_variable_nontriv_destructor">
        <segment>
          <source>jump bypasses variable with a non-trivial destructor</source>
          <target>jump bypasses variable with a non-trivial destructor</target>
        </segment>
      </unit>
      <unit id="6307" name="note_protected_by_vla">
        <segment>
          <source>jump bypasses initialization of variable length array</source>
          <target>jump bypasses initialization of variable length array</target>
        </segment>
      </unit>
      <unit id="6308" name="note_protected_by_vla_type_alias">
        <segment>
          <source>jump bypasses initialization of VLA type alias</source>
          <target>jump bypasses initialization of VLA type alias</target>
        </segment>
      </unit>
      <unit id="6309" name="note_protected_by_vla_typedef">
        <segment>
          <source>jump bypasses initialization of VLA typedef</source>
          <target>jump bypasses initialization of VLA typedef</target>
        </segment>
      </unit>
      <unit id="6310" name="note_protocol_decl">
        <segment>
          <source>protocol is declared here</source>
          <target>protocol is declared here</target>
        </segment>
      </unit>
      <unit id="6311" name="note_protocol_decl_undefined">
        <segment>
          <source>protocol %0 has no definition</source>
          <target>protocol {$arg0} has no definition</target>
        </segment>
      </unit>
      <unit id="6312" name="note_protocol_method">
        <segment>
          <source>protocol method is here</source>
          <target>protocol method is here</target>
        </segment>
      </unit>
      <unit id="6313" name="note_protocol_property_declare">
        <segment>
          <source>it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here</source>
          <target>it could also be property {$arg0 :select s0=|of type {$arg1}| s1=|without attribute '{$arg1}'| s2=|with attribute '{$arg1}'| s3=|with getter {$arg1}| s4=|with setter {$arg1}|} declared here</target>
        </segment>
      </unit>
      <unit id="6314" name="note_ptrauth_virtual_function_incomplete_arg_ret_type">
        <segment>
          <source>%0 is incomplete</source>
          <target>{$arg0} is incomplete</target>
        </segment>
      </unit>
      <unit id="6315" name="note_ptrauth_virtual_function_pointer_incomplete_arg_ret">
        <segment>
          <source>cannot take an address of a virtual member function if its return or argument types are incomplete</source>
          <target>cannot take an address of a virtual member function if its return or argument types are incomplete</target>
        </segment>
      </unit>
      <unit id="6316" name="note_pure_qualified_call_kext">
        <segment>
          <source>qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext</source>
          <target>qualified call to {$arg0}::{$arg1} is treated as a virtual call to {$arg1} due to -fapple-kext</target>
        </segment>
      </unit>
      <unit id="6317" name="note_pure_virtual_function">
        <segment>
          <source>unimplemented pure virtual method %0 in %1</source>
          <target>unimplemented pure virtual method {$arg0} in {$arg1}</target>
        </segment>
      </unit>
      <unit id="6318" name="note_raii_guard_add_name">
        <segment>
          <source>add a variable name to declare a %0 initialized with %1</source>
          <target>add a variable name to declare a {$arg0} initialized with {$arg1}</target>
        </segment>
      </unit>
      <unit id="6319" name="note_receiver_class_declared">
        <segment>
          <source>receiver is instance of class declared here</source>
          <target>receiver is instance of class declared here</target>
        </segment>
      </unit>
      <unit id="6320" name="note_receiver_expr_here">
        <segment>
          <source>receiver expression is here</source>
          <target>receiver expression is here</target>
        </segment>
      </unit>
      <unit id="6321" name="note_receiver_is_id">
        <segment>
          <source>receiver is treated with 'id' type for purpose of method lookup</source>
          <target>receiver is treated with 'id' type for purpose of method lookup</target>
        </segment>
      </unit>
      <unit id="6322" name="note_recursive_default_argument_used_here">
        <segment>
          <source>default argument used here</source>
          <target>default argument used here</target>
        </segment>
      </unit>
      <unit id="6323" name="note_redefinition_include_same_file">
        <segment>
          <source>'%0' included multiple times, additional include site here</source>
          <target>'{$arg0}' included multiple times, additional include site here</target>
        </segment>
      </unit>
      <unit id="6324" name="note_redefinition_modules_same_file">
        <segment>
          <source>'%0' included multiple times, additional include site in header from module '%1'</source>
          <target>'{$arg0}' included multiple times, additional include site in header from module '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6325" name="note_ref_or_ptr_member_declared_here">
        <segment>
          <source>%select{reference|pointer}0 member declared here</source>
          <target>{$arg0 :select s0=|reference| s1=|pointer|} member declared here</target>
        </segment>
      </unit>
      <unit id="6326" name="note_refconst_member_not_initialized">
        <segment>
          <source>%select{const|reference}0 member %1 will never be initialized</source>
          <target>{$arg0 :select s0=|const| s1=|reference|} member {$arg1} will never be initialized</target>
        </segment>
      </unit>
      <unit id="6327" name="note_reference_is_return_value">
        <segment>
          <source>%0 returns a reference</source>
          <target>{$arg0} returns a reference</target>
        </segment>
      </unit>
      <unit id="6328" name="note_reference_placeholder">
        <segment>
          <source>placeholder declared here</source>
          <target>placeholder declared here</target>
        </segment>
      </unit>
      <unit id="6329" name="note_referenced_type_template">
        <segment>
          <source>%select{class|type alias}0 template declared here</source>
          <target>{$arg0 :select s0=|class| s1=|type alias|} template declared here</target>
        </segment>
      </unit>
      <unit id="6330" name="note_reinterpret_updowncast_use_static">
        <segment>
          <source>use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0</source>
          <target>use 'static_cast' to adjust the pointer correctly while {$arg0 :select s0=|upcasting| s1=|downcasting|}</target>
        </segment>
      </unit>
      <unit id="6331" name="note_related_result_type_explicit">
        <segment>
          <source>%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0</source>
          <target>{$arg0 :select s0=|overridden| s1=|current|} method is explicitly declared 'instancetype'{$arg0 :select s0=|| s1=| and is expected to return an instance of its class type|}</target>
        </segment>
      </unit>
      <unit id="6332" name="note_related_result_type_family">
        <segment>
          <source>%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0</source>
          <target>{$arg0 :select s0=|overridden| s1=|current|} method is part of the '{$arg1 :select s0=|| s1=|alloc| s2=|copy| s3=|init| s4=|mutableCopy| s5=|new| s6=|autorelease| s7=|dealloc| s8=|finalize| s9=|release| s10=|retain| s11=|retainCount| s12=|self|}' method family{$arg0 :select s0=|| s1=| and is expected to return an instance of its class type|}</target>
        </segment>
      </unit>
      <unit id="6333" name="note_related_result_type_inferred">
        <segment>
          <source>%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)</source>
          <target>{$arg0 :select s0=|class| s1=|instance|} method {$arg1} is assumed to return an instance of its receiver type ({$arg2})</target>
        </segment>
      </unit>
      <unit id="6334" name="note_related_result_type_overridden">
        <segment>
          <source>overridden method returns an instance of its class type</source>
          <target>overridden method returns an instance of its class type</target>
        </segment>
      </unit>
      <unit id="6335" name="note_remove_abs">
        <segment>
          <source>remove the call to '%0' since unsigned values cannot be negative</source>
          <target>remove the call to '{$arg0}' since unsigned values cannot be negative</target>
        </segment>
      </unit>
      <unit id="6336" name="note_remove_max_call">
        <segment>
          <source>remove call to max function and unsigned zero argument</source>
          <target>remove call to max function and unsigned zero argument</target>
        </segment>
      </unit>
      <unit id="6337" name="note_remove_move">
        <segment>
          <source>remove std::move call here</source>
          <target>remove std::move call here</target>
        </segment>
      </unit>
      <unit id="6338" name="note_remove_parens_for_variable_declaration">
        <segment>
          <source>remove parentheses to silence this warning</source>
          <target>remove parentheses to silence this warning</target>
        </segment>
      </unit>
      <unit id="6339" name="note_replace_abs_function">
        <segment>
          <source>use function '%0' instead</source>
          <target>use function '{$arg0}' instead</target>
        </segment>
      </unit>
      <unit id="6340" name="note_replace_equals_default_to_delete">
        <segment>
          <source>replace 'default' with 'delete'</source>
          <target>replace 'default' with 'delete'</target>
        </segment>
      </unit>
      <unit id="6341" name="note_rewriting_operator_as_spaceship">
        <segment>
          <source>while rewriting comparison as call to 'operator&lt;=&gt;' declared here</source>
          <target>while rewriting comparison as call to 'operator&lt;=&gt;' declared here</target>
        </segment>
      </unit>
      <unit id="6342" name="note_riscv_repeated_interrupt_attribute">
        <segment>
          <source>repeated RISC-V 'interrupt' attribute is here</source>
          <target>repeated RISC-V 'interrupt' attribute is here</target>
        </segment>
      </unit>
      <unit id="6343" name="note_safe_buffer_debug_mode">
        <segment>
          <source>safe buffers debug: %0</source>
          <target>safe buffers debug: {$arg0}</target>
        </segment>
      </unit>
      <unit id="6344" name="note_safe_buffer_usage_suggestions_disabled">
        <segment>
          <source>pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions</source>
          <target>pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions</target>
        </segment>
      </unit>
      <unit id="6345" name="note_sentinel_here">
        <segment>
          <source>%select{function|method|block}0 has been explicitly marked sentinel here</source>
          <target>{$arg0 :select s0=|function| s1=|method| s2=|block|} has been explicitly marked sentinel here</target>
        </segment>
      </unit>
      <unit id="6346" name="note_shadow_field">
        <segment>
          <source>declared here</source>
          <target>declared here</target>
        </segment>
      </unit>
      <unit id="6347" name="note_silence_aligned_allocation_unavailable">
        <segment>
          <source>if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic</source>
          <target>if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic</target>
        </segment>
      </unit>
      <unit id="6348" name="note_single_arg_concept_specialization_constraint_evaluated_to_false">
        <segment>
          <source>%select{and|because}0 %1 does not satisfy %2</source>
          <target>{$arg0 :select s0=|and| s1=|because|} {$arg1} does not satisfy {$arg2}</target>
        </segment>
      </unit>
      <unit id="6349" name="note_sme_use_preserves_za">
        <segment>
          <source>add '__arm_preserves("za")' to the callee if it preserves ZA</source>
          <target>add '__arm_preserves("za")' to the callee if it preserves ZA</target>
        </segment>
      </unit>
      <unit id="6350" name="note_specialized_decl">
        <segment>
          <source>attempt to specialize declaration here</source>
          <target>attempt to specialize declaration here</target>
        </segment>
      </unit>
      <unit id="6351" name="note_specialized_entity">
        <segment>
          <source>explicitly specialized declaration is here</source>
          <target>explicitly specialized declaration is here</target>
        </segment>
      </unit>
      <unit id="6352" name="note_static_for_internal_linkage">
        <segment>
          <source>declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit</source>
          <target>declare 'static' if the {$arg0 :select s0=|variable| s1=|function|} is not intended to be used outside of this translation unit</target>
        </segment>
      </unit>
      <unit id="6353" name="note_string_plus_scalar_silence">
        <segment>
          <source>use array indexing to silence this warning</source>
          <target>use array indexing to silence this warning</target>
        </segment>
      </unit>
      <unit id="6354" name="note_strlcpycat_wrong_size">
        <segment>
          <source>change size argument to be the size of the destination</source>
          <target>change size argument to be the size of the destination</target>
        </segment>
      </unit>
      <unit id="6355" name="note_strncat_wrong_size">
        <segment>
          <source>change the argument to be the free space in the destination buffer minus the terminating null byte</source>
          <target>change the argument to be the free space in the destination buffer minus the terminating null byte</target>
        </segment>
      </unit>
      <unit id="6356" name="note_struct_class_suggestion">
        <segment>
          <source>did you mean %select{struct|interface|class}0 here?</source>
          <target>did you mean {$arg0 :select s0=|struct| s1=|interface| s2=|class|} here?</target>
        </segment>
      </unit>
      <unit id="6357" name="note_substituted_constraint_expr_is_ill_formed">
        <segment>
          <source>because substituted constraint expression is ill-formed%0</source>
          <target>because substituted constraint expression is ill-formed{$arg0}</target>
        </segment>
      </unit>
      <unit id="6358" name="note_suppress_ctad_maybe_unsupported">
        <segment>
          <source>add a deduction guide to suppress this warning</source>
          <target>add a deduction guide to suppress this warning</target>
        </segment>
      </unit>
      <unit id="6359" name="note_suppressed_class_declare">
        <segment>
          <source>class with specified objc_requires_property_definitions attribute is declared here</source>
          <target>class with specified objc_requires_property_definitions attribute is declared here</target>
        </segment>
      </unit>
      <unit id="6360" name="note_surrounding_namespace_ends_here">
        <segment>
          <source>surrounding namespace with visibility attribute ends here</source>
          <target>surrounding namespace with visibility attribute ends here</target>
        </segment>
      </unit>
      <unit id="6361" name="note_surrounding_namespace_starts_here">
        <segment>
          <source>surrounding namespace with visibility attribute starts here</source>
          <target>surrounding namespace with visibility attribute starts here</target>
        </segment>
      </unit>
      <unit id="6362" name="note_suspicious_bzero_size_silence">
        <segment>
          <source>parenthesize the second argument to silence</source>
          <target>parenthesize the second argument to silence</target>
        </segment>
      </unit>
      <unit id="6363" name="note_suspicious_sizeof_memset_silence">
        <segment>
          <source>%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence</source>
          <target>{$arg0 :select s0=|parenthesize the third argument| s1=|cast the second argument to 'int'|} to silence</target>
        </segment>
      </unit>
      <unit id="6364" name="note_switch_conversion">
        <segment>
          <source>conversion to %select{integral|enumeration}0 type %1</source>
          <target>conversion to {$arg0 :select s0=|integral| s1=|enumeration|} type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6365" name="note_tail_call_required">
        <segment>
          <source>tail call required by %0 attribute here</source>
          <target>tail call required by {$arg0} attribute here</target>
        </segment>
      </unit>
      <unit id="6366" name="note_template_arg_internal_object">
        <segment>
          <source>non-type template argument refers to %select{function|object}0 here</source>
          <target>non-type template argument refers to {$arg0 :select s0=|function| s1=|object|} here</target>
        </segment>
      </unit>
      <unit id="6367" name="note_template_arg_refers_here">
        <segment>
          <source>non-type template argument refers here</source>
          <target>non-type template argument refers here</target>
        </segment>
      </unit>
      <unit id="6368" name="note_template_arg_refers_here_func">
        <segment>
          <source>template argument refers to function template %0, here</source>
          <target>template argument refers to function template {$arg0}, here</target>
        </segment>
      </unit>
      <unit id="6369" name="note_template_arg_template_params_mismatch">
        <segment>
          <source>template template argument has different template parameters than its corresponding template template parameter</source>
          <target>template template argument has different template parameters than its corresponding template template parameter</target>
        </segment>
      </unit>
      <unit id="6370" name="note_template_class_explicit_specialization_was_here">
        <segment>
          <source>class template %0 was explicitly specialized here</source>
          <target>class template {$arg0} was explicitly specialized here</target>
        </segment>
      </unit>
      <unit id="6371" name="note_template_class_instantiation_here">
        <segment>
          <source>in instantiation of template class %q0 requested here</source>
          <target>in instantiation of template class {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6372" name="note_template_class_instantiation_was_here">
        <segment>
          <source>class template %0 was instantiated here</source>
          <target>class template {$arg0} was instantiated here</target>
        </segment>
      </unit>
      <unit id="6373" name="note_template_decl_external">
        <segment>
          <source>template declaration from hidden source: %0</source>
          <target>template declaration from hidden source: {$arg0}</target>
        </segment>
      </unit>
      <unit id="6374" name="note_template_decl_here">
        <segment>
          <source>template is declared here</source>
          <target>template is declared here</target>
        </segment>
      </unit>
      <unit id="6375" name="note_template_declared_here">
        <segment>
          <source>%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here</source>
          <target>{$arg0 :select s0=|function template| s1=|class template| s2=|variable template| s3=|type alias template| s4=|template template parameter|} {$arg1} declared here</target>
        </segment>
      </unit>
      <unit id="6376" name="note_template_default_arg_checking">
        <segment>
          <source>while checking a default template argument used here</source>
          <target>while checking a default template argument used here</target>
        </segment>
      </unit>
      <unit id="6377" name="note_template_enum_def_here">
        <segment>
          <source>in instantiation of enumeration %q0 requested here</source>
          <target>in instantiation of enumeration {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6378" name="note_template_exception_spec_instantiation_here">
        <segment>
          <source>in instantiation of exception specification for %0 requested here</source>
          <target>in instantiation of exception specification for {$arg0} requested here</target>
        </segment>
      </unit>
      <unit id="6379" name="note_template_kw_refers_to_non_template">
        <segment>
          <source>declared as a non-template here</source>
          <target>declared as a non-template here</target>
        </segment>
      </unit>
      <unit id="6380" name="note_template_member_class_here">
        <segment>
          <source>in instantiation of member class %q0 requested here</source>
          <target>in instantiation of member class {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6381" name="note_template_member_function_here">
        <segment>
          <source>in instantiation of member function %q0 requested here</source>
          <target>in instantiation of member function {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6382" name="note_template_nontype_parm_different_type">
        <segment>
          <source>template non-type parameter has a different type %0 in template argument</source>
          <target>template non-type parameter has a different type {$arg0} in template argument</target>
        </segment>
      </unit>
      <unit id="6383" name="note_template_nontype_parm_prev_declaration">
        <segment>
          <source>previous non-type template parameter with type %0 is here</source>
          <target>previous non-type template parameter with type {$arg0} is here</target>
        </segment>
      </unit>
      <unit id="6384" name="note_template_nsdmi_here">
        <segment>
          <source>in instantiation of default member initializer %q0 requested here</source>
          <target>in instantiation of default member initializer {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6385" name="note_template_param_different_kind">
        <segment>
          <source>template parameter has a different kind in template argument</source>
          <target>template parameter has a different kind in template argument</target>
        </segment>
      </unit>
      <unit id="6386" name="note_template_param_external">
        <segment>
          <source>template parameter from hidden source: %0</source>
          <target>template parameter from hidden source: {$arg0}</target>
        </segment>
      </unit>
      <unit id="6387" name="note_template_param_here">
        <segment>
          <source>template parameter is declared here</source>
          <target>template parameter is declared here</target>
        </segment>
      </unit>
      <unit id="6388" name="note_template_param_list_different_arity">
        <segment>
          <source>%select{too few|too many}0 template parameters in template template argument</source>
          <target>{$arg0 :select s0=|too few| s1=|too many|} template parameters in template template argument</target>
        </segment>
      </unit>
      <unit id="6389" name="note_template_param_prev_default_arg">
        <segment>
          <source>previous default template argument defined here</source>
          <target>previous default template argument defined here</target>
        </segment>
      </unit>
      <unit id="6390" name="note_template_param_prev_default_arg_in_other_module">
        <segment>
          <source>previous default template argument defined in module %0</source>
          <target>previous default template argument defined in module {$arg0}</target>
        </segment>
      </unit>
      <unit id="6391" name="note_template_parameter_pack_here">
        <segment>
          <source>previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here</source>
          <target>previous {$arg0 :select s0=|template type| s1=|non-type template| s2=|template template|} parameter{$arg1 :select s0=|| s1=| pack|} declared here</target>
        </segment>
      </unit>
      <unit id="6392" name="note_template_parameter_pack_non_pack">
        <segment>
          <source>%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument</source>
          <target>{$arg0 :select s0=|template type| s1=|non-type template| s2=|template template|} parameter{$arg1 :select s0=|| s1=| pack|} does not match {$arg0 :select s0=|template type| s1=|non-type template| s2=|template template|} parameter{$arg1 :select s0=| pack| s1=||} in template argument</target>
        </segment>
      </unit>
      <unit id="6393" name="note_template_prev_declaration">
        <segment>
          <source>previous template %select{declaration|template parameter}0 is here</source>
          <target>previous template {$arg0 :select s0=|declaration| s1=|template parameter|} is here</target>
        </segment>
      </unit>
      <unit id="6394" name="note_template_recursion_depth">
        <segment>
          <source>use -ftemplate-depth=N to increase recursive template instantiation depth</source>
          <target>use -ftemplate-depth=N to increase recursive template instantiation depth</target>
        </segment>
      </unit>
      <unit id="6395" name="note_template_requirement_instantiation_here">
        <segment>
          <source>in instantiation of requirement here</source>
          <target>in instantiation of requirement here</target>
        </segment>
      </unit>
      <unit id="6396" name="note_template_requirement_params_instantiation_here">
        <segment>
          <source>in instantiation of requirement parameters here</source>
          <target>in instantiation of requirement parameters here</target>
        </segment>
      </unit>
      <unit id="6397" name="note_template_static_data_member_def_here">
        <segment>
          <source>in instantiation of static data member %q0 requested here</source>
          <target>in instantiation of static data member {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6398" name="note_template_type_alias_instantiation_here">
        <segment>
          <source>in instantiation of template type alias %0 requested here</source>
          <target>in instantiation of template type alias {$arg0} requested here</target>
        </segment>
      </unit>
      <unit id="6399" name="note_template_unnamed_type_here">
        <segment>
          <source>unnamed type used in template argument was declared here</source>
          <target>unnamed type used in template argument was declared here</target>
        </segment>
      </unit>
      <unit id="6400" name="note_template_variable_def_here">
        <segment>
          <source>in instantiation of variable template specialization %q0 requested here</source>
          <target>in instantiation of variable template specialization {$arg0 :q} requested here</target>
        </segment>
      </unit>
      <unit id="6401" name="note_thread_warning_in_fun">
        <segment>
          <source>thread warning in function %0</source>
          <target>thread warning in function {$arg0}</target>
        </segment>
      </unit>
      <unit id="6402" name="note_throw_in_dtor">
        <segment>
          <source>%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification</source>
          <target>{$arg0 :select s0=|destructor| s1=|deallocator|} has a {$arg1 :select s0=|non-throwing| s1=|implicit non-throwing|} exception specification</target>
        </segment>
      </unit>
      <unit id="6403" name="note_throw_in_function">
        <segment>
          <source>function declared non-throwing here</source>
          <target>function declared non-throwing here</target>
        </segment>
      </unit>
      <unit id="6404" name="note_throw_underaligned_obj">
        <segment>
          <source>required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)</source>
          <target>required alignment of type {$arg0} ({$arg1} bytes) is larger than the supported alignment of C++ exception objects on this target ({$arg2} bytes)</target>
        </segment>
      </unit>
      <unit id="6405" name="note_transparent_union_first_field_size_align">
        <segment>
          <source>%select{alignment|size}0 of first field is %1 bits</source>
          <target>{$arg0 :select s0=|alignment| s1=|size|} of first field is {$arg1} bits</target>
        </segment>
      </unit>
      <unit id="6406" name="note_type_aware_operator_declared">
        <segment>
          <source>%select{non-|}0type aware %1 declared here in %2</source>
          <target>{$arg0 :select s0=|non-| s1=||}type aware {$arg1} declared here in {$arg2}</target>
        </segment>
      </unit>
      <unit id="6407" name="note_type_incomplete">
        <segment>
          <source>%0 is incomplete</source>
          <target>{$arg0} is incomplete</target>
        </segment>
      </unit>
      <unit id="6408" name="note_type_requirement_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid: %2</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid: {$arg2}</target>
        </segment>
      </unit>
      <unit id="6409" name="note_type_requirement_unknown_substitution_error">
        <segment>
          <source>%select{and|because}0 '%1' would be invalid</source>
          <target>{$arg0 :select s0=|and| s1=|because|} '{$arg1}' would be invalid</target>
        </segment>
      </unit>
      <unit id="6410" name="note_typecheck_assign_const">
        <segment>
          <source>%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0</source>
          <target>%select{function {$arg1} which returns const-qualified type {$arg2} declared here|variable {$arg1} declared const here|{$arg1 :select s0=|non-| s1=||}static data member {$arg2} declared const here|member function {$arg1 :q} is declared const here|{$arg0 :select s0=|| s1=|nested }1data member {$arg2} declared const here|}</target>
        </segment>
      </unit>
      <unit id="6411" name="note_typecheck_invalid_operands_converted">
        <segment>
          <source>%select{first|second}0 operand was implicitly converted to type %1</source>
          <target>{$arg0 :select s0=|first| s1=|second|} operand was implicitly converted to type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6412" name="note_typecheck_member_reference_suggestion">
        <segment>
          <source>did you mean to use '.' instead?</source>
          <target>did you mean to use '.' instead?</target>
        </segment>
      </unit>
      <unit id="6413" name="note_typedef_for_linkage_here">
        <segment>
          <source>type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration</source>
          <target>type is given name {$arg0} for linkage purposes by this {$arg1 :select s0=|typedef| s1=|alias|} declaration</target>
        </segment>
      </unit>
      <unit id="6414" name="note_typename_member_refers_here">
        <segment>
          <source>referenced member %0 is declared here</source>
          <target>referenced member {$arg0} is declared here</target>
        </segment>
      </unit>
      <unit id="6415" name="note_typename_refers_here">
        <segment>
          <source>referenced %0 is declared here</source>
          <target>referenced {$arg0} is declared here</target>
        </segment>
      </unit>
      <unit id="6416" name="note_unguarded_available_silence">
        <segment>
          <source>enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning</source>
          <target>enclose {$arg0} in {$arg1 :select s0=|an @available| s1=|a __builtin_available|} check to silence this warning</target>
        </segment>
      </unit>
      <unit id="6417" name="note_uninit_fixit_remove_cond">
        <segment>
          <source>remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2</source>
          <target>remove the {$arg0 :select s0=|'{$arg1}' if its condition| s1=|condition if it|} is always {$arg2 :select s0=|false| s1=|true|}</target>
        </segment>
      </unit>
      <unit id="6418" name="note_uninit_in_this_constructor">
        <segment>
          <source>during field initialization in %select{this|the implicit default}0 constructor</source>
          <target>during field initialization in {$arg0 :select s0=|this| s1=|the implicit default|} constructor</target>
        </segment>
      </unit>
      <unit id="6419" name="note_uninit_reference_member">
        <segment>
          <source>uninitialized reference member is here</source>
          <target>uninitialized reference member is here</target>
        </segment>
      </unit>
      <unit id="6420" name="note_uninit_var_use">
        <segment>
          <source>%select{uninitialized use occurs|variable is captured by block}0 here</source>
          <target>{$arg0 :select s0=|uninitialized use occurs| s1=|variable is captured by block|} here</target>
        </segment>
      </unit>
      <unit id="6421" name="note_unlocked_here">
        <segment>
          <source>%0 released here</source>
          <target>{$arg0} released here</target>
        </segment>
      </unit>
      <unit id="6422" name="note_unmatched_type_aware_allocator_declared">
        <segment>
          <source>unmatched type aware %0 declared here</source>
          <target>unmatched type aware {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6423" name="note_unreachable_entity">
        <segment>
          <source>%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0</source>
          <target>{$arg0 :select s0=|declaration| s1=|definition| s2=|default argument declared| s3=|explicit specialization declared| s4=|partial specialization declared|} here is not {$arg0 :select s0=|visible| s1=|reachable| s2=|reachable| s3=|reachable| s4=|reachable| s5=|reachable|}</target>
        </segment>
      </unit>
      <unit id="6424" name="note_unreachable_silence">
        <segment>
          <source>silence by adding parentheses to mark code as explicitly dead</source>
          <target>silence by adding parentheses to mark code as explicitly dead</target>
        </segment>
      </unit>
      <unit id="6425" name="note_unreachable_template_decl">
        <segment>
          <source>unreachable declaration of template entity is here</source>
          <target>unreachable declaration of template entity is here</target>
        </segment>
      </unit>
      <unit id="6426" name="note_unsafe_buffer_operation">
        <segment>
          <source>used%select{| in pointer arithmetic| in buffer access}0 here</source>
          <target>used{$arg0 :select s0=|| s1=| in pointer arithmetic| s2=| in buffer access|} here</target>
        </segment>
      </unit>
      <unit id="6427" name="note_unsafe_buffer_printf_call">
        <segment>
          <source>%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0</source>
          <target>{$arg0 :select s0=|| s1=|change to 'snprintf' for explicit bounds checking | s2=| buffer pointer and size may not match| s3=|string argument is not guaranteed to be null-terminated| s4=|'va_list' is unsafe|}</target>
        </segment>
      </unit>
      <unit id="6428" name="note_unsafe_buffer_variable_fixit_group">
        <segment>
          <source>change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3</source>
          <target>change type of {$arg0} to '{$arg1 :select s0=|std::span' to preserve bounds information| s1=|std::array' to label it for hardening| s2=|std::span::iterator' to preserve bounds information|}%select{|, and change {$arg2} to '{$arg3 :select s0=|std::span| s1=|std::array| s2=|std::span::iterator}1' to propagate bounds information between them|}</target>
        </segment>
      </unit>
      <unit id="6429" name="note_unsafe_buffer_variable_fixit_together">
        <segment>
          <source>change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3</source>
          <target>change type of {$arg0} to '{$arg1 :select s0=|std::span' to preserve bounds information| s1=|std::array' to label it for hardening| s2=|std::span::iterator' to preserve bounds information|}{$arg3 :select s0=|| s1=|, and change {$arg2} to safe types to make function {$arg4} bounds-safe|}</target>
        </segment>
      </unit>
      <unit id="6430" name="note_use_ifdef_guards">
        <segment>
          <source>unguarded header; consider using #ifdef guards or #pragma once</source>
          <target>unguarded header; consider using #ifdef guards or #pragma once</target>
        </segment>
      </unit>
      <unit id="6431" name="note_use_non_reference_type">
        <segment>
          <source>use non-reference type %0</source>
          <target>use non-reference type {$arg0}</target>
        </segment>
      </unit>
      <unit id="6432" name="note_use_reference_type">
        <segment>
          <source>use reference type %0 to prevent copying</source>
          <target>use reference type {$arg0} to prevent copying</target>
        </segment>
      </unit>
      <unit id="6433" name="note_use_thread_local">
        <segment>
          <source>use 'thread_local' to allow this</source>
          <target>use 'thread_local' to allow this</target>
        </segment>
      </unit>
      <unit id="6434" name="note_use_type_or_non_reference">
        <segment>
          <source>use non-reference type %0 to make construction explicit or type %1 to prevent copying</source>
          <target>use non-reference type {$arg0} to make construction explicit or type {$arg1} to prevent copying</target>
        </segment>
      </unit>
      <unit id="6435" name="note_used_here">
        <segment>
          <source>used here</source>
          <target>used here</target>
        </segment>
      </unit>
      <unit id="6436" name="note_used_in_initialization_here">
        <segment>
          <source>used in initialization here</source>
          <target>used in initialization here</target>
        </segment>
      </unit>
      <unit id="6437" name="note_user_declared_ctor">
        <segment>
          <source>implicit default constructor suppressed by user-declared constructor</source>
          <target>implicit default constructor suppressed by user-declared constructor</target>
        </segment>
      </unit>
      <unit id="6438" name="note_using_decl">
        <segment>
          <source>%select{|previous }0using declaration</source>
          <target>{$arg0 :select s0=|| s1=|previous |}using declaration</target>
        </segment>
      </unit>
      <unit id="6439" name="note_using_decl_class_member_workaround">
        <segment>
          <source>use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead</source>
          <target>use {$arg0 :select s0=|an alias declaration| s1=|a typedef declaration| s2=|a reference| s3=|a const variable| s4=|a constexpr variable|} instead</target>
        </segment>
      </unit>
      <unit id="6440" name="note_using_decl_conflict">
        <segment>
          <source>conflicting declaration</source>
          <target>conflicting declaration</target>
        </segment>
      </unit>
      <unit id="6441" name="note_using_decl_target">
        <segment>
          <source>target of using declaration</source>
          <target>target of using declaration</target>
        </segment>
      </unit>
      <unit id="6442" name="note_using_enum_decl">
        <segment>
          <source>%select{|previous }0using-enum declaration</source>
          <target>{$arg0 :select s0=|| s1=|previous |}using-enum declaration</target>
        </segment>
      </unit>
      <unit id="6443" name="note_using_value_decl_missing_typename">
        <segment>
          <source>add 'typename' to treat this using declaration as a type</source>
          <target>add 'typename' to treat this using declaration as a type</target>
        </segment>
      </unit>
      <unit id="6444" name="note_value_initialization_here">
        <segment>
          <source>in value-initialization of type %0 here</source>
          <target>in value-initialization of type {$arg0} here</target>
        </segment>
      </unit>
      <unit id="6445" name="note_var_declared_here">
        <segment>
          <source>variable %0 is declared here</source>
          <target>variable {$arg0} is declared here</target>
        </segment>
      </unit>
      <unit id="6446" name="note_var_explicitly_captured_here">
        <segment>
          <source>variable %0 is%select{| explicitly}1 captured here</source>
          <target>variable {$arg0} is{$arg1 :select s0=|| s1=| explicitly|} captured here</target>
        </segment>
      </unit>
      <unit id="6447" name="note_var_fixit_add_initialization">
        <segment>
          <source>initialize the variable %0 to silence this warning</source>
          <target>initialize the variable {$arg0} to silence this warning</target>
        </segment>
      </unit>
      <unit id="6448" name="note_var_prev_partial_spec_here">
        <segment>
          <source>previous declaration of variable template partial specialization is here</source>
          <target>previous declaration of variable template partial specialization is here</target>
        </segment>
      </unit>
      <unit id="6449" name="note_vbase_moved_here">
        <segment>
          <source>%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0</source>
          <target>{$arg0 :select s0=|{$arg1} is a virtual base class of base class {$arg2} declared here| s1=|virtual base class {$arg1} declared here|}</target>
        </segment>
      </unit>
      <unit id="6450" name="note_vla_unsupported">
        <segment>
          <source>variable length arrays are not supported for the current target</source>
          <target>variable length arrays are not supported for the current target</target>
        </segment>
      </unit>
      <unit id="6451" name="note_which_delegates_to">
        <segment>
          <source>which delegates to</source>
          <target>which delegates to</target>
        </segment>
      </unit>
      <unit id="6452" name="note_while_in_implementation">
        <segment>
          <source>detected while default synthesizing properties in class implementation</source>
          <target>detected while default synthesizing properties in class implementation</target>
        </segment>
      </unit>
      <unit id="6453" name="note_widen_bitfield">
        <segment>
          <source>widen this field to %0 bits to store all values of %1</source>
          <target>widen this field to {$arg0} bits to store all values of {$arg1}</target>
        </segment>
      </unit>
      <unit id="6454" name="note_within_field_of_type">
        <segment>
          <source>within field of type %0 declared here</source>
          <target>within field of type {$arg0} declared here</target>
        </segment>
      </unit>
      <unit id="6455" name="note_xor_used_as_pow_silence">
        <segment>
          <source>replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning</source>
          <target>replace expression with '{$arg0}' {$arg1 :select s0=|| s1=|or use 'xor' instead of '^' |}to silence this warning</target>
        </segment>
      </unit>
      <unit id="6456" name="override_keyword_hides_virtual_member_function">
        <segment>
          <source>non-virtual member function marked '%0' hides virtual member %select{function|functions}1</source>
          <target>non-virtual member function marked '{$arg0}' hides virtual member {$arg1 :select s0=|function| s1=|functions|}</target>
        </segment>
      </unit>
      <unit id="6457" name="override_keyword_only_allowed_on_virtual_member_functions">
        <segment>
          <source>only virtual member functions can be marked '%0'</source>
          <target>only virtual member functions can be marked '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="6458" name="warn_abs_too_small">
        <segment>
          <source>absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value</source>
          <target>absolute value function {$arg0} given an argument of type {$arg1} but has parameter of type {$arg2} which may cause truncation of value</target>
        </segment>
      </unit>
      <unit id="6459" name="warn_abstract_final_class">
        <segment>
          <source>abstract class is marked '%select{final|sealed}0'</source>
          <target>abstract class is marked '{$arg0 :select s0=|final| s1=|sealed|}'</target>
        </segment>
      </unit>
      <unit id="6460" name="warn_abstract_vbase_init_ignored">
        <segment>
          <source>initializer for virtual base class %0 of abstract class %1 will never be used</source>
          <target>initializer for virtual base class {$arg0} of abstract class {$arg1} will never be used</target>
        </segment>
      </unit>
      <unit id="6461" name="warn_acc_confusing_routine_name">
        <segment>
          <source>OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended</source>
          <target>OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended</target>
        </segment>
      </unit>
      <unit id="6462" name="warn_acc_deprecated_alias_name">
        <segment>
          <source>OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'</source>
          <target>OpenACC clause name '{$arg0}' is a deprecated clause name and is now an alias for '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6463" name="warn_acc_if_self_conflict">
        <segment>
          <source>OpenACC construct 'self' has no effect when an 'if' clause evaluates to true</source>
          <target>OpenACC construct 'self' has no effect when an 'if' clause evaluates to true</target>
        </segment>
      </unit>
      <unit id="6464" name="warn_acc_routine_unimplemented">
        <segment>
          <source>OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored</source>
          <target>OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored</target>
        </segment>
      </unit>
      <unit id="6465" name="warn_access_decl_deprecated">
        <segment>
          <source>access declarations are deprecated; use using declarations instead</source>
          <target>access declarations are deprecated; use using declarations instead</target>
        </segment>
      </unit>
      <unit id="6466" name="warn_accessor_property_type_mismatch">
        <segment>
          <source>type of property %0 does not match type of accessor %1</source>
          <target>type of property {$arg0} does not match type of accessor {$arg1}</target>
        </segment>
      </unit>
      <unit id="6467" name="warn_acquire_requires_negative_cap">
        <segment>
          <source>acquiring %0 '%1' requires negative capability '%2'</source>
          <target>acquiring {$arg0} '{$arg1}' requires negative capability '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="6468" name="warn_acquired_before">
        <segment>
          <source>%0 '%1' must be acquired before '%2'</source>
          <target>{$arg0} '{$arg1}' must be acquired before '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="6469" name="warn_acquired_before_after_cycle">
        <segment>
          <source>cycle in acquired_before/after dependencies, starting with '%0'</source>
          <target>cycle in acquired_before/after dependencies, starting with '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="6470" name="warn_addition_in_bitshift">
        <segment>
          <source>operator '%0' has lower precedence than '%1'; '%1' will be evaluated first</source>
          <target>operator '{$arg0}' has lower precedence than '{$arg1}'; '{$arg1}' will be evaluated first</target>
        </segment>
      </unit>
      <unit id="6471" name="warn_address_of_reference_bool_conversion">
        <segment>
          <source>reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true</source>
          <target>reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true</target>
        </segment>
      </unit>
      <unit id="6472" name="warn_address_of_reference_null_compare">
        <segment>
          <source>reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0</source>
          <target>reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to {$arg0 :select s0=|true| s1=|false|}</target>
        </segment>
      </unit>
      <unit id="6473" name="warn_aligned_attr_underaligned">
        <segment>
          <source>requested alignment is less than minimum alignment of %1 for type %0</source>
          <target>requested alignment is less than minimum alignment of {$arg1} for type {$arg0}</target>
        </segment>
      </unit>
      <unit id="6474" name="warn_alignment_builtin_useless">
        <segment>
          <source>%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0</source>
          <target>{$arg0 :select s0=|aligning a value| s1=|the result of checking whether a value is aligned|} to 1 byte is {$arg0 :select s0=|a no-op| s1=|always true|}</target>
        </segment>
      </unit>
      <unit id="6475" name="warn_alignment_not_power_of_two">
        <segment>
          <source>requested alignment is not a power of 2</source>
          <target>requested alignment is not a power of 2</target>
        </segment>
      </unit>
      <unit id="6476" name="warn_alloca">
        <segment>
          <source>use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability</source>
          <target>use of function {$arg0} is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability</target>
        </segment>
      </unit>
      <unit id="6477" name="warn_alloca_align_alignof">
        <segment>
          <source>second argument to __builtin_alloca_with_align is supposed to be in bits</source>
          <target>second argument to __builtin_alloca_with_align is supposed to be in bits</target>
        </segment>
      </unit>
      <unit id="6478" name="warn_always_inline_coroutine">
        <segment>
          <source>this coroutine may be split into pieces; not every piece is guaranteed to be inlined</source>
          <target>this coroutine may be split into pieces; not every piece is guaranteed to be inlined</target>
        </segment>
      </unit>
      <unit id="6479" name="warn_ambiguous_suitable_delete_function_found">
        <segment>
          <source>multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception</source>
          <target>multiple suitable {$arg0} functions for {$arg1}; no 'operator delete' function will be invoked if initialization throws an exception</target>
        </segment>
      </unit>
      <unit id="6480" name="warn_anyx86_excessive_regsave">
        <segment>
          <source>%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'</source>
          <target>{$arg0 :select s0=|interrupt service routine| s1=|function with attribute 'no_caller_saved_registers'|} should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'</target>
        </segment>
      </unit>
      <unit id="6481" name="warn_arc_lifetime_result_type">
        <segment>
          <source>ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored</source>
          <target>ARC {$arg0 :select s0=|unused| s1=|__unsafe_unretained| s2=|__strong| s3=|__weak| s4=|__autoreleasing|} lifetime qualifier on return type is ignored</target>
        </segment>
      </unit>
      <unit id="6482" name="warn_arc_literal_assign">
        <segment>
          <source>assigning %select{array literal|dictionary literal|numeric literal|boxed expression|&lt;should not happen&gt;|block literal}0 to a weak %select{property|variable}1; object will be released after assignment</source>
          <target>assigning {$arg0 :select s0=|array literal| s1=|dictionary literal| s2=|numeric literal| s3=|boxed expression| s4=|&lt;should not happen&gt;| s5=|block literal|} to a weak {$arg1 :select s0=|property| s1=|variable|}; object will be released after assignment</target>
        </segment>
      </unit>
      <unit id="6483" name="warn_arc_object_memaccess">
        <segment>
          <source>%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2</source>
          <target>{$arg0 :select s0=|destination for| s1=|source of|} this {$arg1} call is a pointer to ownership-qualified type {$arg2}</target>
        </segment>
      </unit>
      <unit id="6484" name="warn_arc_perform_selector_leaks">
        <segment>
          <source>performSelector may cause a leak because its selector is unknown</source>
          <target>performSelector may cause a leak because its selector is unknown</target>
        </segment>
      </unit>
      <unit id="6485" name="warn_arc_possible_repeated_use_of_weak">
        <segment>
          <source>weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive</source>
          <target>weak {$arg0 :select s0=|variable| s1=|property| s2=|implicit property| s3=|instance variable|} {$arg1} may be accessed multiple times in this {$arg2 :select s0=|function| s1=|method| s2=|block| s3=|lambda|} and may be unpredictably set to nil; assign to a strong variable to keep the object alive</target>
        </segment>
      </unit>
      <unit id="6486" name="warn_arc_repeated_use_of_weak">
        <segment>
          <source>weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive</source>
          <target>weak {$arg0 :select s0=|variable| s1=|property| s2=|implicit property| s3=|instance variable|} {$arg1} is accessed multiple times in this {$arg2 :select s0=|function| s1=|method| s2=|block| s3=|lambda|} but may be unpredictably set to nil; assign to a strong variable to keep the object alive</target>
        </segment>
      </unit>
      <unit id="6487" name="warn_arc_retain_cycle">
        <segment>
          <source>capturing %0 strongly in this block is likely to lead to a retain cycle</source>
          <target>capturing {$arg0} strongly in this block is likely to lead to a retain cycle</target>
        </segment>
      </unit>
      <unit id="6488" name="warn_arc_retained_assign">
        <segment>
          <source>assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment</source>
          <target>assigning retained object to {$arg0 :select s0=|weak| s1=|unsafe_unretained|} {$arg1 :select s0=|property| s1=|variable|}; object will be released after assignment</target>
        </segment>
      </unit>
      <unit id="6489" name="warn_arc_retained_property_assign">
        <segment>
          <source>assigning retained object to unsafe property; object will be released after assignment</source>
          <target>assigning retained object to unsafe property; object will be released after assignment</target>
        </segment>
      </unit>
      <unit id="6490" name="warn_arc_strong_pointer_objc_pointer">
        <segment>
          <source>method parameter of type %0 with no explicit ownership</source>
          <target>method parameter of type {$arg0} with no explicit ownership</target>
        </segment>
      </unit>
      <unit id="6491" name="warn_argument_invalid_range">
        <segment>
          <source>argument value %0 is outside the valid range [%1, %2]</source>
          <target>argument value {$arg0} is outside the valid range [{$arg1}, {$arg2}]</target>
        </segment>
      </unit>
      <unit id="6492" name="warn_argument_undefined_behaviour">
        <segment>
          <source>argument value %0 will result in undefined behaviour</source>
          <target>argument value {$arg0} will result in undefined behaviour</target>
        </segment>
      </unit>
      <unit id="6493" name="warn_arith_conv_enum_float">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} {$arg1 :select s0=|floating-point| s1=|enumeration|} type {$arg2} %plural{2:with|4:from|:and}0 {$arg1 :select s0=|enumeration| s1=|floating-point|} type {$arg3}</target>
        </segment>
      </unit>
      <unit id="6494" name="warn_arith_conv_enum_float_cxx20">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} {$arg1 :select s0=|floating-point| s1=|enumeration|} type {$arg2} %plural{2:with|4:from|:and}0 {$arg1 :select s0=|enumeration| s1=|floating-point|} type {$arg3} is deprecated</target>
        </segment>
      </unit>
      <unit id="6495" name="warn_arith_conv_mixed_anon_enum_types">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6496" name="warn_arith_conv_mixed_anon_enum_types_cxx20">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2 is deprecated</target>
        </segment>
      </unit>
      <unit id="6497" name="warn_arith_conv_mixed_enum_types">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6498" name="warn_arith_conv_mixed_enum_types_cxx20">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2 is deprecated</target>
        </segment>
      </unit>
      <unit id="6499" name="warn_arith_conv_mixed_unicode_types">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different Unicode character types %1 and %2</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different Unicode character types {$arg1} and {$arg2}</target>
        </segment>
      </unit>
      <unit id="6500" name="warn_arm_interrupt_save_fp_without_vfp_unit">
        <segment>
          <source>`interrupt_save_fp` only applies to targets that have a VFP unit enabled for this compilation; this will be treated as a regular `interrupt` attribute</source>
          <target>`interrupt_save_fp` only applies to targets that have a VFP unit enabled for this compilation; this will be treated as a regular `interrupt` attribute</target>
        </segment>
      </unit>
      <unit id="6501" name="warn_arm_interrupt_vfp_clobber">
        <segment>
          <source state="initial">interrupt service routine with vfp enabled may clobber the interruptee's vfp state; consider using the `interrupt_save_fp` attribute to prevent this behavior</source>
          <target>interrupt service routine with vfp enabled may clobber the interruptee's vfp state; consider using the `interrupt_save_fp` attribute to prevent this behavior</target>
        </segment>
      </unit>
      <unit id="6502" name="warn_array_comparison">
        <segment>
          <source>comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers</source>
          <target>comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers</target>
        </segment>
      </unit>
      <unit id="6503" name="warn_array_comparison_cxx26">
        <segment>
          <source>comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers</source>
          <target>comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers</target>
        </segment>
      </unit>
      <unit id="6504" name="warn_array_index_exceeds_bounds">
        <segment>
          <source>array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)</source>
          <target>array index {$arg0} is past the end of the array (that has type {$arg1}{$arg2 :select s0=|| s1=|, cast to {$arg3}|})</target>
        </segment>
      </unit>
      <unit id="6505" name="warn_array_index_exceeds_max_addressable_bounds">
        <segment>
          <source>array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)</source>
          <target>array index {$arg0} refers past the last possible element for an array in {$arg1}-bit address space containing {$arg2}-bit ({$arg3}-byte) elements (max possible {$arg4} element%s5)</target>
        </segment>
      </unit>
      <unit id="6506" name="warn_array_index_precedes_bounds">
        <segment>
          <source>array index %0 is before the beginning of the array</source>
          <target>array index {$arg0} is before the beginning of the array</target>
        </segment>
      </unit>
      <unit id="6507" name="warn_asm_label_on_auto_decl">
        <segment>
          <source>ignored asm label '%0' on automatic variable</source>
          <target>ignored asm label '{$arg0}' on automatic variable</target>
        </segment>
      </unit>
      <unit id="6508" name="warn_asm_mismatched_size_modifier">
        <segment>
          <source>value size does not match register size specified by the constraint and modifier</source>
          <target>value size does not match register size specified by the constraint and modifier</target>
        </segment>
      </unit>
      <unit id="6509" name="warn_assume_aligned_too_great">
        <segment>
          <source>requested alignment must be %0 bytes or smaller; maximum alignment assumed</source>
          <target>requested alignment must be {$arg0} bytes or smaller; maximum alignment assumed</target>
        </segment>
      </unit>
      <unit id="6510" name="warn_assume_side_effects">
        <segment>
          <source>assumption is ignored because it contains (potential) side-effects</source>
          <target>assumption is ignored because it contains (potential) side-effects</target>
        </segment>
      </unit>
      <unit id="6511" name="warn_at_available_unchecked_use">
        <segment>
          <source>%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead</source>
          <target>{$arg0 :select s0=|@available| s1=|__builtin_available|} does not guard availability here; use if ({$arg0 :select s0=|@available| s1=|__builtin_available|}) instead</target>
        </segment>
      </unit>
      <unit id="6512" name="warn_atl_uuid_deprecated">
        <segment>
          <source>specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead</source>
          <target>specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead</target>
        </segment>
      </unit>
      <unit id="6513" name="warn_atomic_implicit_seq_cst">
        <segment>
          <source>implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary</source>
          <target>implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary</target>
        </segment>
      </unit>
      <unit id="6514" name="warn_atomic_member_access">
        <segment>
          <source>accessing a member of an atomic structure or union is undefined behavior</source>
          <target>accessing a member of an atomic structure or union is undefined behavior</target>
        </segment>
      </unit>
      <unit id="6515" name="warn_atomic_op_has_invalid_memory_order">
        <segment>
          <source>%select{|success |failure }0memory order argument to atomic operation is invalid</source>
          <target>{$arg0 :select s0=|| s1=|success | s2=|failure |}memory order argument to atomic operation is invalid</target>
        </segment>
      </unit>
      <unit id="6516" name="warn_atomic_property_rule">
        <segment>
          <source>writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2</source>
          <target>writable atomic property {$arg0} cannot pair a synthesized {$arg1 :select s0=|getter| s1=|setter|} with a user defined {$arg2 :select s0=|getter| s1=|setter|}</target>
        </segment>
      </unit>
      <unit id="6517" name="warn_attr_abi_tag_namespace">
        <segment>
          <source>'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored</source>
          <target>'abi_tag' attribute on {$arg0 :select s0=|non-inline| s1=|anonymous|} namespace ignored</target>
        </segment>
      </unit>
      <unit id="6518" name="warn_attr_min_eq_max">
        <segment>
          <source>%0 attribute minimum and maximum arguments are equal</source>
          <target>{$arg0} attribute minimum and maximum arguments are equal</target>
        </segment>
      </unit>
      <unit id="6519" name="warn_attr_on_unconsumable_class">
        <segment>
          <source>consumed analysis attribute is attached to member of class %0 which isn't marked as consumable</source>
          <target>consumed analysis attribute is attached to member of class {$arg0} which isn't marked as consumable</target>
        </segment>
      </unit>
      <unit id="6520" name="warn_attr_swift_name_decl_kind">
        <segment>
          <source>%0 attribute cannot be applied to this declaration</source>
          <target>{$arg0} attribute cannot be applied to this declaration</target>
        </segment>
      </unit>
      <unit id="6521" name="warn_attr_swift_name_decl_missing_params">
        <segment>
          <source>%0 attribute cannot be applied to a %select{function|method}1 with no parameters</source>
          <target>{$arg0} attribute cannot be applied to a {$arg1 :select s0=|function| s1=|method|} with no parameters</target>
        </segment>
      </unit>
      <unit id="6522" name="warn_attr_swift_name_function">
        <segment>
          <source>%0 attribute argument must be a string literal specifying a Swift function name</source>
          <target>{$arg0} attribute argument must be a string literal specifying a Swift function name</target>
        </segment>
      </unit>
      <unit id="6523" name="warn_attr_swift_name_getter_parameters">
        <segment>
          <source>%0 attribute for getter must not have any parameters besides 'self:'</source>
          <target>{$arg0} attribute for getter must not have any parameters besides 'self:'</target>
        </segment>
      </unit>
      <unit id="6524" name="warn_attr_swift_name_invalid_identifier">
        <segment>
          <source>%0 attribute has invalid identifier for the %select{base|context|parameter}1 name</source>
          <target>{$arg0} attribute has invalid identifier for the {$arg1 :select s0=|base| s1=|context| s2=|parameter|} name</target>
        </segment>
      </unit>
      <unit id="6525" name="warn_attr_swift_name_missing_parameters">
        <segment>
          <source>%0 attribute is missing parameter label clause</source>
          <target>{$arg0} attribute is missing parameter label clause</target>
        </segment>
      </unit>
      <unit id="6526" name="warn_attr_swift_name_multiple_selfs">
        <segment>
          <source>%0 attribute cannot specify more than one 'self:' parameter</source>
          <target>{$arg0} attribute cannot specify more than one 'self:' parameter</target>
        </segment>
      </unit>
      <unit id="6527" name="warn_attr_swift_name_num_params">
        <segment>
          <source>too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)</source>
          <target>too {$arg0 :select s0=|few| s1=|many|} parameters in the signature specified by the {$arg1} attribute (expected {$arg2}; got {$arg3})</target>
        </segment>
      </unit>
      <unit id="6528" name="warn_attr_swift_name_setter_parameters">
        <segment>
          <source>%0 attribute for setter must have one parameter for new value</source>
          <target>{$arg0} attribute for setter must have one parameter for new value</target>
        </segment>
      </unit>
      <unit id="6529" name="warn_attr_swift_name_subscript_getter_newValue">
        <segment>
          <source>%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter</source>
          <target>{$arg0} attribute for 'subscript' getter cannot have a 'newValue:' parameter</target>
        </segment>
      </unit>
      <unit id="6530" name="warn_attr_swift_name_subscript_invalid_parameter">
        <segment>
          <source>%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1</source>
          <target>{$arg0} attribute for 'subscript' must {$arg1 :select s0=|be a getter or setter| s1=|have at least one parameter| s2=|have a 'self:' parameter|}</target>
        </segment>
      </unit>
      <unit id="6531" name="warn_attr_swift_name_subscript_setter_multiple_newValues">
        <segment>
          <source>%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters</source>
          <target>{$arg0} attribute for 'subscript' setter cannot have multiple 'newValue:' parameters</target>
        </segment>
      </unit>
      <unit id="6532" name="warn_attr_swift_name_subscript_setter_no_newValue">
        <segment>
          <source>%0 attribute for 'subscript' setter must have a 'newValue:' parameter</source>
          <target>{$arg0} attribute for 'subscript' setter must have a 'newValue:' parameter</target>
        </segment>
      </unit>
      <unit id="6533" name="warn_attribute_address_multiple_identical_qualifiers">
        <segment>
          <source>multiple identical address spaces specified for type</source>
          <target>multiple identical address spaces specified for type</target>
        </segment>
      </unit>
      <unit id="6534" name="warn_attribute_after_definition_ignored">
        <segment>
          <source>attribute %0 after definition is ignored</source>
          <target>attribute {$arg0} after definition is ignored</target>
        </segment>
      </unit>
      <unit id="6535" name="warn_attribute_argument_n_negative">
        <segment>
          <source>%0 attribute parameter %1 is negative and will be ignored</source>
          <target>{$arg0} attribute parameter {$arg1} is negative and will be ignored</target>
        </segment>
      </unit>
      <unit id="6536" name="warn_attribute_arm_za_builtin_no_za_state">
        <segment>
          <source>builtin call is not valid when calling from a function without active ZA state</source>
          <target>builtin call is not valid when calling from a function without active ZA state</target>
        </segment>
      </unit>
      <unit id="6537" name="warn_attribute_arm_zt0_builtin_no_zt0_state">
        <segment>
          <source>builtin call is not valid when calling from a function without active ZT0 state</source>
          <target>builtin call is not valid when calling from a function without active ZT0 state</target>
        </segment>
      </unit>
      <unit id="6538" name="warn_attribute_cmse_entry_static">
        <segment>
          <source>'cmse_nonsecure_entry' cannot be applied to functions with internal linkage</source>
          <target>'cmse_nonsecure_entry' cannot be applied to functions with internal linkage</target>
        </segment>
      </unit>
      <unit id="6539" name="warn_attribute_dll_instantiated_base_class">
        <segment>
          <source>propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported</source>
          <target>propagating dll attribute to {$arg0 :select s0=|already instantiated| s1=|explicitly specialized|} base class template without dll attribute is not supported</target>
        </segment>
      </unit>
      <unit id="6540" name="warn_attribute_dll_redeclaration">
        <segment>
          <source>redeclaration of %q0 should not add %q1 attribute</source>
          <target>redeclaration of {$arg0 :q} should not add {$arg1 :q} attribute</target>
        </segment>
      </unit>
      <unit id="6541" name="warn_attribute_dllexport_explicit_instantiation_decl">
        <segment>
          <source>explicit instantiation declaration should not be 'dllexport'</source>
          <target>explicit instantiation declaration should not be 'dllexport'</target>
        </segment>
      </unit>
      <unit id="6542" name="warn_attribute_dllexport_explicit_instantiation_def">
        <segment>
          <source>'dllexport' attribute ignored on explicit instantiation definition</source>
          <target>'dllexport' attribute ignored on explicit instantiation definition</target>
        </segment>
      </unit>
      <unit id="6543" name="warn_attribute_dllimport_static_field_definition">
        <segment>
          <source>definition of dllimport static field</source>
          <target>definition of dllimport static field</target>
        </segment>
      </unit>
      <unit id="6544" name="warn_attribute_exclude_from_explicit_instantiation_local_class">
        <segment>
          <source>%0 attribute ignored on local class%select{| member}1</source>
          <target>{$arg0} attribute ignored on local class{$arg1 :select s0=|| s1=| member|}</target>
        </segment>
      </unit>
      <unit id="6545" name="warn_attribute_form_ignored">
        <segment>
          <source>%0 attribute ignored because Clang does not yet support this attribute signature</source>
          <target>{$arg0} attribute ignored because Clang does not yet support this attribute signature</target>
        </segment>
      </unit>
      <unit id="6546" name="warn_attribute_has_no_effect_on_compile_time_if">
        <segment>
          <source>attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement</source>
          <target>attribute {$arg0} has no effect when annotating an 'if {$arg1 :select s0=|constexpr| s1=|consteval|}' statement</target>
        </segment>
      </unit>
      <unit id="6547" name="warn_attribute_has_no_effect_on_infinite_loop">
        <segment>
          <source>attribute %0 has no effect when annotating an infinite loop</source>
          <target>attribute {$arg0} has no effect when annotating an infinite loop</target>
        </segment>
      </unit>
      <unit id="6548" name="warn_attribute_hybrid_patchable_non_extern">
        <segment>
          <source>'hybrid_patchable' is ignored on functions without external linkage</source>
          <target>'hybrid_patchable' is ignored on functions without external linkage</target>
        </segment>
      </unit>
      <unit id="6549" name="warn_attribute_iboutlet">
        <segment>
          <source>%0 attribute can only be applied to instance variables or properties</source>
          <target>{$arg0} attribute can only be applied to instance variables or properties</target>
        </segment>
      </unit>
      <unit id="6550" name="warn_attribute_ignored_for_field_of_type">
        <segment>
          <source>%0 attribute ignored for field of type %1</source>
          <target>{$arg0} attribute ignored for field of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6551" name="warn_attribute_ignored_no_calls_in_stmt">
        <segment>
          <source>%0 attribute is ignored because there exists no call expression inside the statement</source>
          <target>{$arg0} attribute is ignored because there exists no call expression inside the statement</target>
        </segment>
      </unit>
      <unit id="6552" name="warn_attribute_ignored_non_function_pointer">
        <segment>
          <source>%0 attribute is ignored because %1 is not a function pointer</source>
          <target>{$arg0} attribute is ignored because {$arg1} is not a function pointer</target>
        </segment>
      </unit>
      <unit id="6553" name="warn_attribute_ignored_on_inline">
        <segment>
          <source>%0 attribute ignored on inline function</source>
          <target>{$arg0} attribute ignored on inline function</target>
        </segment>
      </unit>
      <unit id="6554" name="warn_attribute_ignored_on_non_definition">
        <segment>
          <source>%0 attribute ignored on a non-definition declaration</source>
          <target>{$arg0} attribute ignored on a non-definition declaration</target>
        </segment>
      </unit>
      <unit id="6555" name="warn_attribute_invalid_on_definition">
        <segment>
          <source>'%0' attribute cannot be specified on a definition</source>
          <target>'{$arg0}' attribute cannot be specified on a definition</target>
        </segment>
      </unit>
      <unit id="6556" name="warn_attribute_no_builtin_invalid_builtin_name">
        <segment>
          <source>'%0' is not a valid builtin name for %1</source>
          <target>'{$arg0}' is not a valid builtin name for {$arg1}</target>
        </segment>
      </unit>
      <unit id="6557" name="warn_attribute_non_character_array">
        <segment>
          <source>%0%select{ attribute|}1 only applies to fields or variables of character array type; type is %2</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} only applies to fields or variables of character array type; type is {$arg2}</target>
        </segment>
      </unit>
      <unit id="6558" name="warn_attribute_nonnull_no_pointers">
        <segment>
          <source>'nonnull' attribute applied to function with no pointer arguments</source>
          <target>'nonnull' attribute applied to function with no pointer arguments</target>
        </segment>
      </unit>
      <unit id="6559" name="warn_attribute_nonnull_parm_no_args">
        <segment>
          <source>'nonnull' attribute when used on parameters takes no arguments</source>
          <target>'nonnull' attribute when used on parameters takes no arguments</target>
        </segment>
      </unit>
      <unit id="6560" name="warn_attribute_not_on_decl">
        <segment>
          <source>%0 attribute ignored when parsing type</source>
          <target>{$arg0} attribute ignored when parsing type</target>
        </segment>
      </unit>
      <unit id="6561" name="warn_attribute_on_void_param">
        <segment>
          <source>attribute %0 cannot be applied to a 'void' parameter</source>
          <target>attribute {$arg0} cannot be applied to a 'void' parameter</target>
        </segment>
      </unit>
      <unit id="6562" name="warn_attribute_packed_for_bitfield">
        <segment>
          <source>'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang</source>
          <target>'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang</target>
        </segment>
      </unit>
      <unit id="6563" name="warn_attribute_pointer_or_reference_only">
        <segment>
          <source>%0 attribute only applies to a pointer or reference (%1 is invalid)</source>
          <target>{$arg0} attribute only applies to a pointer or reference ({$arg1} is invalid)</target>
        </segment>
      </unit>
      <unit id="6564" name="warn_attribute_pointers_only">
        <segment>
          <source>%0 attribute only applies to%select{| constant}1 pointer arguments</source>
          <target>{$arg0} attribute only applies to{$arg1 :select s0=|| s1=| constant|} pointer arguments</target>
        </segment>
      </unit>
      <unit id="6565" name="warn_attribute_precede_definition">
        <segment>
          <source>attribute declaration must precede definition</source>
          <target>attribute declaration must precede definition</target>
        </segment>
      </unit>
      <unit id="6566" name="warn_attribute_protected_visibility">
        <segment>
          <source>target does not support 'protected' visibility; using 'default'</source>
          <target>target does not support 'protected' visibility; using 'default'</target>
        </segment>
      </unit>
      <unit id="6567" name="warn_attribute_return_pointers_only">
        <segment>
          <source>%0 attribute only applies to return values that are pointers</source>
          <target>{$arg0} attribute only applies to return values that are pointers</target>
        </segment>
      </unit>
      <unit id="6568" name="warn_attribute_return_pointers_refs_only">
        <segment>
          <source>%0 attribute only applies to return values that are pointers or references</source>
          <target>{$arg0} attribute only applies to return values that are pointers or references</target>
        </segment>
      </unit>
      <unit id="6569" name="warn_attribute_section_drectve">
        <segment>
          <source>#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead</source>
          <target>#pragma {$arg0}(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead</target>
        </segment>
      </unit>
      <unit id="6570" name="warn_attribute_section_on_redeclaration">
        <segment>
          <source>section attribute is specified on redeclared variable</source>
          <target>section attribute is specified on redeclared variable</target>
        </segment>
      </unit>
      <unit id="6571" name="warn_attribute_sentinel_named_arguments">
        <segment>
          <source>'sentinel' attribute requires named arguments</source>
          <target>'sentinel' attribute requires named arguments</target>
        </segment>
      </unit>
      <unit id="6572" name="warn_attribute_sentinel_not_variadic">
        <segment>
          <source>'sentinel' attribute only supported for variadic %select{functions|blocks}0</source>
          <target>'sentinel' attribute only supported for variadic {$arg0 :select s0=|functions| s1=|blocks|}</target>
        </segment>
      </unit>
      <unit id="6573" name="warn_attribute_type_not_supported">
        <segment>
          <source>%0 attribute argument not supported: %1</source>
          <target>{$arg0} attribute argument not supported: {$arg1}</target>
        </segment>
      </unit>
      <unit id="6574" name="warn_attribute_type_not_supported_global">
        <segment>
          <source>%0 attribute argument '%1' not supported on a global variable</source>
          <target>{$arg0} attribute argument '{$arg1}' not supported on a global variable</target>
        </segment>
      </unit>
      <unit id="6575" name="warn_attribute_unknown_visibility">
        <segment>
          <source>unknown visibility %0</source>
          <target>unknown visibility {$arg0}</target>
        </segment>
      </unit>
      <unit id="6576" name="warn_attribute_void_function_method">
        <segment>
          <source>attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value</source>
          <target>attribute {$arg0} cannot be applied to {$arg1 :select s0=|functions| s1=|Objective-C method|} without return value</target>
        </segment>
      </unit>
      <unit id="6577" name="warn_attribute_weak_on_field">
        <segment>
          <source>__weak attribute cannot be specified on a field declaration</source>
          <target>__weak attribute cannot be specified on a field declaration</target>
        </segment>
      </unit>
      <unit id="6578" name="warn_attribute_weak_on_local">
        <segment>
          <source>__weak attribute cannot be specified on an automatic variable when ARC is not enabled</source>
          <target>__weak attribute cannot be specified on an automatic variable when ARC is not enabled</target>
        </segment>
      </unit>
      <unit id="6579" name="warn_attribute_wrong_decl_type">
        <segment>
          <source state="initial">%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&amp;R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} only applies to {$arg2 :select s0=|functions| s1=|unions| s2=|variables and functions| s3=|functions and methods| s4=|functions, methods and blocks| s5=|functions, methods, and parameters| s6=|variables| s7=|variables and fields| s8=|variables, data members and tag types| s9=|types and namespaces| s10=|variables, functions and classes| s11=|kernel functions| s12=|non-K&amp;R-style functions| s13=|for loop statements| s14=|virtual functions| s15=|parameters and implicit object parameters| s16=|non-member functions| s17=|functions, classes, or enumerations| s18=|classes| s19=|typedefs|}</target>
        </segment>
      </unit>
      <unit id="6580" name="warn_attribute_wrong_decl_type_str">
        <segment>
          <source>%0%select{ attribute|}1 only applies to %2</source>
          <target>{$arg0}{$arg1 :select s0=| attribute| s1=||} only applies to {$arg2}</target>
        </segment>
      </unit>
      <unit id="6581" name="warn_attributes_likelihood_ifstmt_conflict">
        <segment>
          <source>conflicting attributes %0 are ignored</source>
          <target>conflicting attributes {$arg0} are ignored</target>
        </segment>
      </unit>
      <unit id="6582" name="warn_auto_implicit_atomic_property">
        <segment>
          <source>property is assumed atomic when auto-synthesizing the property</source>
          <target>property is assumed atomic when auto-synthesizing the property</target>
        </segment>
      </unit>
      <unit id="6583" name="warn_auto_readonly_iboutlet_property">
        <segment>
          <source>readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader</source>
          <target>readonly IBOutlet property {$arg0} when auto-synthesized may not work correctly with 'nib' loader</target>
        </segment>
      </unit>
      <unit id="6584" name="warn_auto_storage_class">
        <segment>
          <source>'auto' storage class specifier is redundant and incompatible with C++11</source>
          <target>'auto' storage class specifier is redundant and incompatible with C++11</target>
        </segment>
      </unit>
      <unit id="6585" name="warn_auto_synthesizing_protocol_property">
        <segment>
          <source>auto property synthesis will not synthesize property %0 declared in protocol %1</source>
          <target>auto property synthesis will not synthesize property {$arg0} declared in protocol {$arg1}</target>
        </segment>
      </unit>
      <unit id="6586" name="warn_auto_var_is_id">
        <segment>
          <source>'auto' deduced as 'id' in declaration of %0</source>
          <target>'auto' deduced as 'id' in declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6587" name="warn_autosynthesis_property_in_superclass">
        <segment>
          <source>auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention</source>
          <target>auto property synthesis will not synthesize property {$arg0}; it will be implemented by its superclass, use @dynamic to acknowledge intention</target>
        </segment>
      </unit>
      <unit id="6588" name="warn_autosynthesis_property_ivar_match">
        <segment>
          <source>autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3</source>
          <target>autosynthesized property {$arg0} will use {$arg1 :select s0=|| s1=|synthesized|} instance variable {$arg2}, not existing instance variable {$arg3}</target>
        </segment>
      </unit>
      <unit id="6589" name="warn_availability_fuchsia_unavailable_minor">
        <segment>
          <source>Fuchsia API Level prohibits specifying a minor or sub-minor version</source>
          <target>Fuchsia API Level prohibits specifying a minor or sub-minor version</target>
        </segment>
      </unit>
      <unit id="6590" name="warn_availability_on_static_initializer">
        <segment>
          <source>ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0</source>
          <target>ignoring availability attribute {$arg0 :select s0=|on '+load' method| s1=|with constructor attribute| s2=|with destructor attribute|}</target>
        </segment>
      </unit>
      <unit id="6591" name="warn_availability_swift_unavailable_deprecated_only">
        <segment>
          <source>only 'unavailable' and 'deprecated' are supported for Swift availability</source>
          <target>only 'unavailable' and 'deprecated' are supported for Swift availability</target>
        </segment>
      </unit>
      <unit id="6592" name="warn_availability_unknown_environment">
        <segment>
          <source>unknown environment %0 in availability macro</source>
          <target>unknown environment {$arg0} in availability macro</target>
        </segment>
      </unit>
      <unit id="6593" name="warn_availability_unknown_platform">
        <segment>
          <source>unknown platform %0 in availability macro</source>
          <target>unknown platform {$arg0} in availability macro</target>
        </segment>
      </unit>
      <unit id="6594" name="warn_availability_version_ordering">
        <segment>
          <source>feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored</source>
          <target>feature cannot be {$arg0 :select s0=|introduced| s1=|deprecated| s2=|obsoleted|} in {$arg1} version {$arg2} before it was {$arg3 :select s0=|introduced| s1=|deprecated| s2=|obsoleted|} in version {$arg4}; attribute ignored</target>
        </segment>
      </unit>
      <unit id="6595" name="warn_bad_cxx_cast_nested_pointer_addr_space">
        <segment>
          <source>%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers</source>
          <target>{$arg0 :select s0=|reinterpret_cast| s1=|C-style cast|} from {$arg1} to {$arg2} changes address space of nested pointers</target>
        </segment>
      </unit>
      <unit id="6596" name="warn_bad_function_cast">
        <segment>
          <source>cast from function call of type %0 to non-matching type %1</source>
          <target>cast from function call of type {$arg0} to non-matching type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6597" name="warn_bad_receiver_type">
        <segment>
          <source>receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'</source>
          <target>receiver type {$arg0} is not 'id' or interface pointer, consider casting it to 'id'</target>
        </segment>
      </unit>
      <unit id="6598" name="warn_base_class_is_uninit">
        <segment>
          <source>base class %0 is uninitialized when used here to access %q1</source>
          <target>base class {$arg0} is uninitialized when used here to access {$arg1 :q}</target>
        </segment>
      </unit>
      <unit id="6599" name="warn_bind_ref_member_to_parameter">
        <segment>
          <source>binding reference member %0 to stack allocated %select{variable|parameter}2 %1</source>
          <target>binding reference member {$arg0} to stack allocated {$arg2 :select s0=|variable| s1=|parameter|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="6600" name="warn_binding_null_to_reference">
        <segment>
          <source>binding dereferenced null pointer to reference has undefined behavior</source>
          <target>binding dereferenced null pointer to reference has undefined behavior</target>
        </segment>
      </unit>
      <unit id="6601" name="warn_bitfield_too_small_for_enum">
        <segment>
          <source>bit-field %0 is not wide enough to store all enumerators of %1</source>
          <target>bit-field {$arg0} is not wide enough to store all enumerators of {$arg1}</target>
        </segment>
      </unit>
      <unit id="6602" name="warn_bitfield_width_exceeds_type_width">
        <segment>
          <source>width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2</source>
          <target>width of bit-field {$arg0} ({$arg1} bits) exceeds the width of its type; value will be truncated to {$arg2} bit%s2</target>
        </segment>
      </unit>
      <unit id="6603" name="warn_bitwise_instead_of_logical">
        <segment>
          <source>use of bitwise '%0' with boolean operands</source>
          <target>use of bitwise '{$arg0}' with boolean operands</target>
        </segment>
      </unit>
      <unit id="6604" name="warn_bitwise_negation_bool">
        <segment>
          <source>bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?</source>
          <target>bitwise negation of a boolean expression{$arg0 :select s0=|;| s1=| always evaluates to 'true';|} did you mean logical negation?</target>
        </segment>
      </unit>
      <unit id="6605" name="warn_bitwise_op_in_bitwise_op">
        <segment>
          <source>'%0' within '%1'</source>
          <target>'{$arg0}' within '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6606" name="warn_block_capture_autoreleasing">
        <segment>
          <source>block captures an autoreleasing out-parameter, which may result in use-after-free bugs</source>
          <target>block captures an autoreleasing out-parameter, which may result in use-after-free bugs</target>
        </segment>
      </unit>
      <unit id="6607" name="warn_block_literal_attributes_on_omitted_return_type">
        <segment>
          <source>attribute %0 ignored, because it cannot be applied to omitted return type</source>
          <target>attribute {$arg0} ignored, because it cannot be applied to omitted return type</target>
        </segment>
      </unit>
      <unit id="6608" name="warn_block_literal_qualifiers_on_omitted_return_type">
        <segment>
          <source>'%0' qualifier on omitted return type %1 has no effect</source>
          <target>'{$arg0}' qualifier on omitted return type {$arg1} has no effect</target>
        </segment>
      </unit>
      <unit id="6609" name="warn_bool_switch_condition">
        <segment>
          <source>switch condition has boolean value</source>
          <target>switch condition has boolean value</target>
        </segment>
      </unit>
      <unit id="6610" name="warn_braces_around_init">
        <segment>
          <source>braces around %select{scalar |}0initializer</source>
          <target>braces around {$arg0 :select s0=|scalar | s1=||}initializer</target>
        </segment>
      </unit>
      <unit id="6611" name="warn_break_binds_to_switch">
        <segment>
          <source>'break' is bound to loop, GCC binds it to switch</source>
          <target>'break' is bound to loop, GCC binds it to switch</target>
        </segment>
      </unit>
      <unit id="6612" name="warn_builtin_chk_overflow">
        <segment>
          <source>'%0' will always overflow; destination buffer has size %1, but size argument is %2</source>
          <target>'{$arg0}' will always overflow; destination buffer has size {$arg1}, but size argument is {$arg2}</target>
        </segment>
      </unit>
      <unit id="6613" name="warn_builtin_unknown">
        <segment>
          <source>use of unknown builtin %0</source>
          <target>use of unknown builtin {$arg0}</target>
        </segment>
      </unit>
      <unit id="6614" name="warn_c2y_compat_alignof_incomplete_array">
        <segment>
          <source>'alignof' on an incomplete array type is incompatible with C standards before C2y</source>
          <target>'alignof' on an incomplete array type is incompatible with C standards before C2y</target>
        </segment>
      </unit>
      <unit id="6615" name="warn_c2y_compat_assoc_type_incomplete">
        <segment>
          <source>use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y</source>
          <target>use of incomplete type {$arg0} in a '_Generic' association is incompatible with C standards before C2y</target>
        </segment>
      </unit>
      <unit id="6616" name="warn_c2y_compat_increment_complex">
        <segment>
          <source>'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y</source>
          <target>'{$arg0 :select s0=|--| s1=|++|}' on an object of complex type is incompatible with C standards before C2y</target>
        </segment>
      </unit>
      <unit id="6617" name="warn_c17_compat_ellipsis_only_parameter">
        <segment>
          <source>'...' as the only parameter of a function is incompatible with C standards before C23</source>
          <target>'...' as the only parameter of a function is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="6618" name="warn_c17_compat_enum_value_not_int">
        <segment>
          <source>%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)</source>
          <target>{$arg0 :select s0=|| s1=|incremented |}enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 ({$arg1} is too {$arg2 :select s0=|small| s1=|large|})</target>
        </segment>
      </unit>
      <unit id="6619" name="warn_c17_compat_va_start_one_arg">
        <segment>
          <source>passing only one argument to 'va_start' is incompatible with C standards before C23</source>
          <target>passing only one argument to 'va_start' is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="6620" name="warn_c17_non_local_variable_decl_in_for">
        <segment>
          <source>declaration of non-local variable in 'for' loop is incompatible with C standards before C23</source>
          <target>declaration of non-local variable in 'for' loop is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="6621" name="warn_c17_non_variable_decl_in_for">
        <segment>
          <source>non-variable declaration in 'for' loop is incompatible with C standards before C23</source>
          <target>non-variable declaration in 'for' loop is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="6622" name="warn_c23_compat_imaginary_constant">
        <segment>
          <source>imaginary constants are incompatible with C standards before C2y</source>
          <target>imaginary constants are incompatible with C standards before C2y</target>
        </segment>
      </unit>
      <unit id="6623" name="warn_c23_compat_restrict_on_array_of_pointers">
        <segment>
          <source>'restrict' qualifier on an array of pointers is incompatible with C standards before C23</source>
          <target>'restrict' qualifier on an array of pointers is incompatible with C standards before C23</target>
        </segment>
      </unit>
      <unit id="6624" name="warn_c23_compat_utf8_string">
        <segment>
          <source>type of UTF-8 string literal will change from array of char to array of char8_t in C23</source>
          <target>type of UTF-8 string literal will change from array of char to array of char8_t in C23</target>
        </segment>
      </unit>
      <unit id="6625" name="warn_call_to_pure_virtual_member_function_from_ctor_dtor">
        <segment>
          <source>call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2</source>
          <target>call to pure virtual member function {$arg0} has undefined behavior; overrides of {$arg0} in subclasses are not available in the {$arg1 :select s0=|constructor| s1=|destructor|} of {$arg2}</target>
        </segment>
      </unit>
      <unit id="6626" name="warn_call_wrong_number_of_arguments">
        <segment>
          <source>too %select{few|many}0 arguments in call to %1</source>
          <target>too {$arg0 :select s0=|few| s1=|many|} arguments in call to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6627" name="warn_called_once_gets_called_twice">
        <segment>
          <source>%0 parameter marked 'called_once' is called twice</source>
          <target>{$arg0} parameter marked 'called_once' is called twice</target>
        </segment>
      </unit>
      <unit id="6628" name="warn_called_once_never_called">
        <segment>
          <source>%select{|captured }1%0 parameter marked 'called_once' is never called</source>
          <target>{$arg1 :select s0=|| s1=|captured |}{$arg0} parameter marked 'called_once' is never called</target>
        </segment>
      </unit>
      <unit id="6629" name="warn_called_once_never_called_when">
        <segment>
          <source>%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2</source>
          <target>{$arg0} parameter marked 'called_once' is never {$arg1 :select s0=|used| s1=|called|} when {$arg2 :select s0=|taking true branch| s1=|taking false branch| s2=|handling this case| s3=|none of the cases applies| s4=|entering the loop| s5=|skipping the loop| s6=|taking one of the branches|}</target>
        </segment>
      </unit>
      <unit id="6630" name="warn_cannot_pass_non_pod_arg_to_vararg">
        <segment>
          <source>cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime</source>
          <target>cannot pass object of {$arg0 :select s0=|non-POD| s1=|non-trivial|} type {$arg1} through variadic {$arg2 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}; call will abort at runtime</target>
        </segment>
      </unit>
      <unit id="6631" name="warn_cannot_resolve_lock">
        <segment>
          <source>cannot resolve lock expression</source>
          <target>cannot resolve lock expression</target>
        </segment>
      </unit>
      <unit id="6632" name="warn_case_empty_range">
        <segment>
          <source>empty case range specified</source>
          <target>empty case range specified</target>
        </segment>
      </unit>
      <unit id="6633" name="warn_case_value_overflow">
        <segment>
          <source>overflow converting case value to switch condition type (%0 to %1)</source>
          <target>overflow converting case value to switch condition type ({$arg0} to {$arg1})</target>
        </segment>
      </unit>
      <unit id="6634" name="warn_cast_align">
        <segment>
          <source>cast from %0 to %1 increases required alignment from %2 to %3</source>
          <target>cast from {$arg0} to {$arg1} increases required alignment from {$arg2} to {$arg3}</target>
        </segment>
      </unit>
      <unit id="6635" name="warn_cast_calling_conv">
        <segment>
          <source>cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime</source>
          <target>cast between incompatible calling conventions '{$arg0}' and '{$arg1}'; calls through this pointer may abort at runtime</target>
        </segment>
      </unit>
      <unit id="6636" name="warn_cast_function_type">
        <segment>
          <source>cast %diff{from $ to $ |}0,1converts to incompatible function type</source>
          <target>cast %diff{from $ to $ |}0,1converts to incompatible function type</target>
        </segment>
      </unit>
      <unit id="6637" name="warn_cast_function_type_strict">
        <segment>
          <source>cast %diff{from $ to $ |}0,1converts to incompatible function type</source>
          <target>cast %diff{from $ to $ |}0,1converts to incompatible function type</target>
        </segment>
      </unit>
      <unit id="6638" name="warn_cast_nonnull_to_bool">
        <segment>
          <source>nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter</source>
          <target>nonnull {$arg0 :select s0=|function call| s1=|parameter|} '{$arg1}' will evaluate to 'true' on first encounter</target>
        </segment>
      </unit>
      <unit id="6639" name="warn_cast_pointer_from_sel">
        <segment>
          <source>cast of type %0 to %1 is deprecated; use sel_getName instead</source>
          <target>cast of type {$arg0} to {$arg1} is deprecated; use sel_getName instead</target>
        </segment>
      </unit>
      <unit id="6640" name="warn_cast_qual">
        <segment>
          <source>cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2</source>
          <target>cast from {$arg0} to {$arg1} drops {$arg2 :select s0=|const and volatile qualifiers| s1=|const qualifier| s2=|volatile qualifier|}</target>
        </segment>
      </unit>
      <unit id="6641" name="warn_cast_qual2">
        <segment>
          <source>cast from %0 to %1 must have all intermediate pointers const qualified to be safe</source>
          <target>cast from {$arg0} to {$arg1} must have all intermediate pointers const qualified to be safe</target>
        </segment>
      </unit>
      <unit id="6642" name="warn_category_method_impl_match">
        <segment>
          <source>category is implementing a method which will also be implemented by its primary class</source>
          <target>category is implementing a method which will also be implemented by its primary class</target>
        </segment>
      </unit>
      <unit id="6643" name="warn_cconv_knr">
        <segment>
          <source>function with no prototype cannot use the %0 calling convention</source>
          <target>function with no prototype cannot use the {$arg0} calling convention</target>
        </segment>
      </unit>
      <unit id="6644" name="warn_cconv_unsupported">
        <segment>
          <source>%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1</source>
          <target>{$arg0} calling convention is not supported {$arg1 :select s0=|for this target| s1=|on variadic function| s2=|on constructor/destructor| s3=|on builtin function|}</target>
        </segment>
      </unit>
      <unit id="6645" name="warn_cdtor_function_try_handler_mem_expr">
        <segment>
          <source>cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block</source>
          <target>cannot refer to a non-static member from the handler of a {$arg0 :select s0=|constructor| s1=|destructor|} function try block</target>
        </segment>
      </unit>
      <unit id="6646" name="warn_cfstring_truncated">
        <segment>
          <source>input conversion stopped due to an input byte that does not belong to the input codeset UTF-8</source>
          <target>input conversion stopped due to an input byte that does not belong to the input codeset UTF-8</target>
        </segment>
      </unit>
      <unit id="6647" name="warn_class_method_not_found">
        <segment>
          <source>class method %objcclass0 not found (return type defaults to 'id')</source>
          <target>class method %objcclass0 not found (return type defaults to 'id')</target>
        </segment>
      </unit>
      <unit id="6648" name="warn_class_method_not_found_with_typo">
        <segment>
          <source>class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?</source>
          <target>class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?</target>
        </segment>
      </unit>
      <unit id="6649" name="warn_cleanup_ext">
        <segment>
          <source>GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier</source>
          <target>GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier</target>
        </segment>
      </unit>
      <unit id="6650" name="warn_cmse_nonsecure_union">
        <segment>
          <source>passing union across security boundary via %select{parameter %1|return value}0 may leak information</source>
          <target>passing union across security boundary via {$arg0 :select s0=|parameter {$arg1}| s1=|return value|} may leak information</target>
        </segment>
      </unit>
      <unit id="6651" name="warn_cocoa_naming_owned_rule">
        <segment>
          <source>property follows Cocoa naming convention for returning 'owned' objects</source>
          <target>property follows Cocoa naming convention for returning 'owned' objects</target>
        </segment>
      </unit>
      <unit id="6652" name="warn_collection_expr_type">
        <segment>
          <source>collection expression type %0 may not respond to %1</source>
          <target>collection expression type {$arg0} may not respond to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6653" name="warn_comma_operator">
        <segment>
          <source>possible misuse of comma operator here</source>
          <target>possible misuse of comma operator here</target>
        </segment>
      </unit>
      <unit id="6654" name="warn_comparison_always">
        <segment>
          <source state="initial">%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1</source>
          <target>{$arg0 :select s0=|self-| s1=|array | s2=|pointer |}comparison always evaluates to {$arg1 :select s0=|a constant| s1=|true| s2=|false| s3=|'std::strong_ordering::equal'|}</target>
        </segment>
      </unit>
      <unit id="6655" name="warn_comparison_bitwise_always">
        <segment>
          <source>bitwise comparison always evaluates to %select{false|true}0</source>
          <target>bitwise comparison always evaluates to {$arg0 :select s0=|false| s1=|true|}</target>
        </segment>
      </unit>
      <unit id="6656" name="warn_comparison_bitwise_or">
        <segment>
          <source>bitwise or with non-zero value always evaluates to true</source>
          <target>bitwise or with non-zero value always evaluates to true</target>
        </segment>
      </unit>
      <unit id="6657" name="warn_comparison_in_fold_expression">
        <segment>
          <source>comparison in fold expression would evaluate to '(X %0 Y) %0 Z' which does not behave the same as a mathematical expression</source>
          <target>comparison in fold expression would evaluate to '(X {$arg0} Y) {$arg0} Z' which does not behave the same as a mathematical expression</target>
        </segment>
      </unit>
      <unit id="6658" name="warn_comparison_mixed_enum_types">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6659" name="warn_comparison_mixed_enum_types_cxx20">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2 is deprecated</target>
        </segment>
      </unit>
      <unit id="6660" name="warn_comparison_of_mixed_enum_types_switch">
        <segment>
          <source>comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1</source>
          <target>comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1</target>
        </segment>
      </unit>
      <unit id="6661" name="warn_comparison_unicode_mixed_types">
        <segment>
          <source>comparing values of different Unicode code unit types %0 and %1 may compare different code points</source>
          <target>comparing values of different Unicode code unit types {$arg0} and {$arg1} may compare different code points</target>
        </segment>
      </unit>
      <unit id="6662" name="warn_comparison_unicode_mixed_types_constant">
        <segment>
          <source>comparing values of different Unicode code unit types %0 and %1 compares unrelated code units '%2' and '%3'</source>
          <target>comparing values of different Unicode code unit types {$arg0} and {$arg1} compares unrelated code units '{$arg2}' and '{$arg3}'</target>
        </segment>
      </unit>
      <unit id="6663" name="warn_compatible_implicit_pointer_conv">
        <segment>
          <source>implicit conversion when %select{%diff{assigning to $ from type $|assigning to type from type}0,1|%diff{passing $ to parameter of type $|passing type to parameter of type}0,1|%diff{returning $ from a function with result type $|returning type from a function with result type}0,1|&lt;CLANG BUG IF YOU SEE THIS&gt;|%diff{initializing $ with an expression of type $|initializing type with an expression of type}0,1|%diff{sending $ to parameter of type $|sending type to parameter of type}0,1|&lt;CLANG BUG IF YOU SEE THIS&gt;}2 is not permitted in C++</source>
          <target>implicit conversion when %select{%diff{assigning to $ from type $|assigning to type from type}0,1|%diff{passing $ to parameter of type $|passing type to parameter of type}0,1|%diff{returning $ from a function with result type $|returning type from a function with result type}0,1|&lt;CLANG BUG IF YOU SEE THIS&gt;|%diff{initializing $ with an expression of type $|initializing type with an expression of type}0,1|%diff{sending $ to parameter of type $|sending type to parameter of type}0,1|&lt;CLANG BUG IF YOU SEE THIS&gt;}2 is not permitted in C++</target>
        </segment>
      </unit>
      <unit id="6664" name="warn_completion_handler_called_twice">
        <segment>
          <source>completion handler is called twice</source>
          <target>completion handler is called twice</target>
        </segment>
      </unit>
      <unit id="6665" name="warn_completion_handler_never_called">
        <segment>
          <source>%select{|captured }1completion handler is never called</source>
          <target>{$arg1 :select s0=|| s1=|captured |}completion handler is never called</target>
        </segment>
      </unit>
      <unit id="6666" name="warn_completion_handler_never_called_when">
        <segment>
          <source>completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2</source>
          <target>completion handler is never {$arg1 :select s0=|used| s1=|called|} when {$arg2 :select s0=|taking true branch| s1=|taking false branch| s2=|handling this case| s3=|none of the cases applies| s4=|entering the loop| s5=|skipping the loop| s6=|taking one of the branches|}</target>
        </segment>
      </unit>
      <unit id="6667" name="warn_concatenated_literal_array_init">
        <segment>
          <source>suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?</source>
          <target>suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?</target>
        </segment>
      </unit>
      <unit id="6668" name="warn_concatenated_nsarray_literal">
        <segment>
          <source>concatenated NSString literal for an NSArray expression - possibly missing a comma</source>
          <target>concatenated NSString literal for an NSArray expression - possibly missing a comma</target>
        </segment>
      </unit>
      <unit id="6669" name="warn_condition_is_assignment">
        <segment>
          <source>using the result of an assignment as a condition without parentheses</source>
          <target>using the result of an assignment as a condition without parentheses</target>
        </segment>
      </unit>
      <unit id="6670" name="warn_condition_is_idiomatic_assignment">
        <segment>
          <source>using the result of an assignment as a condition without parentheses</source>
          <target>using the result of an assignment as a condition without parentheses</target>
        </segment>
      </unit>
      <unit id="6671" name="warn_conditional_mixed_enum_types">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6672" name="warn_conditional_mixed_enum_types_cxx20">
        <segment>
          <source>%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated</source>
          <target>{$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2 is deprecated</target>
        </segment>
      </unit>
      <unit id="6673" name="warn_conflicting_func_effects">
        <segment>
          <source>effects conflict when merging declarations; kept '%0', discarded '%1'</source>
          <target>effects conflict when merging declarations; kept '{$arg0}', discarded '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6674" name="warn_conflicting_overriding_param_modifiers">
        <segment>
          <source>conflicting distributed object modifiers on parameter type in declaration of %0</source>
          <target>conflicting distributed object modifiers on parameter type in declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6675" name="warn_conflicting_overriding_param_types">
        <segment>
          <source>conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2</source>
          <target>conflicting parameter types in declaration of {$arg0}%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="6676" name="warn_conflicting_overriding_ret_type_modifiers">
        <segment>
          <source>conflicting distributed object modifiers on return type in declaration of %0</source>
          <target>conflicting distributed object modifiers on return type in declaration of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6677" name="warn_conflicting_overriding_ret_types">
        <segment>
          <source>conflicting return type in declaration of %0%diff{: $ vs $|}1,2</source>
          <target>conflicting return type in declaration of {$arg0}%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="6678" name="warn_conflicting_overriding_variadic">
        <segment>
          <source>conflicting variadic declaration of method and its implementation</source>
          <target>conflicting variadic declaration of method and its implementation</target>
        </segment>
      </unit>
      <unit id="6679" name="warn_conflicting_param_modifiers">
        <segment>
          <source>conflicting distributed object modifiers on parameter type in implementation of %0</source>
          <target>conflicting distributed object modifiers on parameter type in implementation of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6680" name="warn_conflicting_param_types">
        <segment>
          <source>conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2</source>
          <target>conflicting parameter types in implementation of {$arg0}%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="6681" name="warn_conflicting_ret_type_modifiers">
        <segment>
          <source>conflicting distributed object modifiers on return type in implementation of %0</source>
          <target>conflicting distributed object modifiers on return type in implementation of {$arg0}</target>
        </segment>
      </unit>
      <unit id="6682" name="warn_conflicting_ret_types">
        <segment>
          <source>conflicting return type in implementation of %0%diff{: $ vs $|}1,2</source>
          <target>conflicting return type in implementation of {$arg0}%diff{: $ vs $|}1,2</target>
        </segment>
      </unit>
      <unit id="6683" name="warn_conflicting_variadic">
        <segment>
          <source>conflicting variadic declaration of method and its implementation</source>
          <target>conflicting variadic declaration of method and its implementation</target>
        </segment>
      </unit>
      <unit id="6684" name="warn_consecutive_comparison">
        <segment>
          <source state="initial">chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression</source>
          <target>chained comparison 'X {$arg0} Y {$arg1} Z' does not behave the same as a mathematical expression</target>
        </segment>
      </unit>
      <unit id="6685" name="warn_const_attr_with_pure_attr">
        <segment>
          <source>'const' attribute imposes more restrictions; 'pure' attribute ignored</source>
          <target>'const' attribute imposes more restrictions; 'pure' attribute ignored</target>
        </segment>
      </unit>
      <unit id="6686" name="warn_consteval_if_always_true">
        <segment>
          <source>consteval if is always true in an %select{unevaluated|immediate}0 context</source>
          <target>consteval if is always true in an {$arg0 :select s0=|unevaluated| s1=|immediate|} context</target>
        </segment>
      </unit>
      <unit id="6687" name="warn_conv_mixed_enum_types_cxx26">
        <segment>
          <source>invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2</source>
          <target>invalid {$arg0 :select s0=|arithmetic between| s1=|bitwise operation between| s2=|comparison of| s3=|conditional expression between| s4=|compound assignment of|} different enumeration types%diff{ ($ and $)|}1,2</target>
        </segment>
      </unit>
      <unit id="6688" name="warn_conv_to_base_not_used">
        <segment>
          <source>conversion function converting %0 to its base class %1 will never be used</source>
          <target>conversion function converting {$arg0} to its base class {$arg1} will never be used</target>
        </segment>
      </unit>
      <unit id="6689" name="warn_conv_to_self_not_used">
        <segment>
          <source>conversion function converting %0 to itself will never be used</source>
          <target>conversion function converting {$arg0} to itself will never be used</target>
        </segment>
      </unit>
      <unit id="6690" name="warn_conv_to_void_not_used">
        <segment>
          <source>conversion function converting %0 to %1 will never be used</source>
          <target>conversion function converting {$arg0} to {$arg1} will never be used</target>
        </segment>
      </unit>
      <unit id="6691" name="warn_coroutine_handle_address_invalid_return_type">
        <segment>
          <source>return type of 'coroutine_handle&lt;&gt;::address should be 'void*' (have %0) in order to get capability with existing async C API</source>
          <target>return type of 'coroutine_handle&lt;&gt;::address should be 'void*' (have {$arg0}) in order to get capability with existing async C API</target>
        </segment>
      </unit>
      <unit id="6692" name="warn_coroutine_promise_unhandled_exception_required_with_exceptions">
        <segment>
          <source>%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled</source>
          <target>{$arg0} is required to declare the member 'unhandled_exception()' when exceptions are enabled</target>
        </segment>
      </unit>
      <unit id="6693" name="warn_coroutine_type_aware_allocator_ignored">
        <segment>
          <source>type aware %0 will not be used for coroutine allocation</source>
          <target>type aware {$arg0} will not be used for coroutine allocation</target>
        </segment>
      </unit>
      <unit id="6694" name="warn_counted_by_attr_elt_type_unknown_size">
        <segment>
          <source>'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2</source>
          <target>'{$arg4 :select s0=|counted_by| s1=|sized_by| s2=|counted_by_or_null| s3=|sized_by_or_null|}' {$arg3 :select s0=|cannot| s1=|should not|} be applied to {$arg0 :select s0=|a pointer with pointee| s1=|an array with element|} of unknown size because {$arg1} is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member{$arg2 :select s0=|| s1=|. This will be an error in a future compiler version}3|}</target>
        </segment>
      </unit>
      <unit id="6695" name="warn_cpp_compat_goto_into_protected_scope">
        <segment>
          <source>jump from this goto statement to its label is incompatible with C++</source>
          <target>jump from this goto statement to its label is incompatible with C++</target>
        </segment>
      </unit>
      <unit id="6696" name="warn_cpp_compat_indirect_goto_in_protected_scope">
        <segment>
          <source>jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++</source>
          <target>jump from this {$arg0 :select s0=|indirect| s1=|asm|} goto statement to one of its possible targets is incompatible with C++</target>
        </segment>
      </unit>
      <unit id="6697" name="warn_cpp_compat_switch_into_protected_scope">
        <segment>
          <source>jump from switch statement to this case label is incompatible with C++</source>
          <target>jump from switch statement to this case label is incompatible with C++</target>
        </segment>
      </unit>
      <unit id="6698" name="warn_cstruct_memaccess">
        <segment>
          <source>%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3</source>
          <target>{$arg0 :select s0=|destination for| s1=|source of| s2=|first operand of| s3=|second operand of|} this {$arg1} call is a pointer to record {$arg2} that is not trivial to {$arg3 :select s0=|primitive-default-initialize| s1=|primitive-copy|}</target>
        </segment>
      </unit>
      <unit id="6699" name="warn_ctad_maybe_unsupported">
        <segment>
          <source>%0 may not intend to support class template argument deduction</source>
          <target>{$arg0} may not intend to support class template argument deduction</target>
        </segment>
      </unit>
      <unit id="6700" name="warn_ctor_parm_shadows_field">
        <segment>
          <source>constructor parameter %0 shadows the field %1 of %2</source>
          <target>constructor parameter {$arg0} shadows the field {$arg1} of {$arg2}</target>
        </segment>
      </unit>
      <unit id="6701" name="warn_cuda_maxclusterrank_sm_90">
        <segment>
          <source>maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute</source>
          <target>maxclusterrank requires sm_90 or higher, CUDA arch provided: {$arg0}, ignoring {$arg1} attribute</target>
        </segment>
      </unit>
      <unit id="6702" name="warn_cxx11_compat_constexpr_body_no_return">
        <segment>
          <source>constexpr function with no return statements is incompatible with C++ standards before C++14</source>
          <target>constexpr function with no return statements is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="6703" name="warn_cxx11_compat_deduced_return_type">
        <segment>
          <source>return type deduction is incompatible with C++ standards before C++14</source>
          <target>return type deduction is incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="6704" name="warn_cxx11_compat_generic_lambda">
        <segment>
          <source>generic lambdas are incompatible with C++11</source>
          <target>generic lambdas are incompatible with C++11</target>
        </segment>
      </unit>
      <unit id="6705" name="warn_cxx11_compat_init_capture">
        <segment>
          <source>initialized lambda captures are incompatible with C++ standards before C++14</source>
          <target>initialized lambda captures are incompatible with C++ standards before C++14</target>
        </segment>
      </unit>
      <unit id="6706" name="warn_cxx11_gnu_attribute_on_type">
        <segment>
          <source>attribute %0 ignored, because it cannot be applied to a type</source>
          <target>attribute {$arg0} ignored, because it cannot be applied to a type</target>
        </segment>
      </unit>
      <unit id="6707" name="warn_cxx14_compat_class_template_argument_deduction">
        <segment>
          <source>class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0</source>
          <target>class template argument deduction is incompatible with C++ standards before C++17{$arg0 :select s0=|| s1=|; for compatibility, use explicit type name {$arg1}|}</target>
        </segment>
      </unit>
      <unit id="6708" name="warn_cxx14_compat_constexpr_not_const">
        <segment>
          <source>'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior</source>
          <target>'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior</target>
        </segment>
      </unit>
      <unit id="6709" name="warn_cxx14_compat_star_this_lambda_capture">
        <segment>
          <source>by value capture of '*this' is incompatible with C++ standards before C++17</source>
          <target>by value capture of '*this' is incompatible with C++ standards before C++17</target>
        </segment>
      </unit>
      <unit id="6710" name="warn_cxx14_compat_template_nontype_parm_auto_type">
        <segment>
          <source>non-type template parameters declared with %0 are incompatible with C++ standards before C++17</source>
          <target>non-type template parameters declared with {$arg0} are incompatible with C++ standards before C++17</target>
        </segment>
      </unit>
      <unit id="6711" name="warn_cxx17_compat_aggregate_init_paren_list">
        <segment>
          <source>aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension</source>
          <target>aggregate initialization of type {$arg0} from a parenthesized list of values is a C++20 extension</target>
        </segment>
      </unit>
      <unit id="6712" name="warn_cxx17_compat_capture_binding">
        <segment>
          <source>captured structured bindings are incompatible with C++ standards before C++20</source>
          <target>captured structured bindings are incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6713" name="warn_cxx17_compat_constexpr_virtual">
        <segment>
          <source>virtual constexpr functions are incompatible with C++ standards before C++20</source>
          <target>virtual constexpr functions are incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6714" name="warn_cxx17_compat_defaulted_comparison">
        <segment>
          <source>defaulted comparison operators are incompatible with C++ standards before C++20</source>
          <target>defaulted comparison operators are incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6715" name="warn_cxx17_compat_defaulted_method_type_mismatch">
        <segment>
          <source>explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20</source>
          <target>explicitly defaulting this {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} with a type different from the implicit type is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6716" name="warn_cxx17_compat_designated_init">
        <segment>
          <source>designated initializers are incompatible with C++ standards before C++20</source>
          <target>designated initializers are incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6717" name="warn_cxx17_compat_equals_this_lambda_capture">
        <segment>
          <source>explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20</source>
          <target>explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6718" name="warn_cxx17_compat_exception_spec_in_signature">
        <segment>
          <source>mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature</source>
          <target>mangled name of {$arg0} will change in C++17 due to non-throwing exception specification in function signature</target>
        </segment>
      </unit>
      <unit id="6719" name="warn_cxx17_compat_init_capture_pack">
        <segment>
          <source>initialized lambda capture packs are incompatible with C++ standards before C++20</source>
          <target>initialized lambda capture packs are incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6720" name="warn_cxx17_compat_lambda_def_ctor_assign">
        <segment>
          <source>%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20</source>
          <target>{$arg0 :select s0=|default construction| s1=|assignment|} of lambda is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6721" name="warn_cxx17_compat_pointer_to_const_ref_member_on_rvalue">
        <segment>
          <source>invoking a pointer to a 'const &amp;' member function on an rvalue is incompatible with C++ standards before C++20</source>
          <target>invoking a pointer to a 'const &amp;' member function on an rvalue is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6722" name="warn_cxx17_compat_template_nontype_parm_type">
        <segment>
          <source>non-type template parameter of type %0 is incompatible with C++ standards before C++20</source>
          <target>non-type template parameter of type {$arg0} is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6723" name="warn_cxx17_compat_unicode_type">
        <segment>
          <source>'char8_t' type specifier is incompatible with C++ standards before C++20</source>
          <target>'char8_t' type specifier is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6724" name="warn_cxx17_compat_using_decl_class_member_enumerator">
        <segment>
          <source>member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20</source>
          <target>member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6725" name="warn_cxx17_compat_using_decl_non_member_enumerator">
        <segment>
          <source>member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20</source>
          <target>member using declaration naming non-class '{$arg0}' enumerator is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6726" name="warn_cxx17_compat_using_decl_scoped_enumerator">
        <segment>
          <source>using declaration naming a scoped enumerator is incompatible with C++ standards before C++20</source>
          <target>using declaration naming a scoped enumerator is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6727" name="warn_cxx20_compat_aggregate_init_with_ctors">
        <segment>
          <source>aggregate initialization of type %0 with user-declared constructors is incompatible with C++20</source>
          <target>aggregate initialization of type {$arg0} with user-declared constructors is incompatible with C++20</target>
        </segment>
      </unit>
      <unit id="6728" name="warn_cxx20_compat_auto_expr">
        <segment>
          <source>'auto' as a functional-style cast is incompatible with C++ standards before C++23</source>
          <target>'auto' as a functional-style cast is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="6729" name="warn_cxx20_compat_constexpr_var">
        <segment>
          <source state="initial">definition of a variable of non-literal type in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23</source>
          <target>definition of a variable of non-literal type in a constexpr {$arg0 :select s0=|function| s1=|constructor|} is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="6730" name="warn_cxx20_compat_constinit">
        <segment>
          <source>'constinit' specifier is incompatible with C++ standards before C++20</source>
          <target>'constinit' specifier is incompatible with C++ standards before C++20</target>
        </segment>
      </unit>
      <unit id="6731" name="warn_cxx20_compat_operator_overload_static">
        <segment>
          <source>declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23</source>
          <target>declaring overloaded {$arg0} as 'static' is incompatible with C++ standards before C++23</target>
        </segment>
      </unit>
      <unit id="6732" name="warn_cxx20_compat_use_of_unaddressable_function">
        <segment>
          <source>taking address of non-addressable standard library function is incompatible with C++20</source>
          <target>taking address of non-addressable standard library function is incompatible with C++20</target>
        </segment>
      </unit>
      <unit id="6733" name="warn_cxx20_compat_utf8_string">
        <segment>
          <source>type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20</source>
          <target>type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20</target>
        </segment>
      </unit>
      <unit id="6734" name="warn_cxx23_pack_indexing">
        <segment>
          <source>pack indexing is incompatible with C++ standards before C++2c</source>
          <target>pack indexing is incompatible with C++ standards before C++2c</target>
        </segment>
      </unit>
      <unit id="6735" name="warn_cxx23_placeholder_var_definition">
        <segment>
          <source>placeholder variables are incompatible with C++ standards before C++2c</source>
          <target>placeholder variables are incompatible with C++ standards before C++2c</target>
        </segment>
      </unit>
      <unit id="6736" name="warn_cxx26_type_aware_allocators">
        <segment>
          <source>type aware allocators are incompatible with C++ standards before C++2c</source>
          <target>type aware allocators are incompatible with C++ standards before C++2c</target>
        </segment>
      </unit>
      <unit id="6737" name="warn_cxx98_compat_array_size_conversion">
        <segment>
          <source>implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98</source>
          <target>implicit conversion from array size expression of type {$arg0} to {$arg1 :select s0=|integral| s1=|enumeration|} type {$arg2} is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6738" name="warn_cxx98_compat_auto_type_specifier">
        <segment>
          <source>'auto' type specifier is incompatible with C++98</source>
          <target>'auto' type specifier is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6739" name="warn_cxx98_compat_cast_fn_obj">
        <segment>
          <source>cast between pointer-to-function and pointer-to-object is incompatible with C++98</source>
          <target>cast between pointer-to-function and pointer-to-object is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6740" name="warn_cxx98_compat_constexpr">
        <segment>
          <source>'constexpr' specifier is incompatible with C++98</source>
          <target>'constexpr' specifier is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6741" name="warn_cxx98_compat_ctor_list_init">
        <segment>
          <source>constructor call from initializer list is incompatible with C++98</source>
          <target>constructor call from initializer list is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6742" name="warn_cxx98_compat_delegating_ctor">
        <segment>
          <source>delegating constructors are incompatible with C++98</source>
          <target>delegating constructors are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6743" name="warn_cxx98_compat_empty_scalar_initializer">
        <segment>
          <source>scalar initialized from empty initializer list is incompatible with C++98</source>
          <target>scalar initialized from empty initializer list is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6744" name="warn_cxx98_compat_empty_sizeless_initializer">
        <segment>
          <source>initializing %0 from an empty initializer list is incompatible with C++98</source>
          <target>initializing {$arg0} from an empty initializer list is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6745" name="warn_cxx98_compat_enum_nested_name_spec">
        <segment>
          <source>enumeration type in nested name specifier is incompatible with C++98</source>
          <target>enumeration type in nested name specifier is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6746" name="warn_cxx98_compat_explicit_conversion_functions">
        <segment>
          <source>explicit conversion functions are incompatible with C++98</source>
          <target>explicit conversion functions are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6747" name="warn_cxx98_compat_friend_is_member">
        <segment>
          <source>friend declaration naming a member of the declaring class is incompatible with C++98</source>
          <target>friend declaration naming a member of the declaring class is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6748" name="warn_cxx98_compat_goto_into_protected_scope">
        <segment>
          <source>jump from this goto statement to its label is incompatible with C++98</source>
          <target>jump from this goto statement to its label is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6749" name="warn_cxx98_compat_indirect_goto_in_protected_scope">
        <segment>
          <source>jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98</source>
          <target>jump from this {$arg0 :select s0=|indirect| s1=|asm|} goto statement to one of its possible targets is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6750" name="warn_cxx98_compat_initializer_list_init">
        <segment>
          <source>initialization of initializer_list object is incompatible with C++98</source>
          <target>initialization of initializer_list object is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6751" name="warn_cxx98_compat_non_static_member_use">
        <segment>
          <source>use of non-static data member %0 in an unevaluated context is incompatible with C++98</source>
          <target>use of non-static data member {$arg0} in an unevaluated context is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6752" name="warn_cxx98_compat_nontrivial_union_or_anon_struct_member">
        <segment>
          <source>%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98</source>
          <target>{$arg0 :select s0=|anonymous struct| s1=|union|} member {$arg1} with a non-trivial {$arg2 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6753" name="warn_cxx98_compat_pass_non_pod_arg_to_vararg">
        <segment>
          <source>passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98</source>
          <target>passing object of trivial but non-POD type {$arg0} through variadic {$arg1 :select s0=|function| s1=|block| s2=|method| s3=|constructor|} is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6754" name="warn_cxx98_compat_reference_list_init">
        <segment>
          <source>reference initialized from initializer list is incompatible with C++98</source>
          <target>reference initialized from initializer list is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6755" name="warn_cxx98_compat_sfinae_access_control">
        <segment>
          <source>substitution failure due to access control is incompatible with C++98</source>
          <target>substitution failure due to access control is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6756" name="warn_cxx98_compat_switch_into_protected_scope">
        <segment>
          <source>jump from switch statement to this case label is incompatible with C++98</source>
          <target>jump from switch statement to this case label is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6757" name="warn_cxx98_compat_temp_copy">
        <segment>
          <source>%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98</source>
          <target>{$arg1 :select s0=|copying variable| s1=|copying parameter| s2=|initializing template parameter| s3=|returning object| s4=|initializing statement expression result| s5=|throwing object| s6=|copying member subobject| s7=|copying array element| s8=|allocating object| s9=|copying temporary| s10=|initializing base subobject| s11=|initializing vector element| s12=|capturing value|} of type {$arg2} when binding a reference to a temporary would {$arg0 :select s0=|invoke an inaccessible constructor| s1=|find no viable constructor| s2=|find ambiguous constructors| s3=|invoke a deleted constructor|} in C++98</target>
        </segment>
      </unit>
      <unit id="6758" name="warn_cxx98_compat_template_arg_local_type">
        <segment>
          <source>local type %0 as template argument is incompatible with C++98</source>
          <target>local type {$arg0} as template argument is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6759" name="warn_cxx98_compat_template_arg_null">
        <segment>
          <source>use of null pointer as non-type template argument is incompatible with C++98</source>
          <target>use of null pointer as non-type template argument is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6760" name="warn_cxx98_compat_template_arg_object_internal">
        <segment>
          <source>non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98</source>
          <target>non-type template argument referring to {$arg0 :select s0=|function| s1=|object|} {$arg1} with internal linkage is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6761" name="warn_cxx98_compat_template_arg_unnamed_type">
        <segment>
          <source>unnamed type as template argument is incompatible with C++98</source>
          <target>unnamed type as template argument is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6762" name="warn_cxx98_compat_template_outside_of_template">
        <segment>
          <source>use of 'template' keyword outside of a template is incompatible with C++98</source>
          <target>use of 'template' keyword outside of a template is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6763" name="warn_cxx98_compat_unelaborated_friend_type">
        <segment>
          <source>befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98</source>
          <target>befriending {$arg1} without '{$arg0 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|}' keyword is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6764" name="warn_cxx98_compat_unicode_type">
        <segment>
          <source>'%0' type specifier is incompatible with C++98</source>
          <target>'{$arg0}' type specifier is incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6765" name="warn_cxx98_compat_using_decl_constructor">
        <segment>
          <source>inheriting constructors are incompatible with C++98</source>
          <target>inheriting constructors are incompatible with C++98</target>
        </segment>
      </unit>
      <unit id="6766" name="warn_cxx_compat_hack_fake_diagnostic_do_not_emit">
        <segment>
          <source>if you see this diagnostic, a Clang developer has made a mistake</source>
          <target>if you see this diagnostic, a Clang developer has made a mistake</target>
        </segment>
      </unit>
      <unit id="6767" name="warn_cxx_compat_tentative_definition">
        <segment>
          <source>duplicate declaration of %0 is invalid in C++</source>
          <target>duplicate declaration of {$arg0} is invalid in C++</target>
        </segment>
      </unit>
      <unit id="6768" name="warn_cxx_ms_struct">
        <segment>
          <source>ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions</source>
          <target>ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions</target>
        </segment>
      </unit>
      <unit id="6769" name="warn_cxxstruct_memaccess">
        <segment>
          <source>first argument in call to %0 is a pointer to non-trivially copyable type %1</source>
          <target>first argument in call to {$arg0} is a pointer to non-trivially copyable type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6770" name="warn_dangling_lifetime_pointer">
        <segment>
          <source>object backing the pointer will be destroyed at the end of the full-expression</source>
          <target>object backing the pointer will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6771" name="warn_dangling_lifetime_pointer_assignment">
        <segment>
          <source>object backing the pointer %0 will be destroyed at the end of the full-expression</source>
          <target>object backing the pointer {$arg0} will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6772" name="warn_dangling_lifetime_pointer_member">
        <segment>
          <source>initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object</source>
          <target>initializing pointer member {$arg0} to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object</target>
        </segment>
      </unit>
      <unit id="6773" name="warn_dangling_member">
        <segment>
          <source>%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object</source>
          <target>{$arg2 :select s0=|reference| s1=|backing array for 'std::initializer_list'|} {$arg1 :select s0=|| s1=|subobject of |}member {$arg0} {$arg2 :select s0=|binds to| s1=|is|} a temporary object whose lifetime is shorter than the lifetime of the constructed object</target>
        </segment>
      </unit>
      <unit id="6774" name="warn_dangling_pointer_assignment">
        <segment>
          <source state="initial">object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression</source>
          <target>object backing {$arg0 :select s0=|| s1=|the pointer |}{$arg1} will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6775" name="warn_dangling_reference_captured">
        <segment>
          <source state="initial">object whose reference is captured by %0 will be destroyed at the end of the full-expression</source>
          <target>object whose reference is captured by {$arg0} will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6776" name="warn_dangling_reference_captured_by_unknown">
        <segment>
          <source>object whose reference is captured will be destroyed at the end of the full-expression</source>
          <target>object whose reference is captured will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6777" name="warn_dangling_variable">
        <segment>
          <source>%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression</source>
          <target>%select{temporary %select{whose address is used as value of|{$arg4 :select s0=|| s1=|implicitly }2bound to|} %select{{$arg4 :select s0=|| s1=|reference |}member of local variable|local {$arg1 :select s0=|variable| s1=|reference}4|}|array backing {$arg0 :select s0=|initializer list subobject of local variable| s1=|local initializer list}1|} {$arg2 :select s0=|{$arg3} | s1=||}will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="6778" name="warn_dealloc_in_category">
        <segment>
          <source>-dealloc is being overridden in a category</source>
          <target>-dealloc is being overridden in a category</target>
        </segment>
      </unit>
      <unit id="6779" name="warn_decl_hidden_in_cpp">
        <segment>
          <source>%select{struct|union|enum}0 defined within a struct or union is not visible in C++</source>
          <target>{$arg0 :select s0=|struct| s1=|union| s2=|enum|} defined within a struct or union is not visible in C++</target>
        </segment>
      </unit>
      <unit id="6780" name="warn_decl_in_param_list">
        <segment>
          <source>declaration of %0 will not be visible outside of this function</source>
          <target>declaration of {$arg0} will not be visible outside of this function</target>
        </segment>
      </unit>
      <unit id="6781" name="warn_decl_shadow">
        <segment>
          <source>declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1</source>
          <target>declaration shadows a {$arg1 :select s0=|local variable| s1=|variable in {$arg2}| s2=|static data member of {$arg2}| s3=|field of {$arg2}| s4=|typedef in {$arg2}| s5=|type alias in {$arg2}| s6=|structured binding|}</target>
        </segment>
      </unit>
      <unit id="6782" name="warn_decl_shadow_uncaptured_local">
        <segment>
          <source>declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1</source>
          <target>declaration shadows a {$arg1 :select s0=|local variable| s1=|variable in {$arg2}| s2=|static data member of {$arg2}| s3=|field of {$arg2}| s4=|typedef in {$arg2}| s5=|type alias in {$arg2}| s6=|structured binding|}</target>
        </segment>
      </unit>
      <unit id="6783" name="warn_declspec_allocator_nonpointer">
        <segment>
          <source>ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type</source>
          <target>ignoring __declspec(allocator) because the function return type {$arg0} is not a pointer or reference type</target>
        </segment>
      </unit>
      <unit id="6784" name="warn_declspec_attribute_ignored">
        <segment>
          <source>attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration</source>
          <target>attribute {$arg0} is ignored, place it after "{$arg1 :select s0=|class| s1=|struct| s2=|interface| s3=|union| s4=|enum| s5=|enum class| s6=|enum struct|}" to apply attribute to type declaration</target>
        </segment>
      </unit>
      <unit id="6785" name="warn_deep_exception_specs_differ">
        <segment>
          <source>exception specifications of %select{return|argument}0 types differ</source>
          <target>exception specifications of {$arg0 :select s0=|return| s1=|argument|} types differ</target>
        </segment>
      </unit>
      <unit id="6786" name="warn_def_missing_case">
        <segment>
          <source>%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0</source>
          <target>%plural{1:enumeration value {$arg1} not explicitly handled in switch|2:enumeration values {$arg1} and {$arg2} not explicitly handled in switch|3:enumeration values {$arg1}, {$arg2}, and {$arg3} not explicitly handled in switch|:{$arg0} enumeration values not explicitly handled in switch: {$arg1}, {$arg2}, {$arg3}...}0</target>
        </segment>
      </unit>
      <unit id="6787" name="warn_default_atomic_custom_getter_setter">
        <segment>
          <source>atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)</source>
          <target>atomic by default property {$arg0} has a user defined {$arg1 :select s0=|getter| s1=|setter|} (property should be marked 'atomic' if this is intended)</target>
        </segment>
      </unit>
      <unit id="6788" name="warn_default_init_const">
        <segment>
          <source>default initialization of an object of type %0 is incompatible with C++</source>
          <target>default initialization of an object of type {$arg0} is incompatible with C++</target>
        </segment>
      </unit>
      <unit id="6789" name="warn_default_init_const_field">
        <segment>
          <source>default initialization of an object of type %0 with const member is incompatible with C++</source>
          <target>default initialization of an object of type {$arg0} with const member is incompatible with C++</target>
        </segment>
      </unit>
      <unit id="6790" name="warn_default_init_const_field_unsafe">
        <segment>
          <source>default initialization of an object of type %0 with const member leaves the object uninitialized%select{| and is incompatible with C++}1</source>
          <target>default initialization of an object of type {$arg0} with const member leaves the object uninitialized{$arg1 :select s0=|| s1=| and is incompatible with C++|}</target>
        </segment>
      </unit>
      <unit id="6791" name="warn_default_init_const_unsafe">
        <segment>
          <source>default initialization of an object of type %0 leaves the object uninitialized%select{| and is incompatible with C++}1</source>
          <target>default initialization of an object of type {$arg0} leaves the object uninitialized{$arg1 :select s0=|| s1=| and is incompatible with C++|}</target>
        </segment>
      </unit>
      <unit id="6792" name="warn_defaulted_comparison_deleted">
        <segment>
          <source>explicitly defaulted %select{&lt;ERROR&gt;|equality|three-way|equality|relational}0 comparison operator is implicitly deleted</source>
          <target>explicitly defaulted {$arg0 :select s0=|&lt;ERROR&gt;| s1=|equality| s2=|three-way| s3=|equality| s4=|relational|} comparison operator is implicitly deleted</target>
        </segment>
      </unit>
      <unit id="6793" name="warn_defaulted_method_deleted">
        <segment>
          <source>explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted</source>
          <target>explicitly defaulted {$arg0 :select s0=|default constructor| s1=|copy constructor| s2=|move constructor| s3=|copy assignment operator| s4=|move assignment operator| s5=|destructor|} is implicitly deleted</target>
        </segment>
      </unit>
      <unit id="6794" name="warn_delegating_ctor_cycle">
        <segment>
          <source>constructor for %0 creates a delegation cycle</source>
          <target>constructor for {$arg0} creates a delegation cycle</target>
        </segment>
      </unit>
      <unit id="6795" name="warn_delete_abstract_non_virtual_dtor">
        <segment>
          <source>%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor</source>
          <target>{$arg0 :select s0=|delete| s1=|destructor|} called on {$arg1} that is abstract but has non-virtual destructor</target>
        </segment>
      </unit>
      <unit id="6796" name="warn_delete_array_type">
        <segment>
          <source>'delete' applied to a pointer-to-array type %0 treated as 'delete[]'</source>
          <target>'delete' applied to a pointer-to-array type {$arg0} treated as 'delete[]'</target>
        </segment>
      </unit>
      <unit id="6797" name="warn_delete_incomplete">
        <segment>
          <source>deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior</source>
          <target>deleting pointer to incomplete type {$arg0} is incompatible with C++2c and may cause undefined behavior</target>
        </segment>
      </unit>
      <unit id="6798" name="warn_delete_non_virtual_dtor">
        <segment>
          <source>%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor</source>
          <target>{$arg0 :select s0=|delete| s1=|destructor|} called on non-final {$arg1} that has virtual functions but non-virtual destructor</target>
        </segment>
      </unit>
      <unit id="6799" name="warn_depr_array_comparison">
        <segment>
          <source>comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers</source>
          <target>comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers</target>
        </segment>
      </unit>
      <unit id="6800" name="warn_deprecated">
        <segment>
          <source>%0 is deprecated</source>
          <target>{$arg0} is deprecated</target>
        </segment>
      </unit>
      <unit id="6801" name="warn_deprecated_altivec_src_compat">
        <segment>
          <source>current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option</source>
          <target>current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option</target>
        </segment>
      </unit>
      <unit id="6802" name="warn_deprecated_anonymous_namespace">
        <segment>
          <source>'deprecated' attribute on anonymous namespace ignored</source>
          <target>'deprecated' attribute on anonymous namespace ignored</target>
        </segment>
      </unit>
      <unit id="6803" name="warn_deprecated_builtin">
        <segment>
          <source>builtin %0 is deprecated; use %1 instead</source>
          <target>builtin {$arg0} is deprecated; use {$arg1} instead</target>
        </segment>
      </unit>
      <unit id="6804" name="warn_deprecated_comma_subscript">
        <segment>
          <source>top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23</source>
          <target>top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23</target>
        </segment>
      </unit>
      <unit id="6805" name="warn_deprecated_copy">
        <segment>
          <source>definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1</source>
          <target>definition of implicit copy {$arg1 :select s0=|constructor| s1=|assignment operator|} for {$arg0} is deprecated because it has a user-declared copy {$arg1 :select s0=|assignment operator| s1=|constructor|}</target>
        </segment>
      </unit>
      <unit id="6806" name="warn_deprecated_copy_with_dtor">
        <segment>
          <source>definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor</source>
          <target>definition of implicit copy {$arg1 :select s0=|constructor| s1=|assignment operator|} for {$arg0} is deprecated because it has a user-declared destructor</target>
        </segment>
      </unit>
      <unit id="6807" name="warn_deprecated_copy_with_user_provided_copy">
        <segment>
          <source>definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1</source>
          <target>definition of implicit copy {$arg1 :select s0=|constructor| s1=|assignment operator|} for {$arg0} is deprecated because it has a user-provided copy {$arg1 :select s0=|assignment operator| s1=|constructor|}</target>
        </segment>
      </unit>
      <unit id="6808" name="warn_deprecated_copy_with_user_provided_dtor">
        <segment>
          <source>definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor</source>
          <target>definition of implicit copy {$arg1 :select s0=|constructor| s1=|assignment operator|} for {$arg0} is deprecated because it has a user-provided destructor</target>
        </segment>
      </unit>
      <unit id="6809" name="warn_deprecated_def">
        <segment>
          <source>implementing deprecated %select{method|class|category}0</source>
          <target>implementing deprecated {$arg0 :select s0=|method| s1=|class| s2=|category|}</target>
        </segment>
      </unit>
      <unit id="6810" name="warn_deprecated_fwdclass_message">
        <segment>
          <source>%0 may be deprecated because the receiver type is unknown</source>
          <target>{$arg0} may be deprecated because the receiver type is unknown</target>
        </segment>
      </unit>
      <unit id="6811" name="warn_deprecated_ignored_on_using">
        <segment>
          <source>%0 currently has no effect on a using declaration</source>
          <target>{$arg0} currently has no effect on a using declaration</target>
        </segment>
      </unit>
      <unit id="6812" name="warn_deprecated_increment_decrement_volatile">
        <segment>
          <source>%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated</source>
          <target>{$arg0 :select s0=|decrement| s1=|increment|} of object of volatile-qualified type {$arg1} is deprecated</target>
        </segment>
      </unit>
      <unit id="6813" name="warn_deprecated_lax_vec_conv_all">
        <segment>
          <source>implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default</source>
          <target>implicit conversion between vector types ('{$arg0}' and '{$arg1}') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default</target>
        </segment>
      </unit>
      <unit id="6814" name="warn_deprecated_literal_operator_id">
        <segment>
          <source>identifier %0 preceded by whitespace in a literal operator declaration is deprecated</source>
          <target>identifier {$arg0} preceded by whitespace in a literal operator declaration is deprecated</target>
        </segment>
      </unit>
      <unit id="6815" name="warn_deprecated_message">
        <segment>
          <source>%0 is deprecated: %1</source>
          <target>{$arg0} is deprecated: {$arg1}</target>
        </segment>
      </unit>
      <unit id="6816" name="warn_deprecated_noreturn_spelling">
        <segment>
          <source>the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead</source>
          <target>the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead</target>
        </segment>
      </unit>
      <unit id="6817" name="warn_deprecated_redundant_constexpr_static_def">
        <segment>
          <source>out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated</source>
          <target>out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated</target>
        </segment>
      </unit>
      <unit id="6818" name="warn_deprecated_register">
        <segment>
          <source>'register' storage class specifier is deprecated and incompatible with C++17</source>
          <target>'register' storage class specifier is deprecated and incompatible with C++17</target>
        </segment>
      </unit>
      <unit id="6819" name="warn_deprecated_simple_assign_volatile">
        <segment>
          <source>use of result of assignment to object of volatile-qualified type %0 is deprecated</source>
          <target>use of result of assignment to object of volatile-qualified type {$arg0} is deprecated</target>
        </segment>
      </unit>
      <unit id="6820" name="warn_deprecated_string_literal_conversion">
        <segment>
          <source>conversion from string literal to %0 is deprecated</source>
          <target>conversion from string literal to {$arg0} is deprecated</target>
        </segment>
      </unit>
      <unit id="6821" name="warn_deprecated_this_capture">
        <segment>
          <source>implicit capture of 'this' with a capture default of '=' is deprecated</source>
          <target>implicit capture of 'this' with a capture default of '=' is deprecated</target>
        </segment>
      </unit>
      <unit id="6822" name="warn_deprecated_volatile_param">
        <segment>
          <source>volatile-qualified parameter type %0 is deprecated</source>
          <target>volatile-qualified parameter type {$arg0} is deprecated</target>
        </segment>
      </unit>
      <unit id="6823" name="warn_deprecated_volatile_return">
        <segment>
          <source>volatile-qualified return type %0 is deprecated</source>
          <target>volatile-qualified return type {$arg0} is deprecated</target>
        </segment>
      </unit>
      <unit id="6824" name="warn_deprecated_volatile_structured_binding">
        <segment>
          <source>volatile qualifier in structured binding declaration is deprecated</source>
          <target>volatile qualifier in structured binding declaration is deprecated</target>
        </segment>
      </unit>
      <unit id="6825" name="warn_dereference_of_noderef_type">
        <segment>
          <source>dereferencing %0; was declared with a 'noderef' type</source>
          <target>dereferencing {$arg0}; was declared with a 'noderef' type</target>
        </segment>
      </unit>
      <unit id="6826" name="warn_dereference_of_noderef_type_no_decl">
        <segment>
          <source>dereferencing expression marked as 'noderef'</source>
          <target>dereferencing expression marked as 'noderef'</target>
        </segment>
      </unit>
      <unit id="6827" name="warn_diagnose_if_succeeded">
        <segment>
          <source>%0</source>
          <target>{$arg0}</target>
        </segment>
      </unit>
      <unit id="6828" name="warn_direct_initialize_call">
        <segment>
          <source>explicit call to +initialize results in duplicate call to +initialize</source>
          <target>explicit call to +initialize results in duplicate call to +initialize</target>
        </segment>
      </unit>
      <unit id="6829" name="warn_direct_ivar_access">
        <segment>
          <source>instance variable %0 is being directly accessed</source>
          <target>instance variable {$arg0} is being directly accessed</target>
        </segment>
      </unit>
      <unit id="6830" name="warn_direct_super_initialize_call">
        <segment>
          <source>explicit call to [super initialize] should only be in implementation of +initialize</source>
          <target>explicit call to [super initialize] should only be in implementation of +initialize</target>
        </segment>
      </unit>
      <unit id="6831" name="warn_dispatch_body_ignored">
        <segment>
          <source>body of cpu_dispatch function will be ignored</source>
          <target>body of cpu_dispatch function will be ignored</target>
        </segment>
      </unit>
      <unit id="6832" name="warn_division_sizeof_array">
        <segment>
          <source>expression does not compute the number of elements in this array; element type is %0, not %1</source>
          <target>expression does not compute the number of elements in this array; element type is {$arg0}, not {$arg1}</target>
        </segment>
      </unit>
      <unit id="6833" name="warn_division_sizeof_ptr">
        <segment>
          <source state="initial">%0 will return the size of the pointer, not the array itself</source>
          <target>{$arg0} will return the size of the pointer, not the array itself</target>
        </segment>
      </unit>
      <unit id="6834" name="warn_dllimport_dropped_from_inline_function">
        <segment>
          <source>%q0 redeclared inline; %1 attribute ignored</source>
          <target>{$arg0 :q} redeclared inline; {$arg1} attribute ignored</target>
        </segment>
      </unit>
      <unit id="6835" name="warn_double_const_requires_fp64">
        <segment>
          <source>double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision</source>
          <target>double precision constant requires {$arg0 :select s0=|cl_khr_fp64| s1=|cl_khr_fp64 and __opencl_c_fp64|}, casting to single precision</target>
        </segment>
      </unit>
      <unit id="6836" name="warn_double_lock">
        <segment>
          <source>acquiring %0 '%1' that is already held</source>
          <target>acquiring {$arg0} '{$arg1}' that is already held</target>
        </segment>
      </unit>
      <unit id="6837" name="warn_duplicate_attribute">
        <segment>
          <source>attribute %0 is already applied with different arguments</source>
          <target>attribute {$arg0} is already applied with different arguments</target>
        </segment>
      </unit>
      <unit id="6838" name="warn_duplicate_attribute_exact">
        <segment>
          <source>attribute %0 is already applied</source>
          <target>attribute {$arg0} is already applied</target>
        </segment>
      </unit>
      <unit id="6839" name="warn_duplicate_codeseg_attribute">
        <segment>
          <source>duplicate code segment specifiers</source>
          <target>duplicate code segment specifiers</target>
        </segment>
      </unit>
      <unit id="6840" name="warn_duplicate_enum_values">
        <segment>
          <source>element %0 has been implicitly assigned %1 which another element has been assigned</source>
          <target>element {$arg0} has been implicitly assigned {$arg1} which another element has been assigned</target>
        </segment>
      </unit>
      <unit id="6841" name="warn_duplicate_method_decl">
        <segment>
          <source>multiple declarations of method %0 found and ignored</source>
          <target>multiple declarations of method {$arg0} found and ignored</target>
        </segment>
      </unit>
      <unit id="6842" name="warn_duplicate_protocol_def">
        <segment>
          <source>duplicate protocol definition of %0 is ignored</source>
          <target>duplicate protocol definition of {$arg0} is ignored</target>
        </segment>
      </unit>
      <unit id="6843" name="warn_dyn_class_memaccess">
        <segment>
          <source>%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4</source>
          <target>{$arg0 :select s0=|destination for| s1=|source of| s2=|first operand of| s3=|second operand of|} this {$arg1} call is a pointer to {$arg2 :select s0=|| s1=|class containing a |}dynamic class {$arg3}; vtable pointer will be {$arg4 :select s0=|overwritten| s1=|copied| s2=|moved| s3=|compared|}</target>
        </segment>
      </unit>
      <unit id="6844" name="warn_empty_for_body">
        <segment>
          <source>for loop has empty body</source>
          <target>for loop has empty body</target>
        </segment>
      </unit>
      <unit id="6845" name="warn_empty_format_string">
        <segment>
          <source>format string is empty</source>
          <target>format string is empty</target>
        </segment>
      </unit>
      <unit id="6846" name="warn_empty_if_body">
        <segment>
          <source>if statement has empty body</source>
          <target>if statement has empty body</target>
        </segment>
      </unit>
      <unit id="6847" name="warn_empty_parens_are_function_decl">
        <segment>
          <source>empty parentheses interpreted as a function declaration</source>
          <target>empty parentheses interpreted as a function declaration</target>
        </segment>
      </unit>
      <unit id="6848" name="warn_empty_range_based_for_body">
        <segment>
          <source>range-based for loop has empty body</source>
          <target>range-based for loop has empty body</target>
        </segment>
      </unit>
      <unit id="6849" name="warn_empty_switch_body">
        <segment>
          <source>switch statement has empty body</source>
          <target>switch statement has empty body</target>
        </segment>
      </unit>
      <unit id="6850" name="warn_empty_while_body">
        <segment>
          <source>while loop has empty body</source>
          <target>while loop has empty body</target>
        </segment>
      </unit>
      <unit id="6851" name="warn_enum_constant_in_bool_context">
        <segment>
          <source>converting the enum constant to a boolean</source>
          <target>converting the enum constant to a boolean</target>
        </segment>
      </unit>
      <unit id="6852" name="warn_equality_with_extra_parens">
        <segment>
          <source>equality comparison with extraneous parentheses</source>
          <target>equality comparison with extraneous parentheses</target>
        </segment>
      </unit>
      <unit id="6853" name="warn_exception_caught_by_earlier_handler">
        <segment>
          <source>exception of type %0 will be caught by earlier handler</source>
          <target>exception of type {$arg0} will be caught by earlier handler</target>
        </segment>
      </unit>
      <unit id="6854" name="warn_excess_precision_not_supported">
        <segment>
          <source>excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0</source>
          <target>excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior{$arg0 :select s0=|| s1=|, additional uses where the requested higher precision cannot be honored were found but not diagnosed|}</target>
        </segment>
      </unit>
      <unit id="6855" name="warn_exit_time_destructor">
        <segment>
          <source>declaration requires an exit-time destructor</source>
          <target>declaration requires an exit-time destructor</target>
        </segment>
      </unit>
      <unit id="6856" name="warn_expect_fewer_underlying_mutexes">
        <segment>
          <source>did not expect %0 '%2' to be managed by '%1'</source>
          <target>did not expect {$arg0} '{$arg2}' to be managed by '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6857" name="warn_expect_more_underlying_mutexes">
        <segment>
          <source>%0 '%2' not managed by '%1'</source>
          <target>{$arg0} '{$arg2}' not managed by '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6858" name="warn_expecting_lock_held_on_loop">
        <segment>
          <source>expecting %0 '%1' to be held at start of each loop</source>
          <target>expecting {$arg0} '{$arg1}' to be held at start of each loop</target>
        </segment>
      </unit>
      <unit id="6859" name="warn_expecting_locked">
        <segment>
          <source>expecting %0 '%1' to be held at the end of function</source>
          <target>expecting {$arg0} '{$arg1}' to be held at the end of function</target>
        </segment>
      </unit>
      <unit id="6860" name="warn_experimental_header_unit">
        <segment>
          <source>the implementation of header units is in an experimental phase</source>
          <target>the implementation of header units is in an experimental phase</target>
        </segment>
      </unit>
      <unit id="6861" name="warn_explicit_instantiation_after_specialization">
        <segment>
          <source>explicit instantiation of %0 that occurs after an explicit specialization has no effect</source>
          <target>explicit instantiation of {$arg0} that occurs after an explicit specialization has no effect</target>
        </segment>
      </unit>
      <unit id="6862" name="warn_explicit_instantiation_inline_0x">
        <segment>
          <source>explicit instantiation cannot be 'inline'</source>
          <target>explicit instantiation cannot be 'inline'</target>
        </segment>
      </unit>
      <unit id="6863" name="warn_explicit_instantiation_must_be_global_0x">
        <segment>
          <source>explicit instantiation of %0 must occur at global scope</source>
          <target>explicit instantiation of {$arg0} must occur at global scope</target>
        </segment>
      </unit>
      <unit id="6864" name="warn_explicit_instantiation_out_of_scope_0x">
        <segment>
          <source>explicit instantiation of %0 not in a namespace enclosing %1</source>
          <target>explicit instantiation of {$arg0} not in a namespace enclosing {$arg1}</target>
        </segment>
      </unit>
      <unit id="6865" name="warn_explicit_instantiation_unqualified_wrong_namespace_0x">
        <segment>
          <source>explicit instantiation of %q0 must occur in namespace %1</source>
          <target>explicit instantiation of {$arg0 :q} must occur in namespace {$arg1}</target>
        </segment>
      </unit>
      <unit id="6866" name="warn_extern_init">
        <segment>
          <source>'extern' variable has an initializer</source>
          <target>'extern' variable has an initializer</target>
        </segment>
      </unit>
      <unit id="6867" name="warn_falloff_nonvoid">
        <segment>
          <source>non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1</source>
          <target>non-void {$arg0 :select s0=|function| s1=|block| s2=|lambda| s3=|coroutine|} does not return a value{$arg1 :select s0=|| s1=| in all control paths|}</target>
        </segment>
      </unit>
      <unit id="6868" name="warn_field_is_uninit">
        <segment>
          <source>field %0 is uninitialized when used here</source>
          <target>field {$arg0} is uninitialized when used here</target>
        </segment>
      </unit>
      <unit id="6869" name="warn_field_requires_explicit_init">
        <segment>
          <source>field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized</source>
          <target>field {$arg0 :select s0=|{$arg1}| s1=|in {$arg1}|} requires explicit initialization but is not explicitly initialized</target>
        </segment>
      </unit>
      <unit id="6870" name="warn_final_dtor_non_final_class">
        <segment>
          <source>class with destructor marked '%select{final|sealed}0' cannot be inherited from</source>
          <target>class with destructor marked '{$arg0 :select s0=|final| s1=|sealed|}' cannot be inherited from</target>
        </segment>
      </unit>
      <unit id="6871" name="warn_flag_enum_constant_out_of_range">
        <segment>
          <source>enumeration value %0 is out of range of flags in enumeration type %1</source>
          <target>enumeration value {$arg0} is out of range of flags in enumeration type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6872" name="warn_float_compare_literal">
        <segment>
          <source>floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1</source>
          <target>floating-point comparison is always {$arg0 :select s0=|true| s1=|false|}; constant cannot be represented exactly in type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6873" name="warn_float_overflow">
        <segment>
          <source>magnitude of floating-point constant too large for type %0; maximum is %1</source>
          <target>magnitude of floating-point constant too large for type {$arg0}; maximum is {$arg1}</target>
        </segment>
      </unit>
      <unit id="6874" name="warn_float_underflow">
        <segment>
          <source>magnitude of floating-point constant too small for type %0; minimum is %1</source>
          <target>magnitude of floating-point constant too small for type {$arg0}; minimum is {$arg1}</target>
        </segment>
      </unit>
      <unit id="6875" name="warn_floatingpoint_eq">
        <segment>
          <source>comparing floating point with == or != is unsafe</source>
          <target>comparing floating point with == or != is unsafe</target>
        </segment>
      </unit>
      <unit id="6876" name="warn_for_range_begin_end_types_differ">
        <segment>
          <source>'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17</source>
          <target>'begin' and 'end' returning different types ({$arg0} and {$arg1}) is incompatible with C++ standards before C++17</target>
        </segment>
      </unit>
      <unit id="6877" name="warn_for_range_const_ref_binds_temp_built_from_ref">
        <segment>
          <source>loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2</source>
          <target>loop variable {$arg0} %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2</target>
        </segment>
      </unit>
      <unit id="6878" name="warn_for_range_copy">
        <segment>
          <source>loop variable %0 creates a copy from type %1</source>
          <target>loop variable {$arg0} creates a copy from type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6879" name="warn_for_range_ref_binds_ret_temp">
        <segment>
          <source>loop variable %0 binds to a temporary value produced by a range of type %1</source>
          <target>loop variable {$arg0} binds to a temporary value produced by a range of type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6880" name="warn_format_P_no_precision">
        <segment>
          <source>using '%%P' format specifier without precision</source>
          <target>using '%P' format specifier without precision</target>
        </segment>
      </unit>
      <unit id="6881" name="warn_format_P_with_objc_pointer">
        <segment>
          <source>using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value</source>
          <target>using '%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value</target>
        </segment>
      </unit>
      <unit id="6882" name="warn_format_argument_needs_cast">
        <segment>
          <source>%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead</source>
          <target>{$arg2 :select s0=|values of type| s1=|enum values with underlying type|} '{$arg0}' should not be used as format arguments; add an explicit cast to {$arg1} instead</target>
        </segment>
      </unit>
      <unit id="6883" name="warn_format_argument_needs_cast_pedantic">
        <segment>
          <source>%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead</source>
          <target>{$arg2 :select s0=|values of type| s1=|enum values with underlying type|} '{$arg0}' should not be used as format arguments; add an explicit cast to {$arg1} instead</target>
        </segment>
      </unit>
      <unit id="6884" name="warn_format_bool_as_character">
        <segment>
          <source>using '%0' format specifier, but argument has boolean value</source>
          <target>using '{$arg0}' format specifier, but argument has boolean value</target>
        </segment>
      </unit>
      <unit id="6885" name="warn_format_cmp_modifierfor_mismatch">
        <segment>
          <source>format argument modifies specifier at position %0, but it should modify specifier at position %1</source>
          <target>format argument modifies specifier at position {$arg0}, but it should modify specifier at position {$arg1}</target>
        </segment>
      </unit>
      <unit id="6886" name="warn_format_cmp_role_mismatch">
        <segment>
          <source>format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1</source>
          <target>format argument is {$arg0 :select s0=|a value| s1=|an indirect field width| s2=|an indirect precision| s3=|an auxiliary value|}, but it should be {$arg1 :select s0=|a value| s1=|an indirect field width| s2=|an indirect precision| s3=|an auxiliary value|}</target>
        </segment>
      </unit>
      <unit id="6887" name="warn_format_cmp_sensitivity_mismatch">
        <segment>
          <source>argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1</source>
          <target>argument sensitivity is {$arg0 :select s0=|unspecified| s1=|private| s2=|public| s3=|sensitive|}, but it should be {$arg1 :select s0=|unspecified| s1=|private| s2=|public| s3=|sensitive|}</target>
        </segment>
      </unit>
      <unit id="6888" name="warn_format_cmp_specifier_arity">
        <segment>
          <source>%select{fewer|more}0 specifiers in format string than expected</source>
          <target>{$arg0 :select s0=|fewer| s1=|more|} specifiers in format string than expected</target>
        </segment>
      </unit>
      <unit id="6889" name="warn_format_cmp_specifier_mismatch">
        <segment>
          <source>format specifier '%0' is incompatible with '%1'</source>
          <target>format specifier '{$arg0}' is incompatible with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6890" name="warn_format_cmp_specifier_mismatch_pedantic">
        <segment>
          <source>signedness of format specifier '%0' is incompatible with '%1'</source>
          <target>signedness of format specifier '{$arg0}' is incompatible with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6891" name="warn_format_cmp_specifier_sign_mismatch">
        <segment>
          <source>signedness of format specifier '%0' is incompatible with '%1'</source>
          <target>signedness of format specifier '{$arg0}' is incompatible with '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6892" name="warn_format_conversion_argument_type_mismatch">
        <segment>
          <source>format specifies type %0 but the argument has %select{type|underlying type}2 %1</source>
          <target>format specifies type {$arg0} but the argument has {$arg2 :select s0=|type| s1=|underlying type|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="6893" name="warn_format_conversion_argument_type_mismatch_confusion">
        <segment>
          <source>format specifies type %0 but the argument has %select{type|underlying type}2 %1</source>
          <target>format specifies type {$arg0} but the argument has {$arg2 :select s0=|type| s1=|underlying type|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="6894" name="warn_format_conversion_argument_type_mismatch_pedantic">
        <segment>
          <source>format specifies type %0 but the argument has %select{type|underlying type}2 %1</source>
          <target>format specifies type {$arg0} but the argument has {$arg2 :select s0=|type| s1=|underlying type|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="6895" name="warn_format_conversion_argument_type_mismatch_signedness">
        <segment>
          <source>format specifies type %0 but the argument has %select{type|underlying type}2 %1</source>
          <target>format specifies type {$arg0} but the argument has {$arg2 :select s0=|type| s1=|underlying type|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="6896" name="warn_format_invalid_annotation">
        <segment>
          <source>using '%0' format specifier annotation outside of os_log()/os_trace()</source>
          <target>using '{$arg0}' format specifier annotation outside of os_log()/os_trace()</target>
        </segment>
      </unit>
      <unit id="6897" name="warn_format_invalid_conversion">
        <segment>
          <source>invalid conversion specifier '%0'</source>
          <target>invalid conversion specifier '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="6898" name="warn_format_invalid_positional_specifier">
        <segment>
          <source>invalid position specified for %select{field width|field precision}0</source>
          <target>invalid position specified for {$arg0 :select s0=|field width| s1=|field precision|}</target>
        </segment>
      </unit>
      <unit id="6899" name="warn_format_mix_positional_nonpositional_args">
        <segment>
          <source>cannot mix positional and non-positional arguments in format string</source>
          <target>cannot mix positional and non-positional arguments in format string</target>
        </segment>
      </unit>
      <unit id="6900" name="warn_format_non_standard">
        <segment>
          <source>'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C</source>
          <target>'{$arg0}' {$arg1 :select s0=|length modifier| s1=|conversion specifier|} is not supported by ISO C</target>
        </segment>
      </unit>
      <unit id="6901" name="warn_format_non_standard_conversion_spec">
        <segment>
          <source>using length modifier '%0' with conversion specifier '%1' is not supported by ISO C</source>
          <target>using length modifier '{$arg0}' with conversion specifier '{$arg1}' is not supported by ISO C</target>
        </segment>
      </unit>
      <unit id="6902" name="warn_format_non_standard_positional_arg">
        <segment>
          <source>positional arguments are not supported by ISO C</source>
          <target>positional arguments are not supported by ISO C</target>
        </segment>
      </unit>
      <unit id="6903" name="warn_format_nonliteral">
        <segment>
          <source>format string is not a string literal</source>
          <target>format string is not a string literal</target>
        </segment>
      </unit>
      <unit id="6904" name="warn_format_nonliteral_noargs">
        <segment>
          <source>format string is not a string literal (potentially insecure)</source>
          <target>format string is not a string literal (potentially insecure)</target>
        </segment>
      </unit>
      <unit id="6905" name="warn_format_nonsensical_length">
        <segment>
          <source>length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier</source>
          <target>length modifier '{$arg0}' results in undefined behavior or no effect with '{$arg1}' conversion specifier</target>
        </segment>
      </unit>
      <unit id="6906" name="warn_format_overflow">
        <segment>
          <source>'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2</source>
          <target>'{$arg0}' will always overflow; destination buffer has size {$arg1}, but format string expands to at least {$arg2}</target>
        </segment>
      </unit>
      <unit id="6907" name="warn_format_overflow_non_kprintf">
        <segment>
          <source>'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2</source>
          <target>'{$arg0}' will always overflow; destination buffer has size {$arg1}, but format string expands to at least {$arg2}</target>
        </segment>
      </unit>
      <unit id="6908" name="warn_format_string_is_wide_literal">
        <segment>
          <source>format string should not be a wide string</source>
          <target>format string should not be a wide string</target>
        </segment>
      </unit>
      <unit id="6909" name="warn_format_string_type_incompatible">
        <segment>
          <source>passing '%0' format string where '%1' format string is expected</source>
          <target>passing '{$arg0}' format string where '{$arg1}' format string is expected</target>
        </segment>
      </unit>
      <unit id="6910" name="warn_format_truncation">
        <segment>
          <source>'%0' will always be truncated; specified size is %1, but format string expands to at least %2</source>
          <target>'{$arg0}' will always be truncated; specified size is {$arg1}, but format string expands to at least {$arg2}</target>
        </segment>
      </unit>
      <unit id="6911" name="warn_format_truncation_non_kprintf">
        <segment>
          <source>'%0' will always be truncated; specified size is %1, but format string expands to at least %2</source>
          <target>'{$arg0}' will always be truncated; specified size is {$arg1}, but format string expands to at least {$arg2}</target>
        </segment>
      </unit>
      <unit id="6912" name="warn_format_zero_positional_specifier">
        <segment>
          <source>position arguments in format strings start counting at 1 (not 0)</source>
          <target>position arguments in format strings start counting at 1 (not 0)</target>
        </segment>
      </unit>
      <unit id="6913" name="warn_fortify_scanf_overflow">
        <segment>
          <source>'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3</source>
          <target>'{$arg0}' may overflow; destination buffer in argument {$arg1} has size {$arg2}, but the corresponding specifier may require size {$arg3}</target>
        </segment>
      </unit>
      <unit id="6914" name="warn_fortify_source_overflow">
        <segment>
          <source>'%0' will always overflow; destination buffer has size %1, but size argument is %2</source>
          <target>'{$arg0}' will always overflow; destination buffer has size {$arg1}, but size argument is {$arg2}</target>
        </segment>
      </unit>
      <unit id="6915" name="warn_fortify_source_size_mismatch">
        <segment>
          <source>'%0' size argument is too large; destination buffer has size %1, but size argument is %2</source>
          <target>'{$arg0}' size argument is too large; destination buffer has size {$arg1}, but size argument is {$arg2}</target>
        </segment>
      </unit>
      <unit id="6916" name="warn_fortify_strlen_overflow">
        <segment>
          <source>'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)</source>
          <target>'{$arg0}' will always overflow; destination buffer has size {$arg1}, but the source string has length {$arg2} (including NUL byte)</target>
        </segment>
      </unit>
      <unit id="6917" name="warn_forward_class_redefinition">
        <segment>
          <source>redefinition of forward class %0 of a typedef name of an object type is ignored</source>
          <target>redefinition of forward class {$arg0} of a typedef name of an object type is ignored</target>
        </segment>
      </unit>
      <unit id="6918" name="warn_frame_address">
        <segment>
          <source>calling '%0' with a nonzero argument is unsafe</source>
          <target>calling '{$arg0}' with a nonzero argument is unsafe</target>
        </segment>
      </unit>
      <unit id="6919" name="warn_free_nonheap_object">
        <segment>
          <source>attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1</source>
          <target>attempt to call {$arg0} on non-heap {$arg1 :select s0=|object {$arg2}| s1=|object: block expression| s2=|object: lambda-to-function-pointer conversion|}</target>
        </segment>
      </unit>
      <unit id="6920" name="warn_fun_excludes_mutex">
        <segment>
          <source>cannot call function '%1' while %0 '%2' is held</source>
          <target>cannot call function '{$arg1}' while {$arg0} '{$arg2}' is held</target>
        </segment>
      </unit>
      <unit id="6921" name="warn_fun_requires_lock">
        <segment>
          <source>calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>calling function {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6922" name="warn_fun_requires_lock_precise">
        <segment>
          <source>calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>calling function {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6923" name="warn_fun_requires_negative_cap">
        <segment>
          <source>calling function %0 requires negative capability '%1'</source>
          <target>calling function {$arg0} requires negative capability '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="6924" name="warn_func_effect_calls_expr_without_effect">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block| s5=|member initializer of constructor|} with '{$arg1}' attribute must not call non-'{$arg1}' expression</target>
        </segment>
      </unit>
      <unit id="6925" name="warn_func_effect_calls_func_without_effect">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block| s5=|member initializer of constructor|} with '{$arg1}' attribute must not call non-'{$arg1}' {$arg2 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block|} '{$arg3}'</target>
        </segment>
      </unit>
      <unit id="6926" name="warn_func_effect_violation">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block| s5=|member initializer of constructor|} with '{$arg1}' attribute must not {$arg2 :select s0=|allocate or deallocate memory| s1=|throw or catch exceptions| s2=|have static local variables| s3=|use thread-local variables| s4=|access ObjC methods or properties|}</target>
        </segment>
      </unit>
      <unit id="6927" name="warn_func_template_missing">
        <segment>
          <source>instantiation of function %q0 required here, but no definition is available</source>
          <target>instantiation of function {$arg0 :q} required here, but no definition is available</target>
        </segment>
      </unit>
      <unit id="6928" name="warn_function_attribute_ignored_in_stmt">
        <segment>
          <source>attribute is ignored on this statement as it only applies to functions; use '%0' on statements</source>
          <target>attribute is ignored on this statement as it only applies to functions; use '{$arg0}' on statements</target>
        </segment>
      </unit>
      <unit id="6929" name="warn_function_def_in_objc_container">
        <segment>
          <source>function definition inside an Objective-C container is deprecated</source>
          <target>function definition inside an Objective-C container is deprecated</target>
        </segment>
      </unit>
      <unit id="6930" name="warn_function_stmt_attribute_precedence">
        <segment>
          <source>statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'</source>
          <target>statement attribute {$arg0} has higher precedence than function attribute '{$arg1 :select s0=|always_inline| s1=|flatten| s2=|noinline|}'</target>
        </segment>
      </unit>
      <unit id="6931" name="warn_gc_attribute_weak_on_local">
        <segment>
          <source>Objective-C GC does not allow weak variables on the stack</source>
          <target>Objective-C GC does not allow weak variables on the stack</target>
        </segment>
      </unit>
      <unit id="6932" name="warn_gcc_ignores_type_attr">
        <segment>
          <source>GCC does not allow the %0 attribute to be written on a type</source>
          <target>GCC does not allow the {$arg0} attribute to be written on a type</target>
        </segment>
      </unit>
      <unit id="6933" name="warn_gcc_requires_variadic_function">
        <segment>
          <source>GCC requires a function with the %0 attribute to be variadic</source>
          <target>GCC requires a function with the {$arg0} attribute to be variadic</target>
        </segment>
      </unit>
      <unit id="6934" name="warn_global_constructor">
        <segment>
          <source>declaration requires a global constructor</source>
          <target>declaration requires a global constructor</target>
        </segment>
      </unit>
      <unit id="6935" name="warn_global_destructor">
        <segment>
          <source>declaration requires a global destructor</source>
          <target>declaration requires a global destructor</target>
        </segment>
      </unit>
      <unit id="6936" name="warn_gnu_inline_attribute_requires_inline">
        <segment>
          <source>'gnu_inline' attribute requires function to be marked 'inline', attribute ignored</source>
          <target>'gnu_inline' attribute requires function to be marked 'inline', attribute ignored</target>
        </segment>
      </unit>
      <unit id="6937" name="warn_gnu_inline_cplusplus_without_extern">
        <segment>
          <source>'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10</source>
          <target>'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10</target>
        </segment>
      </unit>
      <unit id="6938" name="warn_gnu_null_ptr_arith">
        <segment>
          <source>arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension</source>
          <target>arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension</target>
        </segment>
      </unit>
      <unit id="6939" name="warn_guarded_pass_by_reference">
        <segment>
          <source>passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>passing variable {$arg1} by reference requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6940" name="warn_guarded_pass_pointer">
        <segment>
          <source>passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>passing pointer to variable {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6941" name="warn_guarded_return_by_reference">
        <segment>
          <source>returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>returning variable {$arg1} by reference requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6942" name="warn_guarded_return_pointer">
        <segment>
          <source>returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>returning pointer to variable {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="6943" name="warn_hip_omp_target_directives">
        <segment>
          <source>HIP does not support OpenMP target directives; directive has been ignored</source>
          <target>HIP does not support OpenMP target directives; directive has been ignored</target>
        </segment>
      </unit>
      <unit id="6944" name="warn_hlsl_availability">
        <segment>
          <source>%0 is only available %select{|in %4 environment }3on %1 %2 or newer</source>
          <target>{$arg0} is only available {$arg3 :select s0=|| s1=|in {$arg4} environment |}on {$arg1} {$arg2} or newer</target>
        </segment>
      </unit>
      <unit id="6945" name="warn_hlsl_availability_unavailable">
        <segment>
          <source>%0 is unavailable</source>
          <target>{$arg0} is unavailable</target>
        </segment>
      </unit>
      <unit id="6946" name="warn_hlsl_deprecated_register_type_b">
        <segment>
          <source>binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported</source>
          <target>binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported</target>
        </segment>
      </unit>
      <unit id="6947" name="warn_hlsl_deprecated_register_type_i">
        <segment>
          <source>binding type 'i' ignored. The 'integer constant' binding type is no longer supported</source>
          <target>binding type 'i' ignored. The 'integer constant' binding type is no longer supported</target>
        </segment>
      </unit>
      <unit id="6948" name="warn_hlsl_impcast_vector_truncation">
        <segment>
          <source>implicit conversion truncates vector: %0 to %1</source>
          <target>implicit conversion truncates vector: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6949" name="warn_hlsl_implicit_binding">
        <segment>
          <source>resource has implicit register binding</source>
          <target>resource has implicit register binding</target>
        </segment>
      </unit>
      <unit id="6950" name="warn_hlsl_packoffset_mix">
        <segment>
          <source>cannot mix packoffset elements with nonpackoffset elements in a cbuffer</source>
          <target>cannot mix packoffset elements with nonpackoffset elements in a cbuffer</target>
        </segment>
      </unit>
      <unit id="6951" name="warn_hlsl_register_type_c_packoffset">
        <segment>
          <source>binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?</source>
          <target>binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?</target>
        </segment>
      </unit>
      <unit id="6952" name="warn_hlsl_user_defined_type_missing_member">
        <segment>
          <source>binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0</source>
          <target>binding type '{$arg0 :select s0=|t| s1=|u| s2=|b| s3=|s| s4=|c|}' only applies to types containing {$arg0 :select s0=|SRV resources| s1=|UAV resources| s2=|constant buffer resources| s3=|sampler state| s4=|numeric types|}</target>
        </segment>
      </unit>
      <unit id="6953" name="warn_iboutlet_object_type">
        <segment>
          <source>%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)</source>
          <target>{$arg2 :select s0=|instance variable| s1=|property|} with {$arg0} attribute must be an object type (invalid {$arg1})</target>
        </segment>
      </unit>
      <unit id="6954" name="warn_iboutletcollection_property_assign">
        <segment>
          <source>IBOutletCollection properties should be copy/strong and not assign</source>
          <target>IBOutletCollection properties should be copy/strong and not assign</target>
        </segment>
      </unit>
      <unit id="6955" name="warn_identity_field_assign">
        <segment>
          <source>assigning %select{field|instance variable}0 to itself</source>
          <target>assigning {$arg0 :select s0=|field| s1=|instance variable|} to itself</target>
        </segment>
      </unit>
      <unit id="6956" name="warn_ignored_ms_inheritance">
        <segment>
          <source>inheritance model ignored on %select{primary template|partial specialization}0</source>
          <target>inheritance model ignored on {$arg0 :select s0=|primary template| s1=|partial specialization|}</target>
        </segment>
      </unit>
      <unit id="6957" name="warn_ignored_objc_externally_retained">
        <segment>
          <source>'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0</source>
          <target>'objc_externally_retained' can only be applied to local variables {$arg0 :select s0=|of retainable type| s1=|with strong ownership|}</target>
        </segment>
      </unit>
      <unit id="6958" name="warn_imp_cast_drops_unaligned">
        <segment>
          <source>implicit cast from type %0 to type %1 drops __unaligned qualifier</source>
          <target>implicit cast from type {$arg0} to type {$arg1} drops __unaligned qualifier</target>
        </segment>
      </unit>
      <unit id="6959" name="warn_impcast_bitfield_precision_constant">
        <segment>
          <source>implicit truncation from %2 to bit-field changes value from %0 to %1</source>
          <target>implicit truncation from {$arg2} to bit-field changes value from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6960" name="warn_impcast_bool_to_null_pointer">
        <segment>
          <source>initialization of pointer of type %0 to null from a constant boolean expression</source>
          <target>initialization of pointer of type {$arg0} to null from a constant boolean expression</target>
        </segment>
      </unit>
      <unit id="6961" name="warn_impcast_complex_scalar">
        <segment>
          <source>implicit conversion discards imaginary component: %0 to %1</source>
          <target>implicit conversion discards imaginary component: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6962" name="warn_impcast_constant_value_to_objc_bool">
        <segment>
          <source>implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO</source>
          <target>implicit conversion from constant value {$arg0} to 'BOOL'; the only well defined values for 'BOOL' are YES and NO</target>
        </segment>
      </unit>
      <unit id="6963" name="warn_impcast_different_enum_types">
        <segment>
          <source>implicit conversion from enumeration type %0 to different enumeration type %1</source>
          <target>implicit conversion from enumeration type {$arg0} to different enumeration type {$arg1}</target>
        </segment>
      </unit>
      <unit id="6964" name="warn_impcast_double_promotion">
        <segment>
          <source>implicit conversion increases floating-point precision: %0 to %1</source>
          <target>implicit conversion increases floating-point precision: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6965" name="warn_impcast_fixed_point_range">
        <segment>
          <source>implicit conversion from %0 cannot fit within the range of values for %1</source>
          <target>implicit conversion from {$arg0} cannot fit within the range of values for {$arg1}</target>
        </segment>
      </unit>
      <unit id="6966" name="warn_impcast_float_integer">
        <segment>
          <source>implicit conversion turns floating-point number into integer: %0 to %1</source>
          <target>implicit conversion turns floating-point number into integer: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6967" name="warn_impcast_float_precision">
        <segment>
          <source>implicit conversion loses floating-point precision: %0 to %1</source>
          <target>implicit conversion loses floating-point precision: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6968" name="warn_impcast_float_result_precision">
        <segment>
          <source>implicit conversion when assigning computation result loses floating-point precision: %0 to %1</source>
          <target>implicit conversion when assigning computation result loses floating-point precision: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6969" name="warn_impcast_float_to_integer">
        <segment>
          <source>implicit conversion from %0 to %1 changes value from %2 to %3</source>
          <target>implicit conversion from {$arg0} to {$arg1} changes value from {$arg2} to {$arg3}</target>
        </segment>
      </unit>
      <unit id="6970" name="warn_impcast_float_to_integer_out_of_range">
        <segment>
          <source>implicit conversion of out of range value from %0 to %1 is undefined</source>
          <target>implicit conversion of out of range value from {$arg0} to {$arg1} is undefined</target>
        </segment>
      </unit>
      <unit id="6971" name="warn_impcast_float_to_integer_zero">
        <segment>
          <source>implicit conversion from %0 to %1 changes non-zero value from %2 to %3</source>
          <target>implicit conversion from {$arg0} to {$arg1} changes non-zero value from {$arg2} to {$arg3}</target>
        </segment>
      </unit>
      <unit id="6972" name="warn_impcast_float_to_objc_signed_char_bool">
        <segment>
          <source>implicit conversion from floating-point type %0 to 'BOOL'</source>
          <target>implicit conversion from floating-point type {$arg0} to 'BOOL'</target>
        </segment>
      </unit>
      <unit id="6973" name="warn_impcast_floating_point_to_bool">
        <segment>
          <source>implicit conversion turns floating-point number into bool: %0 to %1</source>
          <target>implicit conversion turns floating-point number into bool: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6974" name="warn_impcast_high_order_zero_bits">
        <segment>
          <source>higher order bits are zeroes after implicit conversion</source>
          <target>higher order bits are zeroes after implicit conversion</target>
        </segment>
      </unit>
      <unit id="6975" name="warn_impcast_int_to_enum">
        <segment>
          <source>implicit conversion from %0 to enumeration type %1 is invalid in C++</source>
          <target>implicit conversion from {$arg0} to enumeration type {$arg1} is invalid in C++</target>
        </segment>
      </unit>
      <unit id="6976" name="warn_impcast_int_to_objc_signed_char_bool">
        <segment>
          <source>implicit conversion from integral type %0 to 'BOOL'</source>
          <target>implicit conversion from integral type {$arg0} to 'BOOL'</target>
        </segment>
      </unit>
      <unit id="6977" name="warn_impcast_integer_64_32">
        <segment>
          <source>implicit conversion loses integer precision: %0 to %1</source>
          <target>implicit conversion loses integer precision: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6978" name="warn_impcast_integer_float_precision">
        <segment>
          <source>implicit conversion from %0 to %1 may lose precision</source>
          <target>implicit conversion from {$arg0} to {$arg1} may lose precision</target>
        </segment>
      </unit>
      <unit id="6979" name="warn_impcast_integer_float_precision_constant">
        <segment>
          <source>implicit conversion from %2 to %3 changes value from %0 to %1</source>
          <target>implicit conversion from {$arg2} to {$arg3} changes value from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6980" name="warn_impcast_integer_precision">
        <segment>
          <source>implicit conversion loses integer precision: %0 to %1</source>
          <target>implicit conversion loses integer precision: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6981" name="warn_impcast_integer_precision_constant">
        <segment>
          <source>implicit conversion from %2 to %3 changes value from %0 to %1</source>
          <target>implicit conversion from {$arg2} to {$arg3} changes value from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6982" name="warn_impcast_integer_sign">
        <segment>
          <source>implicit conversion changes signedness: %0 to %1</source>
          <target>implicit conversion changes signedness: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6983" name="warn_impcast_integer_sign_conditional">
        <segment>
          <source>operand of ? changes signedness: %0 to %1</source>
          <target>operand of ? changes signedness: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6984" name="warn_impcast_literal_float_to_integer">
        <segment>
          <source>implicit conversion from %0 to %1 changes value from %2 to %3</source>
          <target>implicit conversion from {$arg0} to {$arg1} changes value from {$arg2} to {$arg3}</target>
        </segment>
      </unit>
      <unit id="6985" name="warn_impcast_literal_float_to_integer_out_of_range">
        <segment>
          <source>implicit conversion of out of range value from %0 to %1 is undefined</source>
          <target>implicit conversion of out of range value from {$arg0} to {$arg1} is undefined</target>
        </segment>
      </unit>
      <unit id="6986" name="warn_impcast_nonnegative_result">
        <segment>
          <source>the resulting value is always non-negative after implicit conversion</source>
          <target>the resulting value is always non-negative after implicit conversion</target>
        </segment>
      </unit>
      <unit id="6987" name="warn_impcast_null_pointer_to_integer">
        <segment>
          <source>implicit conversion of %select{NULL|nullptr}0 constant to %1</source>
          <target>implicit conversion of {$arg0 :select s0=|NULL| s1=|nullptr|} constant to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6988" name="warn_impcast_objective_c_literal_to_bool">
        <segment>
          <source>implicit boolean conversion of Objective-C object literal always evaluates to true</source>
          <target>implicit boolean conversion of Objective-C object literal always evaluates to true</target>
        </segment>
      </unit>
      <unit id="6989" name="warn_impcast_pointer_to_bool">
        <segment>
          <source>address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'</source>
          <target>address of {$arg0 :select s0=|'{$arg1}'| s1=|function '{$arg1}'| s2=|array '{$arg1}'| s3=|lambda function pointer conversion operator|} will always evaluate to 'true'</target>
        </segment>
      </unit>
      <unit id="6990" name="warn_impcast_single_bit_bitield_precision_constant">
        <segment>
          <source>implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1</source>
          <target>implicit truncation from {$arg2} to a one-bit wide bit-field changes value from {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6991" name="warn_impcast_string_literal_to_bool">
        <segment>
          <source>implicit conversion turns string literal into bool: %0 to %1</source>
          <target>implicit conversion turns string literal into bool: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6992" name="warn_impcast_unicode_char_type">
        <segment>
          <source>implicit conversion from %0 to %1 may change the meaning of the represented code unit</source>
          <target>implicit conversion from {$arg0} to {$arg1} may change the meaning of the represented code unit</target>
        </segment>
      </unit>
      <unit id="6993" name="warn_impcast_unicode_char_type_constant">
        <segment>
          <source>implicit conversion from %0 to %1 changes the meaning of the %select{code unit|code point}2 '%3'</source>
          <target>implicit conversion from {$arg0} to {$arg1} changes the meaning of the {$arg2 :select s0=|code unit| s1=|code point|} '{$arg3}'</target>
        </segment>
      </unit>
      <unit id="6994" name="warn_impcast_unicode_precision">
        <segment>
          <source>implicit conversion from %0 to %1 may lose precision and change the meaning of the represented code unit</source>
          <target>implicit conversion from {$arg0} to {$arg1} may lose precision and change the meaning of the represented code unit</target>
        </segment>
      </unit>
      <unit id="6995" name="warn_impcast_vector_scalar">
        <segment>
          <source>implicit conversion turns vector to scalar: %0 to %1</source>
          <target>implicit conversion turns vector to scalar: {$arg0} to {$arg1}</target>
        </segment>
      </unit>
      <unit id="6996" name="warn_impl_required_for_class_property">
        <segment>
          <source>class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation</source>
          <target>class property {$arg0} requires method {$arg1} to be defined - use @dynamic or provide a method implementation in this class implementation</target>
        </segment>
      </unit>
      <unit id="6997" name="warn_impl_required_in_category_for_class_property">
        <segment>
          <source>class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category</source>
          <target>class property {$arg0} requires method {$arg1} to be defined - use @dynamic or provide a method implementation in this category</target>
        </segment>
      </unit>
      <unit id="6998" name="warn_implements_nscopying">
        <segment>
          <source>default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]</source>
          <target>default assign attribute on property {$arg0} which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]</target>
        </segment>
      </unit>
      <unit id="6999" name="warn_implicit_atomic_property">
        <segment>
          <source>property is assumed atomic by default</source>
          <target>property is assumed atomic by default</target>
        </segment>
      </unit>
      <unit id="7000" name="warn_implicit_decl_no_jmp_buf">
        <segment>
          <source>declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header &lt;setjmp.h&gt;</source>
          <target>declaration of built-in function '{$arg0}' requires the declaration of the 'jmp_buf' type, commonly provided in the header &lt;setjmp.h&gt;</target>
        </segment>
      </unit>
      <unit id="7001" name="warn_implicit_decl_requires_sysheader">
        <segment>
          <source>declaration of built-in function '%1' requires inclusion of the header &lt;%0&gt;</source>
          <target>declaration of built-in function '{$arg1}' requires inclusion of the header &lt;{$arg0}&gt;</target>
        </segment>
      </unit>
      <unit id="7002" name="warn_implicit_function_decl">
        <segment>
          <source>implicit declaration of function %0</source>
          <target>implicit declaration of function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7003" name="warn_implicitly_retains_self">
        <segment>
          <source>block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior</source>
          <target>block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior</target>
        </segment>
      </unit>
      <unit id="7004" name="warn_import_implementation_partition_unit_in_interface_unit">
        <segment>
          <source>importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable</source>
          <target>importing an implementation partition unit in a module interface is not recommended. Names from {$arg0} may not be reachable</target>
        </segment>
      </unit>
      <unit id="7005" name="warn_import_on_definition">
        <segment>
          <source>import %select{module|name}0 cannot be applied to a function with a definition</source>
          <target>import {$arg0 :select s0=|module| s1=|name|} cannot be applied to a function with a definition</target>
        </segment>
      </unit>
      <unit id="7006" name="warn_inaccessible_base_class">
        <segment>
          <source>direct base %0 is inaccessible due to ambiguity:%1</source>
          <target>direct base {$arg0} is inaccessible due to ambiguity:{$arg1}</target>
        </segment>
      </unit>
      <unit id="7007" name="warn_incompatible_exception_specs">
        <segment>
          <source>target exception specification is not superset of source</source>
          <target>target exception specification is not superset of source</target>
        </segment>
      </unit>
      <unit id="7008" name="warn_incompatible_qualified_id">
        <segment>
          <source>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2</source>
          <target>%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2</target>
        </segment>
      </unit>
      <unit id="7009" name="warn_incompatible_vectors">
        <segment>
          <source>incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</source>
          <target>incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2</target>
        </segment>
      </unit>
      <unit id="7010" name="warn_incomplete_encoded_type">
        <segment>
          <source>encoding of %0 type is incomplete because %1 component has unknown encoding</source>
          <target>encoding of {$arg0} type is incomplete because {$arg1} component has unknown encoding</target>
        </segment>
      </unit>
      <unit id="7011" name="warn_inconsistent_array_form">
        <segment>
          <source>argument %0 of type %1 with mismatched bound</source>
          <target>argument {$arg0} of type {$arg1} with mismatched bound</target>
        </segment>
      </unit>
      <unit id="7012" name="warn_inconsistent_destructor_marked_not_override_overriding">
        <segment>
          <source>%0 overrides a destructor but is not marked 'override'</source>
          <target>{$arg0} overrides a destructor but is not marked 'override'</target>
        </segment>
      </unit>
      <unit id="7013" name="warn_inconsistent_function_marked_not_override_overriding">
        <segment>
          <source>%0 overrides a member function but is not marked 'override'</source>
          <target>{$arg0} overrides a member function but is not marked 'override'</target>
        </segment>
      </unit>
      <unit id="7014" name="warn_increment_bool">
        <segment>
          <source>incrementing expression of type bool is deprecated and incompatible with C++17</source>
          <target>incrementing expression of type bool is deprecated and incompatible with C++17</target>
        </segment>
      </unit>
      <unit id="7015" name="warn_independentclass_attribute">
        <segment>
          <source>'objc_independent_class' attribute may be put on a typedef only; attribute is ignored</source>
          <target>'objc_independent_class' attribute may be put on a typedef only; attribute is ignored</target>
        </segment>
      </unit>
      <unit id="7016" name="warn_indirection_through_null">
        <segment>
          <source>indirection of non-volatile null pointer will be deleted, not trap</source>
          <target>indirection of non-volatile null pointer will be deleted, not trap</target>
        </segment>
      </unit>
      <unit id="7017" name="warn_infinite_recursive_function">
        <segment>
          <source>all paths through this function will call itself</source>
          <target>all paths through this function will call itself</target>
        </segment>
      </unit>
      <unit id="7018" name="warn_init_list_constant_narrowing">
        <segment>
          <source>constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11</source>
          <target>constant expression evaluates to {$arg0} which cannot be narrowed to type {$arg1} in C++11</target>
        </segment>
      </unit>
      <unit id="7019" name="warn_init_list_type_narrowing">
        <segment>
          <source>type %0 cannot be narrowed to %1 in initializer list in C++11</source>
          <target>type {$arg0} cannot be narrowed to {$arg1} in initializer list in C++11</target>
        </segment>
      </unit>
      <unit id="7020" name="warn_init_list_variable_narrowing">
        <segment>
          <source>non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11</source>
          <target>non-constant-expression cannot be narrowed from type {$arg0} to {$arg1} in initializer list in C++11</target>
        </segment>
      </unit>
      <unit id="7021" name="warn_init_priority_reserved">
        <segment>
          <source>requested 'init_priority' %0 is reserved for internal use</source>
          <target>requested 'init_priority' {$arg0} is reserved for internal use</target>
        </segment>
      </unit>
      <unit id="7022" name="warn_init_ptr_member_to_parameter_addr">
        <segment>
          <source>initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1</source>
          <target>initializing pointer member {$arg0} with the stack address of {$arg2 :select s0=|variable| s1=|parameter|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="7023" name="warn_initializer_out_of_order">
        <segment>
          <source>%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3</source>
          <target>{$arg0 :select s0=|field| s1=|base class|} {$arg1} will be initialized after {$arg2 :select s0=|field| s1=|base|} {$arg3}</target>
        </segment>
      </unit>
      <unit id="7024" name="warn_initializer_overrides">
        <segment>
          <source>initializer %select{partially |}0overrides prior initialization of this subobject</source>
          <target>initializer {$arg0 :select s0=|partially | s1=||}overrides prior initialization of this subobject</target>
        </segment>
      </unit>
      <unit id="7025" name="warn_initializer_string_for_char_array_too_long_for_cpp">
        <segment>
          <source>initializer-string for character array is too long for C++, array size is %0 but initializer has size %1 (including the null terminating character)</source>
          <target>initializer-string for character array is too long for C++, array size is {$arg0} but initializer has size {$arg1} (including the null terminating character)</target>
        </segment>
      </unit>
      <unit id="7026" name="warn_initializer_string_for_char_array_too_long_no_nonstring">
        <segment>
          <source>initializer-string for character array is too long, array size is %0 but initializer has size %1 (including the null terminating character); did you mean to use the 'nonstring' attribute?</source>
          <target>initializer-string for character array is too long, array size is {$arg0} but initializer has size {$arg1} (including the null terminating character); did you mean to use the 'nonstring' attribute?</target>
        </segment>
      </unit>
      <unit id="7027" name="warn_inline_namespace_reopened_noninline">
        <segment>
          <source>inline namespace reopened as a non-inline namespace</source>
          <target>inline namespace reopened as a non-inline namespace</target>
        </segment>
      </unit>
      <unit id="7028" name="warn_inst_method_not_found">
        <segment>
          <source>instance method %objcinstance0 not found (return type defaults to 'id')</source>
          <target>instance method %objcinstance0 not found (return type defaults to 'id')</target>
        </segment>
      </unit>
      <unit id="7029" name="warn_instance_method_not_found_with_typo">
        <segment>
          <source>instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?</source>
          <target>instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?</target>
        </segment>
      </unit>
      <unit id="7030" name="warn_instance_method_on_class_found">
        <segment>
          <source>instance method %0 found instead of class method %1</source>
          <target>instance method {$arg0} found instead of class method {$arg1}</target>
        </segment>
      </unit>
      <unit id="7031" name="warn_int_to_pointer_cast">
        <segment>
          <source>cast to %1 from smaller integer type %0</source>
          <target>cast to {$arg1} from smaller integer type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7032" name="warn_int_to_void_pointer_cast">
        <segment>
          <source>cast to %1 from smaller integer type %0</source>
          <target>cast to {$arg1} from smaller integer type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7033" name="warn_integer_constants_in_conditional_always_true">
        <segment>
          <source>converting the result of '?:' with integer constants to a boolean always evaluates to 'true'</source>
          <target>converting the result of '?:' with integer constants to a boolean always evaluates to 'true'</target>
        </segment>
      </unit>
      <unit id="7034" name="warn_internal_linkage_local_storage">
        <segment>
          <source>'internal_linkage' attribute on a non-static local variable is ignored</source>
          <target>'internal_linkage' attribute on a non-static local variable is ignored</target>
        </segment>
      </unit>
      <unit id="7035" name="warn_interrupt_signal_attribute_invalid">
        <segment>
          <source>%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2</source>
          <target>{$arg0 :select s0=|MIPS| s1=|MSP430| s2=|RISC-V| s3=|AVR|} '{$arg1 :select s0=|interrupt| s1=|signal|}' attribute only applies to functions that have {$arg2 :select s0=|no parameters| s1=|a 'void' return type|}</target>
        </segment>
      </unit>
      <unit id="7036" name="warn_invalid_add_func_effects">
        <segment>
          <source>attribute '%0' should not be added via type conversion</source>
          <target>attribute '{$arg0}' should not be added via type conversion</target>
        </segment>
      </unit>
      <unit id="7037" name="warn_invalid_asm_cast_lvalue">
        <segment>
          <source state="initial">invalid use of a cast in an inline asm context requiring an lvalue</source>
          <target>invalid use of a cast in an inline asm context requiring an lvalue</target>
        </segment>
      </unit>
      <unit id="7038" name="warn_invalid_cpu_supports">
        <segment>
          <source>invalid cpu feature string for builtin</source>
          <target>invalid cpu feature string for builtin</target>
        </segment>
      </unit>
      <unit id="7039" name="warn_invalid_initializer_from_system_header">
        <segment>
          <source>invalid constructor from class in system header, should not be explicit</source>
          <target>invalid constructor from class in system header, should not be explicit</target>
        </segment>
      </unit>
      <unit id="7040" name="warn_invalid_specialization">
        <segment>
          <source>%0 cannot be specialized%select{|: %2}1</source>
          <target>{$arg0} cannot be specialized{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="7041" name="warn_ivar_use_hidden">
        <segment>
          <source>local declaration of %0 hides instance variable</source>
          <target>local declaration of {$arg0} hides instance variable</target>
        </segment>
      </unit>
      <unit id="7042" name="warn_ivars_in_interface">
        <segment>
          <source>declaration of instance variables in the interface is deprecated</source>
          <target>declaration of instance variables in the interface is deprecated</target>
        </segment>
      </unit>
      <unit id="7043" name="warn_jump_out_of_seh_finally">
        <segment>
          <source>jump out of __finally block has undefined behavior</source>
          <target>jump out of __finally block has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7044" name="warn_kern_is_inline">
        <segment>
          <source>ignored 'inline' attribute on kernel function %0</source>
          <target>ignored 'inline' attribute on kernel function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7045" name="warn_kern_is_method">
        <segment>
          <source>kernel function %0 is a member function; this may not be accepted by nvcc</source>
          <target>kernel function {$arg0} is a member function; this may not be accepted by nvcc</target>
        </segment>
      </unit>
      <unit id="7046" name="warn_left_shift_always">
        <segment>
          <source>converting the result of '&lt;&lt;' to a boolean always evaluates to %select{false|true}0</source>
          <target>converting the result of '&lt;&lt;' to a boolean always evaluates to {$arg0 :select s0=|false| s1=|true|}</target>
        </segment>
      </unit>
      <unit id="7047" name="warn_left_shift_in_bool_context">
        <segment>
          <source state="initial">converting the result of '&lt;&lt;' to a boolean; did you mean to compare with '0'?</source>
          <target>converting the result of '&lt;&lt;' to a boolean; did you mean to compare with '0'?</target>
        </segment>
      </unit>
      <unit id="7048" name="warn_lock_exclusive_and_shared">
        <segment>
          <source>%0 '%1' is acquired exclusively and shared in the same scope</source>
          <target>{$arg0} '{$arg1}' is acquired exclusively and shared in the same scope</target>
        </segment>
      </unit>
      <unit id="7049" name="warn_lock_some_predecessors">
        <segment>
          <source>%0 '%1' is not held on every path through here</source>
          <target>{$arg0} '{$arg1}' is not held on every path through here</target>
        </segment>
      </unit>
      <unit id="7050" name="warn_logical_and_in_logical_or">
        <segment>
          <source>'&amp;&amp;' within '||'</source>
          <target>'&amp;&amp;' within '||'</target>
        </segment>
      </unit>
      <unit id="7051" name="warn_logical_instead_of_bitwise">
        <segment>
          <source>use of logical '%0' with constant operand</source>
          <target>use of logical '{$arg0}' with constant operand</target>
        </segment>
      </unit>
      <unit id="7052" name="warn_logical_not_on_lhs_of_check">
        <segment>
          <source>logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0</source>
          <target>logical not is only applied to the left hand side of this {$arg0 :select s0=|comparison| s1=|bitwise operator|}</target>
        </segment>
      </unit>
      <unit id="7053" name="warn_loop_ctrl_binds_to_inner">
        <segment>
          <source>'%0' is bound to current loop, GCC binds it to the enclosing loop</source>
          <target>'{$arg0}' is bound to current loop, GCC binds it to the enclosing loop</target>
        </segment>
      </unit>
      <unit id="7054" name="warn_loop_state_mismatch">
        <segment>
          <source>state of variable '%0' must match at the entry and exit of loop</source>
          <target>state of variable '{$arg0}' must match at the entry and exit of loop</target>
        </segment>
      </unit>
      <unit id="7055" name="warn_main_one_arg">
        <segment>
          <source>only one parameter on 'main' declaration</source>
          <target>only one parameter on 'main' declaration</target>
        </segment>
      </unit>
      <unit id="7056" name="warn_main_redefined">
        <segment>
          <source>variable named 'main' with external linkage has undefined behavior</source>
          <target>variable named 'main' with external linkage has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7057" name="warn_main_returns_bool_literal">
        <segment>
          <source>bool literal returned from 'main'</source>
          <target>bool literal returned from 'main'</target>
        </segment>
      </unit>
      <unit id="7058" name="warn_max_unsigned_zero">
        <segment>
          <source>taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value</source>
          <target>taking the max of {$arg0 :select s0=|a value and unsigned zero| s1=|unsigned zero and a value|} is always equal to the other value</target>
        </segment>
      </unit>
      <unit id="7059" name="warn_maybe_capture_bad_target_this_ptr">
        <segment>
          <source>capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side</source>
          <target>capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side</target>
        </segment>
      </unit>
      <unit id="7060" name="warn_maybe_uninit_var">
        <segment>
          <source>variable %0 may be uninitialized when %select{used here|captured by block}1</source>
          <target>variable {$arg0} may be uninitialized when {$arg1 :select s0=|used here| s1=|captured by block|}</target>
        </segment>
      </unit>
      <unit id="7061" name="warn_maynot_respond">
        <segment>
          <source>%0 may not respond to %1</source>
          <target>{$arg0} may not respond to {$arg1}</target>
        </segment>
      </unit>
      <unit id="7062" name="warn_member_extra_qualification">
        <segment>
          <source>extra qualification on member %0</source>
          <target>extra qualification on member {$arg0}</target>
        </segment>
      </unit>
      <unit id="7063" name="warn_memsize_comparison">
        <segment>
          <source>size argument in %0 call is a comparison</source>
          <target>size argument in {$arg0} call is a comparison</target>
        </segment>
      </unit>
      <unit id="7064" name="warn_messaging_unqualified_id">
        <segment>
          <source>messaging unqualified id</source>
          <target>messaging unqualified id</target>
        </segment>
      </unit>
      <unit id="7065" name="warn_mig_server_routine_does_not_return_kern_return_t">
        <segment>
          <source>'mig_server_routine' attribute only applies to routines that return a kern_return_t</source>
          <target>'mig_server_routine' attribute only applies to routines that return a kern_return_t</target>
        </segment>
      </unit>
      <unit id="7066" name="warn_mismatched_availability">
        <segment>
          <source>availability does not match previous declaration</source>
          <target>availability does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="7067" name="warn_mismatched_availability_override">
        <segment>
          <source>%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)</source>
          <target>{$arg4 :select s0=|| s1=|overriding |}method {$arg0 :select s0=|introduced after| s1=|deprecated before| s2=|obsoleted before|} {$arg4 :select s0=|the protocol method it implements| s1=|overridden method|} on {$arg1} ({$arg2} vs. {$arg3})</target>
        </segment>
      </unit>
      <unit id="7068" name="warn_mismatched_availability_override_unavail">
        <segment>
          <source>%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available</source>
          <target>{$arg1 :select s0=|| s1=|overriding |}method cannot be unavailable on {$arg0} when {$arg1 :select s0=|the protocol method it implements| s1=|its overridden method|} is available</target>
        </segment>
      </unit>
      <unit id="7069" name="warn_mismatched_delete_new">
        <segment>
          <source>'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?</source>
          <target>'delete{$arg0 :select s0=|| s1=|[]|}' applied to a pointer that was allocated with 'new{$arg0 :select s0=|[]| s1=||}'; did you mean 'delete{$arg0 :select s0=|[]| s1=||}'?</target>
        </segment>
      </unit>
      <unit id="7070" name="warn_mismatched_func_effect_override">
        <segment>
          <source>attribute '%0' on overriding function does not match base declaration</source>
          <target>attribute '{$arg0}' on overriding function does not match base declaration</target>
        </segment>
      </unit>
      <unit id="7071" name="warn_mismatched_func_effect_redeclaration">
        <segment>
          <source>attribute '%0' on function does not match previous declaration</source>
          <target>attribute '{$arg0}' on function does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="7072" name="warn_mismatched_import">
        <segment>
          <source>import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration</source>
          <target>import {$arg0 :select s0=|module| s1=|name|} ({$arg1}) does not match the import {$arg0 :select s0=|module| s1=|name|} ({$arg2}) of the previous declaration</target>
        </segment>
      </unit>
      <unit id="7073" name="warn_mismatched_nullability_attr">
        <segment>
          <source>nullability specifier %0 conflicts with existing specifier %1</source>
          <target>nullability specifier {$arg0} conflicts with existing specifier {$arg1}</target>
        </segment>
      </unit>
      <unit id="7074" name="warn_mismatched_section">
        <segment>
          <source>%select{codeseg|section}0 does not match previous declaration</source>
          <target>{$arg0 :select s0=|codeseg| s1=|section|} does not match previous declaration</target>
        </segment>
      </unit>
      <unit id="7075" name="warn_missing_braces">
        <segment>
          <source>suggest braces around initialization of subobject</source>
          <target>suggest braces around initialization of subobject</target>
        </segment>
      </unit>
      <unit id="7076" name="warn_missing_case">
        <segment>
          <source>%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0</source>
          <target>%plural{1:enumeration value {$arg1} not handled in switch|2:enumeration values {$arg1} and {$arg2} not handled in switch|3:enumeration values {$arg1}, {$arg2}, and {$arg3} not handled in switch|:{$arg0} enumeration values not handled in switch: {$arg1}, {$arg2}, {$arg3}...}0</target>
        </segment>
      </unit>
      <unit id="7077" name="warn_missing_case_for_condition">
        <segment>
          <source>no case matching constant switch condition '%0'</source>
          <target>no case matching constant switch condition '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="7078" name="warn_missing_designated_field_initializers">
        <segment>
          <source>missing field %0 initializer</source>
          <target>missing field {$arg0} initializer</target>
        </segment>
      </unit>
      <unit id="7079" name="warn_missing_explicit_synthesis">
        <segment>
          <source>auto property synthesis is synthesizing property not explicitly synthesized</source>
          <target>auto property synthesis is synthesizing property not explicitly synthesized</target>
        </segment>
      </unit>
      <unit id="7080" name="warn_missing_field_initializers">
        <segment>
          <source>missing field %0 initializer</source>
          <target>missing field {$arg0} initializer</target>
        </segment>
      </unit>
      <unit id="7081" name="warn_missing_format_string">
        <segment>
          <source>format string missing</source>
          <target>format string missing</target>
        </segment>
      </unit>
      <unit id="7082" name="warn_missing_method_return_type">
        <segment>
          <source>method has no return type specified; defaults to 'id'</source>
          <target>method has no return type specified; defaults to 'id'</target>
        </segment>
      </unit>
      <unit id="7083" name="warn_missing_prototype">
        <segment>
          <source>no previous prototype for function %0</source>
          <target>no previous prototype for function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7084" name="warn_missing_sdksettings_for_availability_checking">
        <segment>
          <source>%0 availability is ignored without a valid 'SDKSettings.json' in the SDK</source>
          <target>{$arg0} availability is ignored without a valid 'SDKSettings.json' in the SDK</target>
        </segment>
      </unit>
      <unit id="7085" name="warn_missing_sentinel">
        <segment>
          <source>missing sentinel in %select{function call|method dispatch|block call}0</source>
          <target>missing sentinel in {$arg0 :select s0=|function call| s1=|method dispatch| s2=|block call|}</target>
        </segment>
      </unit>
      <unit id="7086" name="warn_missing_variable_declarations">
        <segment>
          <source>no previous extern declaration for non-static variable %0</source>
          <target>no previous extern declaration for non-static variable {$arg0}</target>
        </segment>
      </unit>
      <unit id="7087" name="warn_mixed_decls_code">
        <segment>
          <source>mixing declarations and code is incompatible with standards before C99</source>
          <target>mixing declarations and code is incompatible with standards before C99</target>
        </segment>
      </unit>
      <unit id="7088" name="warn_mixed_sign_comparison">
        <segment>
          <source>comparison of integers of different signs: %0 and %1</source>
          <target>comparison of integers of different signs: {$arg0} and {$arg1}</target>
        </segment>
      </unit>
      <unit id="7089" name="warn_modifying_shadowing_decl">
        <segment>
          <source>modifying constructor parameter %0 that shadows a field of %1</source>
          <target>modifying constructor parameter {$arg0} that shadows a field of {$arg1}</target>
        </segment>
      </unit>
      <unit id="7090" name="warn_ms_bitfield_mismatched_storage_packing">
        <segment>
          <source>bit-field %0 of type %1 has a different storage size than the preceding bit-field (%2 vs %3 bytes) and will not be packed under the Microsoft ABI</source>
          <target>bit-field {$arg0} of type {$arg1} has a different storage size than the preceding bit-field ({$arg2} vs {$arg3} bytes) and will not be packed under the Microsoft ABI</target>
        </segment>
      </unit>
      <unit id="7091" name="warn_ms_inline_non_function">
        <segment>
          <source>'inline' can only appear on functions%select{| and non-local variables}0</source>
          <target>'inline' can only appear on functions{$arg0 :select s0=|| s1=| and non-local variables|}</target>
        </segment>
      </unit>
      <unit id="7092" name="warn_multiple_method_decl">
        <segment>
          <source>multiple methods named %0 found</source>
          <target>multiple methods named {$arg0} found</target>
        </segment>
      </unit>
      <unit id="7093" name="warn_multiple_selectors">
        <segment>
          <source>several methods with selector %0 of mismatched types are found for the @selector expression</source>
          <target>several methods with selector {$arg0} of mismatched types are found for the @selector expression</target>
        </segment>
      </unit>
      <unit id="7094" name="warn_multiversion_duplicate_entries">
        <segment>
          <source>CPU list contains duplicate entries; attribute ignored</source>
          <target>CPU list contains duplicate entries; attribute ignored</target>
        </segment>
      </unit>
      <unit id="7095" name="warn_musttail_local_temp_addr_ref">
        <segment>
          <source>passing %select{address of|reference to}0 local temporary object to musttail function</source>
          <target>passing {$arg0 :select s0=|address of| s1=|reference to|} local temporary object to musttail function</target>
        </segment>
      </unit>
      <unit id="7096" name="warn_namespace_member_extra_qualification">
        <segment>
          <source>extra qualification on member %0</source>
          <target>extra qualification on member {$arg0}</target>
        </segment>
      </unit>
      <unit id="7097" name="warn_neon_vector_initializer_non_portable">
        <segment>
          <source>vector initializers are not compatible with NEON intrinsics in big endian mode</source>
          <target>vector initializers are not compatible with NEON intrinsics in big endian mode</target>
        </segment>
      </unit>
      <unit id="7098" name="warn_new_dangling_initializer_list">
        <segment>
          <source>array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression</source>
          <target>array backing {$arg0 :select s0=|initializer list subobject of the allocated object| s1=|the allocated initializer list|} will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="7099" name="warn_new_dangling_reference">
        <segment>
          <source>temporary bound to reference member of allocated object will be destroyed at the end of the full-expression</source>
          <target>temporary bound to reference member of allocated object will be destroyed at the end of the full-expression</target>
        </segment>
      </unit>
      <unit id="7100" name="warn_no_autosynthesis_property">
        <segment>
          <source>auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property</source>
          <target>auto property synthesis will not synthesize property {$arg0} because it is 'readwrite' but it will be synthesized 'readonly' via another property</target>
        </segment>
      </unit>
      <unit id="7101" name="warn_no_autosynthesis_shared_ivar_property">
        <segment>
          <source>auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property</source>
          <target>auto property synthesis will not synthesize property {$arg0} because it cannot share an ivar with another synthesized property</target>
        </segment>
      </unit>
      <unit id="7102" name="warn_no_constructor_for_refconst">
        <segment>
          <source>%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members</source>
          <target>{$arg0 :select s0=|struct| s1=|interface| s2=|union| s3=|class| s4=|enum|} {$arg1} does not declare any constructor to initialize its non-modifiable members</target>
        </segment>
      </unit>
      <unit id="7103" name="warn_no_dynamic_cast_with_rtti_disabled">
        <segment>
          <source>dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0</source>
          <target>dynamic_cast will not work since RTTI data is disabled by {$arg0 :select s0=|-fno-rtti-data| s1=|/GR-|}</target>
        </segment>
      </unit>
      <unit id="7104" name="warn_no_typeid_with_rtti_disabled">
        <segment>
          <source>typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0</source>
          <target>typeid will not work since RTTI data is disabled by {$arg0 :select s0=|-fno-rtti-data| s1=|/GR-|}</target>
        </segment>
      </unit>
      <unit id="7105" name="warn_no_underlying_type_specified_for_enum_bitfield">
        <segment>
          <source>enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable</source>
          <target>enums in the Microsoft ABI are signed integers by default; consider giving the enum {$arg0} an unsigned underlying type to make this code portable</target>
        </segment>
      </unit>
      <unit id="7106" name="warn_no_unlock">
        <segment>
          <source>%0 '%1' is still held at the end of function</source>
          <target>{$arg0} '{$arg1}' is still held at the end of function</target>
        </segment>
      </unit>
      <unit id="7107" name="warn_nocf_check_attribute_ignored">
        <segment>
          <source>'nocf_check' attribute ignored; use -fcf-protection to enable the attribute</source>
          <target>'nocf_check' attribute ignored; use -fcf-protection to enable the attribute</target>
        </segment>
      </unit>
      <unit id="7108" name="warn_noderef_on_non_pointer_or_array">
        <segment>
          <source>'noderef' can only be used on an array or pointer type</source>
          <target>'noderef' can only be used on an array or pointer type</target>
        </segment>
      </unit>
      <unit id="7109" name="warn_noderef_to_dereferenceable_pointer">
        <segment>
          <source>casting to dereferenceable pointer removes 'noderef' attribute</source>
          <target>casting to dereferenceable pointer removes 'noderef' attribute</target>
        </segment>
      </unit>
      <unit id="7110" name="warn_non_aligned_allocation_function">
        <segment>
          <source>under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function</source>
          <target>under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type {$arg0} has higher precedence than the global aligned allocation function</target>
        </segment>
      </unit>
      <unit id="7111" name="warn_non_contravariant_overriding_param_types">
        <segment>
          <source>conflicting parameter types in declaration of %0: %1 vs %2</source>
          <target>conflicting parameter types in declaration of {$arg0}: {$arg1} vs {$arg2}</target>
        </segment>
      </unit>
      <unit id="7112" name="warn_non_contravariant_param_types">
        <segment>
          <source>conflicting parameter types in implementation of %0: %1 vs %2</source>
          <target>conflicting parameter types in implementation of {$arg0}: {$arg1} vs {$arg2}</target>
        </segment>
      </unit>
      <unit id="7113" name="warn_non_covariant_overriding_ret_types">
        <segment>
          <source>conflicting return type in declaration of %0: %1 vs %2</source>
          <target>conflicting return type in declaration of {$arg0}: {$arg1} vs {$arg2}</target>
        </segment>
      </unit>
      <unit id="7114" name="warn_non_covariant_ret_types">
        <segment>
          <source>conflicting return type in implementation of %0: %1 vs %2</source>
          <target>conflicting return type in implementation of {$arg0}: {$arg1} vs {$arg2}</target>
        </segment>
      </unit>
      <unit id="7115" name="warn_non_literal_null_pointer">
        <segment>
          <source>expression which evaluates to zero treated as a null pointer constant of type %0</source>
          <target>expression which evaluates to zero treated as a null pointer constant of type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7116" name="warn_non_pod_vararg_with_format_string">
        <segment>
          <source>cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3</source>
          <target>cannot pass {$arg0 :select s0=|non-POD| s1=|non-trivial|} object of type {$arg1} to variadic {$arg2 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}; expected type from format string was {$arg3}</target>
        </segment>
      </unit>
      <unit id="7117" name="warn_non_prototype_changes_behavior">
        <segment>
          <source>a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1</source>
          <target>a function {$arg0 :select s0=|declaration| s1=|definition|} without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a {$arg2 :select s0=|previous| s1=|subsequent|} {$arg1 :select s0=|declaration| s1=|definition}3|}</target>
        </segment>
      </unit>
      <unit id="7118" name="warn_non_virtual_dtor">
        <segment>
          <source>%0 has virtual functions but non-virtual destructor</source>
          <target>{$arg0} has virtual functions but non-virtual destructor</target>
        </segment>
      </unit>
      <unit id="7119" name="warn_nonnull_expr_compare">
        <segment>
          <source>comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter</source>
          <target>comparison of nonnull {$arg0 :select s0=|function call| s1=|parameter|} '{$arg1}' {$arg2 :select s0=|not | s1=||}equal to a null pointer is '{$arg2 :select s0=|true| s1=|false|}' on first encounter</target>
        </segment>
      </unit>
      <unit id="7120" name="warn_noreturn_coroutine">
        <segment>
          <source>coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle</source>
          <target>coroutine {$arg0} cannot be declared 'noreturn' as it always returns a coroutine handle</target>
        </segment>
      </unit>
      <unit id="7121" name="warn_noreturn_function_has_return_expr">
        <segment>
          <source>function %0 declared 'noreturn' should not return</source>
          <target>function {$arg0} declared 'noreturn' should not return</target>
        </segment>
      </unit>
      <unit id="7122" name="warn_noreturn_has_return_expr">
        <segment>
          <source>%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return</source>
          <target>{$arg0 :select s0=|function| s1=|block| s2=|lambda| s3=|coroutine|} declared 'noreturn' should not return</target>
        </segment>
      </unit>
      <unit id="7123" name="warn_not_a_doxygen_trailing_member_comment">
        <segment>
          <source>not a Doxygen trailing comment</source>
          <target>not a Doxygen trailing comment</target>
        </segment>
      </unit>
      <unit id="7124" name="warn_not_compound_assign">
        <segment>
          <source>use of unary operator that may be intended as compound assignment (%0=)</source>
          <target>use of unary operator that may be intended as compound assignment ({$arg0}=)</target>
        </segment>
      </unit>
      <unit id="7125" name="warn_not_eliding_copy_on_return">
        <segment>
          <source>not eliding copy on return</source>
          <target>not eliding copy on return</target>
        </segment>
      </unit>
      <unit id="7126" name="warn_not_enough_argument">
        <segment>
          <source>not enough variable arguments in %0 declaration to fit a sentinel</source>
          <target>not enough variable arguments in {$arg0} declaration to fit a sentinel</target>
        </segment>
      </unit>
      <unit id="7127" name="warn_not_in_enum">
        <segment>
          <source>case value not in enumerated type %0</source>
          <target>case value not in enumerated type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7128" name="warn_not_in_enum_assignment">
        <segment>
          <source>integer constant not in range of enumerated type %0</source>
          <target>integer constant not in range of enumerated type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7129" name="warn_not_xl_compatible">
        <segment>
          <source>alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older</source>
          <target>alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older</target>
        </segment>
      </unit>
      <unit id="7130" name="warn_nothrow_attribute_ignored">
        <segment>
          <source>'nothrow' attribute conflicts with exception specification; attribute ignored</source>
          <target>'nothrow' attribute conflicts with exception specification; attribute ignored</target>
        </segment>
      </unit>
      <unit id="7131" name="warn_ns_attribute_wrong_parameter_type">
        <segment>
          <source>%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters</source>
          <target>{$arg0} attribute only applies to {$arg1 :select s0=|Objective-C object| s1=|pointer| s2=|pointer-to-CF-pointer| s3=|pointer/reference-to-OSObject-pointer|} parameters</target>
        </segment>
      </unit>
      <unit id="7132" name="warn_ns_attribute_wrong_return_type">
        <segment>
          <source>%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2</source>
          <target>{$arg0} attribute only applies to {$arg1 :select s0=|functions| s1=|methods| s2=|properties|} that return {$arg2 :select s0=|an Objective-C object| s1=|a pointer| s2=|a non-retainable pointer|}</target>
        </segment>
      </unit>
      <unit id="7133" name="warn_nsconsumed_attribute_mismatch">
        <segment>
          <source>overriding method has mismatched ns_consumed attribute on its parameter</source>
          <target>overriding method has mismatched ns_consumed attribute on its parameter</target>
        </segment>
      </unit>
      <unit id="7134" name="warn_nsdictionary_duplicate_key">
        <segment>
          <source>duplicate key in dictionary literal</source>
          <target>duplicate key in dictionary literal</target>
        </segment>
      </unit>
      <unit id="7135" name="warn_nsobject_attribute">
        <segment>
          <source>'NSObject' attribute may be put on a typedef only; attribute is ignored</source>
          <target>'NSObject' attribute may be put on a typedef only; attribute is ignored</target>
        </segment>
      </unit>
      <unit id="7136" name="warn_nsreturns_retained_attribute_mismatch">
        <segment>
          <source>overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes</source>
          <target>overriding method has mismatched ns_returns_{$arg0 :select s0=|not_retained| s1=|retained|} attributes</target>
        </segment>
      </unit>
      <unit id="7137" name="warn_null_arg">
        <segment>
          <source>null passed to a callee that requires a non-null argument</source>
          <target>null passed to a callee that requires a non-null argument</target>
        </segment>
      </unit>
      <unit id="7138" name="warn_null_in_arithmetic_operation">
        <segment>
          <source>use of NULL in arithmetic operation</source>
          <target>use of NULL in arithmetic operation</target>
        </segment>
      </unit>
      <unit id="7139" name="warn_null_in_comparison_operation">
        <segment>
          <source>comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0</source>
          <target>comparison between NULL and non-pointer {$arg0 :select s0=|({$arg1} and NULL)| s1=|(NULL and {$arg1})|}</target>
        </segment>
      </unit>
      <unit id="7140" name="warn_null_pointer_compare">
        <segment>
          <source>comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2</source>
          <target>comparison of {$arg0 :select s0=|address of| s1=|function| s2=|array|} '{$arg1}' {$arg2 :select s0=|not | s1=||}equal to a null pointer is always {$arg2 :select s0=|true| s1=|false|}</target>
        </segment>
      </unit>
      <unit id="7141" name="warn_null_resettable_setter">
        <segment>
          <source>synthesized setter %0 for null_resettable property %1 does not handle nil</source>
          <target>synthesized setter {$arg0} for null_resettable property {$arg1} does not handle nil</target>
        </segment>
      </unit>
      <unit id="7142" name="warn_null_ret">
        <segment>
          <source>null returned from %select{function|method}0 that requires a non-null return value</source>
          <target>null returned from {$arg0 :select s0=|function| s1=|method|} that requires a non-null return value</target>
        </segment>
      </unit>
      <unit id="7143" name="warn_nullability_declspec">
        <segment>
          <source>nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?</source>
          <target>nullability specifier {$arg0} cannot be applied to non-pointer type {$arg1}; did you mean to apply the specifier to the {$arg2 :select s0=|pointer| s1=|block pointer| s2=|member pointer| s3=|function pointer| s4=|member function pointer|}?</target>
        </segment>
      </unit>
      <unit id="7144" name="warn_nullability_inferred_on_nested_type">
        <segment>
          <source>inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated</source>
          <target>inferring '_Nonnull' for pointer type within {$arg0 :select s0=|array| s1=|reference|} is deprecated</target>
        </segment>
      </unit>
      <unit id="7145" name="warn_nullability_lost">
        <segment>
          <source>implicit conversion from nullable pointer %0 to non-nullable pointer type %1</source>
          <target>implicit conversion from nullable pointer {$arg0} to non-nullable pointer type {$arg1}</target>
        </segment>
      </unit>
      <unit id="7146" name="warn_nullability_missing">
        <segment>
          <source>%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)</source>
          <target>{$arg0 :select s0=|pointer| s1=|block pointer| s2=|member pointer|} is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)</target>
        </segment>
      </unit>
      <unit id="7147" name="warn_nullability_missing_array">
        <segment>
          <source>array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)</source>
          <target>array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)</target>
        </segment>
      </unit>
      <unit id="7148" name="warn_objc_boxing_invalid_utf8_string">
        <segment>
          <source>string is ill-formed as UTF-8 and will become a null %0 when boxed</source>
          <target>string is ill-formed as UTF-8 and will become a null {$arg0} when boxed</target>
        </segment>
      </unit>
      <unit id="7149" name="warn_objc_cdirective_format_string">
        <segment>
          <source>using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2</source>
          <target>using {$arg0} directive in {$arg1 :select s0=|NSString| s1=|CFString|} which is being passed as a formatting argument to the formatting {$arg2 :select s0=|method| s1=|CFfunction|}</target>
        </segment>
      </unit>
      <unit id="7150" name="warn_objc_circular_container">
        <segment>
          <source>adding %0 to %1 might cause circular dependency in container</source>
          <target>adding {$arg0} to {$arg1} might cause circular dependency in container</target>
        </segment>
      </unit>
      <unit id="7151" name="warn_objc_collection_literal_element">
        <segment>
          <source>object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2</source>
          <target>object of type {$arg0} is not compatible with {$arg1 :select s0=|array element type| s1=|dictionary key type| s2=|dictionary value type|} {$arg2}</target>
        </segment>
      </unit>
      <unit id="7152" name="warn_objc_designated_init_missing_super_call">
        <segment>
          <source>designated initializer missing a 'super' call to a designated initializer of the super class</source>
          <target>designated initializer missing a 'super' call to a designated initializer of the super class</target>
        </segment>
      </unit>
      <unit id="7153" name="warn_objc_designated_init_non_designated_init_call">
        <segment>
          <source>designated initializer invoked a non-designated initializer</source>
          <target>designated initializer invoked a non-designated initializer</target>
        </segment>
      </unit>
      <unit id="7154" name="warn_objc_designated_init_non_super_designated_init_call">
        <segment>
          <source>designated initializer should only invoke a designated initializer on 'super'</source>
          <target>designated initializer should only invoke a designated initializer on 'super'</target>
        </segment>
      </unit>
      <unit id="7155" name="warn_objc_direct_ignored">
        <segment>
          <source>%0 attribute isn't implemented by this Objective-C runtime</source>
          <target>{$arg0} attribute isn't implemented by this Objective-C runtime</target>
        </segment>
      </unit>
      <unit id="7156" name="warn_objc_direct_property_ignored">
        <segment>
          <source>direct attribute on property %0 ignored (not implemented by this Objective-C runtime)</source>
          <target>direct attribute on property {$arg0} ignored (not implemented by this Objective-C runtime)</target>
        </segment>
      </unit>
      <unit id="7157" name="warn_objc_implementation_missing_designated_init_override">
        <segment>
          <source>method override for the designated initializer of the superclass %objcinstance0 not found</source>
          <target>method override for the designated initializer of the superclass %objcinstance0 not found</target>
        </segment>
      </unit>
      <unit id="7158" name="warn_objc_invalid_bridge">
        <segment>
          <source>%0 bridges to %1, not %2</source>
          <target>{$arg0} bridges to {$arg1}, not {$arg2}</target>
        </segment>
      </unit>
      <unit id="7159" name="warn_objc_invalid_bridge_to_cf">
        <segment>
          <source>%0 cannot bridge to %1</source>
          <target>{$arg0} cannot bridge to {$arg1}</target>
        </segment>
      </unit>
      <unit id="7160" name="warn_objc_isa_assign">
        <segment>
          <source>assignment to Objective-C's isa is deprecated in favor of object_setClass()</source>
          <target>assignment to Objective-C's isa is deprecated in favor of object_setClass()</target>
        </segment>
      </unit>
      <unit id="7161" name="warn_objc_isa_use">
        <segment>
          <source>direct access to Objective-C's isa is deprecated in favor of object_getClass()</source>
          <target>direct access to Objective-C's isa is deprecated in favor of object_getClass()</target>
        </segment>
      </unit>
      <unit id="7162" name="warn_objc_literal_comparison">
        <segment>
          <source>direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior</source>
          <target>direct comparison of {$arg0 :select s0=|an array literal| s1=|a dictionary literal| s2=|a numeric literal| s3=|a boxed expression| s4=||} has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7163" name="warn_objc_missing_super_call">
        <segment>
          <source>method possibly missing a [super %0] call</source>
          <target>method possibly missing a [super {$arg0}] call</target>
        </segment>
      </unit>
      <unit id="7164" name="warn_objc_pointer_cxx_catch_fragile">
        <segment>
          <source>cannot catch an exception thrown with @throw in C++ in the non-unified exception model</source>
          <target>cannot catch an exception thrown with @throw in C++ in the non-unified exception model</target>
        </segment>
      </unit>
      <unit id="7165" name="warn_objc_pointer_masking">
        <segment>
          <source>bitmasking for introspection of Objective-C object pointers is strongly discouraged</source>
          <target>bitmasking for introspection of Objective-C object pointers is strongly discouraged</target>
        </segment>
      </unit>
      <unit id="7166" name="warn_objc_pointer_masking_performSelector">
        <segment>
          <source>bitmasking for introspection of Objective-C object pointers is strongly discouraged</source>
          <target>bitmasking for introspection of Objective-C object pointers is strongly discouraged</target>
        </segment>
      </unit>
      <unit id="7167" name="warn_objc_precise_lifetime_meaningless">
        <segment>
          <source>objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects</source>
          <target>objc_precise_lifetime is not meaningful for {$arg0 :select s0=|__unsafe_unretained| s1=|__autoreleasing|} objects</target>
        </segment>
      </unit>
      <unit id="7168" name="warn_objc_property_assign_on_object">
        <segment>
          <source>'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'</source>
          <target>'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'</target>
        </segment>
      </unit>
      <unit id="7169" name="warn_objc_property_copy_missing_on_block">
        <segment>
          <source>'copy' attribute must be specified for the block property when -fobjc-gc-only is specified</source>
          <target>'copy' attribute must be specified for the block property when -fobjc-gc-only is specified</target>
        </segment>
      </unit>
      <unit id="7170" name="warn_objc_property_default_assign_on_object">
        <segment>
          <source>default property attribute 'assign' not appropriate for object</source>
          <target>default property attribute 'assign' not appropriate for object</target>
        </segment>
      </unit>
      <unit id="7171" name="warn_objc_property_no_assignment_attribute">
        <segment>
          <source>no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed</source>
          <target>no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed</target>
        </segment>
      </unit>
      <unit id="7172" name="warn_objc_property_retain_of_block">
        <segment>
          <source>retain'ed block property does not copy the block - use copy attribute instead</source>
          <target>retain'ed block property does not copy the block - use copy attribute instead</target>
        </segment>
      </unit>
      <unit id="7173" name="warn_objc_readonly_property_has_setter">
        <segment>
          <source>setter cannot be specified for a readonly property</source>
          <target>setter cannot be specified for a readonly property</target>
        </segment>
      </unit>
      <unit id="7174" name="warn_objc_redundant_literal_use">
        <segment>
          <source>using %0 with a literal is redundant</source>
          <target>using {$arg0} with a literal is redundant</target>
        </segment>
      </unit>
      <unit id="7175" name="warn_objc_redundant_qualified_class_type">
        <segment>
          <source>parameterized class %0 already conforms to the protocols listed; did you forget a '*'?</source>
          <target>parameterized class {$arg0} already conforms to the protocols listed; did you forget a '*'?</target>
        </segment>
      </unit>
      <unit id="7176" name="warn_objc_requires_super_protocol">
        <segment>
          <source>%0 attribute cannot be applied to %select{methods in protocols|dealloc}1</source>
          <target>{$arg0} attribute cannot be applied to {$arg1 :select s0=|methods in protocols| s1=|dealloc|}</target>
        </segment>
      </unit>
      <unit id="7177" name="warn_objc_root_class_missing">
        <segment>
          <source>class %0 defined without specifying a base class</source>
          <target>class {$arg0} defined without specifying a base class</target>
        </segment>
      </unit>
      <unit id="7178" name="warn_objc_secondary_init_missing_init_call">
        <segment>
          <source>convenience initializer missing a 'self' call to another initializer</source>
          <target>convenience initializer missing a 'self' call to another initializer</target>
        </segment>
      </unit>
      <unit id="7179" name="warn_objc_secondary_init_super_init_call">
        <segment>
          <source>convenience initializer should not invoke an initializer on 'super'</source>
          <target>convenience initializer should not invoke an initializer on 'super'</target>
        </segment>
      </unit>
      <unit id="7180" name="warn_objc_string_literal_comparison">
        <segment>
          <source>direct comparison of a string literal has undefined behavior</source>
          <target>direct comparison of a string literal has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7181" name="warn_objc_unsafe_perform_selector">
        <segment>
          <source>%0 is incompatible with selectors that return a %select{struct|union|vector}1 type</source>
          <target>{$arg0} is incompatible with selectors that return a {$arg1 :select s0=|struct| s1=|union| s2=|vector|} type</target>
        </segment>
      </unit>
      <unit id="7182" name="warn_offload_incompatible_redeclare">
        <segment>
          <source>target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function</source>
          <target>target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is {$arg0 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function, old declaration is {$arg1 :select s0=|__device__| s1=|__global__| s2=|__host__| s3=|__host__ __device__|} function</target>
        </segment>
      </unit>
      <unit id="7183" name="warn_old_style_cast">
        <segment>
          <source>use of old-style cast</source>
          <target>use of old-style cast</target>
        </segment>
      </unit>
      <unit id="7184" name="warn_omp_alignment_not_power_of_two">
        <segment>
          <source>aligned clause will be ignored because the requested alignment is not a power of 2</source>
          <target>aligned clause will be ignored because the requested alignment is not a power of 2</target>
        </segment>
      </unit>
      <unit id="7185" name="warn_omp_allocate_thread_on_task_target_directive">
        <segment>
          <source>allocator with the 'thread' trait access has unspecified behavior on '%0' directive</source>
          <target>allocator with the 'thread' trait access has unspecified behavior on '{$arg0}' directive</target>
        </segment>
      </unit>
      <unit id="7186" name="warn_omp_assume_attribute_string_unknown">
        <segment>
          <source>unknown assumption string '%0'; attribute is potentially ignored</source>
          <target>unknown assumption string '{$arg0}'; attribute is potentially ignored</target>
        </segment>
      </unit>
      <unit id="7187" name="warn_omp_assume_attribute_string_unknown_suggested">
        <segment>
          <source>unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?</source>
          <target>unknown assumption string '{$arg0}' may be misspelled; attribute is potentially ignored, did you mean '{$arg1}'?</target>
        </segment>
      </unit>
      <unit id="7188" name="warn_omp_declare_target_after_first_use">
        <segment>
          <source>declaration marked as declare target after first use, it may lead to incorrect results</source>
          <target>declaration marked as declare target after first use, it may lead to incorrect results</target>
        </segment>
      </unit>
      <unit id="7189" name="warn_omp_declare_variant_after_emitted">
        <segment>
          <source>'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used</source>
          <target>'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used</target>
        </segment>
      </unit>
      <unit id="7190" name="warn_omp_declare_variant_after_used">
        <segment>
          <source>'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used</source>
          <target>'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used</target>
        </segment>
      </unit>
      <unit id="7191" name="warn_omp_declare_variant_marked_as_declare_variant">
        <segment>
          <source>variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'</source>
          <target>variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'</target>
        </segment>
      </unit>
      <unit id="7192" name="warn_omp_declare_variant_score_not_constant">
        <segment>
          <source>score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored</source>
          <target>score expressions in the OpenMP context selector need to be constant; {$arg0} is not and will be ignored</target>
        </segment>
      </unit>
      <unit id="7193" name="warn_omp_linear_step_zero">
        <segment>
          <source>zero linear step (%0 %select{|and other variables in clause }1should probably be const)</source>
          <target>zero linear step ({$arg0} {$arg1 :select s0=|| s1=|and other variables in clause |}should probably be const)</target>
        </segment>
      </unit>
      <unit id="7194" name="warn_omp_loop_64_bit_var">
        <segment>
          <source>OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed</source>
          <target>OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed</target>
        </segment>
      </unit>
      <unit id="7195" name="warn_omp_minus_in_reduction_deprecated">
        <segment>
          <source>minus(-) operator for reductions is deprecated; use + or user defined reduction instead</source>
          <target>minus(-) operator for reductions is deprecated; use + or user defined reduction instead</target>
        </segment>
      </unit>
      <unit id="7196" name="warn_omp_nesting_simd">
        <segment>
          <source>OpenMP only allows an ordered construct with the simd clause nested in a simd construct</source>
          <target>OpenMP only allows an ordered construct with the simd clause nested in a simd construct</target>
        </segment>
      </unit>
      <unit id="7197" name="warn_omp_non_trivial_type_mapped">
        <segment>
          <source>type %0 is not trivially copyable and not guaranteed to be mapped correctly</source>
          <target>type {$arg0} is not trivially copyable and not guaranteed to be mapped correctly</target>
        </segment>
      </unit>
      <unit id="7198" name="warn_omp_not_in_target_context">
        <segment>
          <source>declaration is not declared in any declare target region</source>
          <target>declaration is not declared in any declare target region</target>
        </segment>
      </unit>
      <unit id="7199" name="warn_omp_section_is_char">
        <segment>
          <source>array section %select{lower bound|length}0 is of type 'char'</source>
          <target>array section {$arg0 :select s0=|lower bound| s1=|length|} is of type 'char'</target>
        </segment>
      </unit>
      <unit id="7200" name="warn_omp_unterminated_declare_target">
        <segment>
          <source>expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'</source>
          <target>expected '#pragma omp end declare target' at end of file to match '#pragma omp {$arg0}'</target>
        </segment>
      </unit>
      <unit id="7201" name="warn_omp_used_different_allocator">
        <segment>
          <source>allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2</source>
          <target>allocate directive specifies {$arg0 :select s0=|default| s1=|'{$arg1}'|} allocator while previously used {$arg2 :select s0=|default| s1=|'{$arg3}'|}</target>
        </segment>
      </unit>
      <unit id="7202" name="warn_on_superclass_use">
        <segment>
          <source>class implementation may not have super class</source>
          <target>class implementation may not have super class</target>
        </segment>
      </unit>
      <unit id="7203" name="warn_opencl_attr_deprecated_ignored">
        <segment>
          <source>%0 attribute is deprecated and ignored in %1</source>
          <target>{$arg0} attribute is deprecated and ignored in {$arg1}</target>
        </segment>
      </unit>
      <unit id="7204" name="warn_opencl_generic_address_space_arg">
        <segment>
          <source>passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance</source>
          <target>passing non-generic address space pointer to {$arg0} may cause dynamic conversion affecting performance</target>
        </segment>
      </unit>
      <unit id="7205" name="warn_operator_new_returns_null">
        <segment>
          <source>%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1</source>
          <target>{$arg0} should not return a null pointer unless it is declared 'throw()'{$arg1 :select s0=|| s1=| or 'noexcept'|}</target>
        </segment>
      </unit>
      <unit id="7206" name="warn_os_log_format_narg">
        <segment>
          <source>os_log() '%%n' format specifier is not allowed</source>
          <target>os_log() '%n' format specifier is not allowed</target>
        </segment>
      </unit>
      <unit id="7207" name="warn_out_of_range_compare">
        <segment>
          <source>result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4</source>
          <target>result of comparison of {$arg1 :select s0=|constant {$arg0}| s1=|true| s2=|false|} with {$arg3 :select s0=|expression of type {$arg2}| s1=|boolean expression|} is always {$arg4}</target>
        </segment>
      </unit>
      <unit id="7208" name="warn_overaligned_type">
        <segment>
          <source>type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes</source>
          <target>type {$arg0} requires {$arg1} bytes of alignment and the default allocator only guarantees {$arg2} bytes</target>
        </segment>
      </unit>
      <unit id="7209" name="warn_overloaded_shift_in_comparison">
        <segment>
          <source>overloaded operator %select{&gt;&gt;|&lt;&lt;}0 has higher precedence than comparison operator</source>
          <target>overloaded operator {$arg0 :select s0=|&gt;&gt;| s1=|&lt;&lt;|} has higher precedence than comparison operator</target>
        </segment>
      </unit>
      <unit id="7210" name="warn_overloaded_virtual">
        <segment>
          <source>%q0 hides overloaded virtual %select{function|functions}1</source>
          <target>{$arg0 :q} hides overloaded virtual {$arg1 :select s0=|function| s1=|functions|}</target>
        </segment>
      </unit>
      <unit id="7211" name="warn_overriding_method_missing_noescape">
        <segment>
          <source>parameter of overriding method should be annotated with __attribute__((noescape))</source>
          <target>parameter of overriding method should be annotated with __attribute__((noescape))</target>
        </segment>
      </unit>
      <unit id="7212" name="warn_param_mismatched_alignment">
        <segment>
          <source>passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access</source>
          <target>passing {$arg0}-byte aligned argument to {$arg1}-byte aligned parameter {$arg2}{$arg3 :select s0=|| s1=| of {$arg4}|} may result in an unaligned pointer access</target>
        </segment>
      </unit>
      <unit id="7213" name="warn_param_return_typestate_mismatch">
        <segment>
          <source>parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'</source>
          <target>parameter '{$arg0}' not in expected state when the function returns: expected '{$arg1}', observed '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="7214" name="warn_param_typestate_mismatch">
        <segment>
          <source>argument not in expected state; expected '%0', observed '%1'</source>
          <target>argument not in expected state; expected '{$arg0}', observed '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="7215" name="warn_parameter_size">
        <segment>
          <source>%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?</source>
          <target>{$arg0} is a large ({$arg1} bytes) pass-by-value argument; pass it by reference instead ?</target>
        </segment>
      </unit>
      <unit id="7216" name="warn_parens_disambiguated_as_function_declaration">
        <segment>
          <source>parentheses were disambiguated as a function declaration</source>
          <target>parentheses were disambiguated as a function declaration</target>
        </segment>
      </unit>
      <unit id="7217" name="warn_parens_disambiguated_as_variable_declaration">
        <segment>
          <source>parentheses were disambiguated as redundant parentheses around declaration of variable named %0</source>
          <target>parentheses were disambiguated as redundant parentheses around declaration of variable named {$arg0}</target>
        </segment>
      </unit>
      <unit id="7218" name="warn_pass_class_arg_to_vararg">
        <segment>
          <source>passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2</source>
          <target>passing object of class type {$arg0} through variadic {$arg1 :select s0=|function| s1=|block| s2=|method| s3=|constructor|}{$arg2 :select s0=|| s1=|; did you mean to call '{$arg3}'?|}</target>
        </segment>
      </unit>
      <unit id="7219" name="warn_perf_constraint_implies_noexcept">
        <segment>
          <source>%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept</source>
          <target>{$arg0 :select s0=|function| s1=|constructor| s2=|destructor| s3=|lambda| s4=|block|} with '{$arg1}' attribute should be declared noexcept</target>
        </segment>
      </unit>
      <unit id="7220" name="warn_pessimizing_move_on_initialization">
        <segment>
          <source>moving a temporary object prevents copy elision</source>
          <target>moving a temporary object prevents copy elision</target>
        </segment>
      </unit>
      <unit id="7221" name="warn_pessimizing_move_on_return">
        <segment>
          <source>moving a local object in a return statement prevents copy elision</source>
          <target>moving a local object in a return statement prevents copy elision</target>
        </segment>
      </unit>
      <unit id="7222" name="warn_pointer_abs">
        <segment>
          <source>taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious</source>
          <target>taking the absolute value of {$arg0 :select s0=|pointer| s1=|function| s2=|array|} type {$arg1} is suspicious</target>
        </segment>
      </unit>
      <unit id="7223" name="warn_pointer_arith_null_ptr">
        <segment>
          <source>performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0</source>
          <target>performing pointer arithmetic on a null pointer has undefined behavior{$arg0 :select s0=|| s1=| if the offset is nonzero|}</target>
        </segment>
      </unit>
      <unit id="7224" name="warn_pointer_compare">
        <segment>
          <source>comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?</source>
          <target>comparing a pointer to a null character constant; did you mean to compare to {$arg0 :select s0=|NULL| s1=|(void *)0|}?</target>
        </segment>
      </unit>
      <unit id="7225" name="warn_pointer_indirection_from_incompatible_type">
        <segment>
          <source>dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior</source>
          <target>dereference of type {$arg1} that was reinterpret_cast from type {$arg0} has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7226" name="warn_pointer_sub_null_ptr">
        <segment>
          <source>performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior</source>
          <target>performing pointer subtraction with a null pointer {$arg0 :select s0=|has| s1=|may have|} undefined behavior</target>
        </segment>
      </unit>
      <unit id="7227" name="warn_pointer_to_enum_cast">
        <segment>
          <source>cast to smaller integer type %1 from %0</source>
          <target>cast to smaller integer type {$arg1} from {$arg0}</target>
        </segment>
      </unit>
      <unit id="7228" name="warn_pointer_to_int_cast">
        <segment>
          <source>cast to smaller integer type %1 from %0</source>
          <target>cast to smaller integer type {$arg1} from {$arg0}</target>
        </segment>
      </unit>
      <unit id="7229" name="warn_possible_object_duplication_init">
        <segment>
          <source>initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage</source>
          <target>initialization of {$arg0} may run twice when built into a shared library: it has hidden visibility and external linkage</target>
        </segment>
      </unit>
      <unit id="7230" name="warn_possible_object_duplication_mutable">
        <segment>
          <source>%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage</source>
          <target>{$arg0} may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage</target>
        </segment>
      </unit>
      <unit id="7231" name="warn_potentially_direct_selector_expression">
        <segment>
          <source>@selector expression formed with potentially direct selector %0</source>
          <target>@selector expression formed with potentially direct selector {$arg0}</target>
        </segment>
      </unit>
      <unit id="7232" name="warn_pragma_align_not_xl_compatible">
        <segment>
          <source>#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++</source>
          <target>#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++</target>
        </segment>
      </unit>
      <unit id="7233" name="warn_pragma_attribute_unused">
        <segment>
          <source>unused attribute %0 in '#pragma clang attribute push' region</source>
          <target>unused attribute {$arg0} in '#pragma clang attribute push' region</target>
        </segment>
      </unit>
      <unit id="7234" name="warn_pragma_options_align_reset_failed">
        <segment>
          <source>#pragma options align=reset failed: %0</source>
          <target>#pragma options align=reset failed: {$arg0}</target>
        </segment>
      </unit>
      <unit id="7235" name="warn_pragma_pack_invalid_alignment">
        <segment>
          <source>expected #pragma pack parameter to be '1', '2', '4', '8', or '16'</source>
          <target>expected #pragma pack parameter to be '1', '2', '4', '8', or '16'</target>
        </segment>
      </unit>
      <unit id="7236" name="warn_pragma_pack_modified_after_include">
        <segment>
          <source>the current #pragma pack alignment value is modified in the included file</source>
          <target>the current #pragma pack alignment value is modified in the included file</target>
        </segment>
      </unit>
      <unit id="7237" name="warn_pragma_pack_no_pop_eof">
        <segment>
          <source>unterminated '#pragma pack (push, ...)' at end of file</source>
          <target>unterminated '#pragma pack (push, ...)' at end of file</target>
        </segment>
      </unit>
      <unit id="7238" name="warn_pragma_pack_non_default_at_include">
        <segment>
          <source>non-default #pragma pack value changes the alignment of struct or union members in the included file</source>
          <target>non-default #pragma pack value changes the alignment of struct or union members in the included file</target>
        </segment>
      </unit>
      <unit id="7239" name="warn_pragma_pack_pop_identifier_and_alignment">
        <segment>
          <source>specifying both a name and alignment to 'pop' is undefined</source>
          <target>specifying both a name and alignment to 'pop' is undefined</target>
        </segment>
      </unit>
      <unit id="7240" name="warn_pragma_pack_show">
        <segment>
          <source>value of #pragma pack(show) == %0</source>
          <target>value of #pragma pack(show) == {$arg0}</target>
        </segment>
      </unit>
      <unit id="7241" name="warn_pragma_pop_failed">
        <segment>
          <source>#pragma %0(pop, ...) failed: %1</source>
          <target>#pragma {$arg0}(pop, ...) failed: {$arg1}</target>
        </segment>
      </unit>
      <unit id="7242" name="warn_pragma_unused_expected_var_arg">
        <segment>
          <source>only variables can be arguments to '#pragma unused'</source>
          <target>only variables can be arguments to '#pragma unused'</target>
        </segment>
      </unit>
      <unit id="7243" name="warn_pragma_unused_undeclared_var">
        <segment>
          <source>undeclared variable %0 used as an argument for '#pragma unused'</source>
          <target>undeclared variable {$arg0} used as an argument for '#pragma unused'</target>
        </segment>
      </unit>
      <unit id="7244" name="warn_precedence_bitwise_conditional">
        <segment>
          <source>operator '?:' has lower precedence than '%0'; '%0' will be evaluated first</source>
          <target>operator '?:' has lower precedence than '{$arg0}'; '{$arg0}' will be evaluated first</target>
        </segment>
      </unit>
      <unit id="7245" name="warn_precedence_bitwise_rel">
        <segment>
          <source>%0 has lower precedence than %1; %1 will be evaluated first</source>
          <target>{$arg0} has lower precedence than {$arg1}; {$arg1} will be evaluated first</target>
        </segment>
      </unit>
      <unit id="7246" name="warn_precedence_conditional">
        <segment>
          <source>operator '?:' has lower precedence than '%0'; '%0' will be evaluated first</source>
          <target>operator '?:' has lower precedence than '{$arg0}'; '{$arg0}' will be evaluated first</target>
        </segment>
      </unit>
      <unit id="7247" name="warn_preferred_type_bitfield_too_small_for_enum">
        <segment>
          <source>bit-field %0 is not wide enough to store all enumerators of preferred type %1</source>
          <target>bit-field {$arg0} is not wide enough to store all enumerators of preferred type {$arg1}</target>
        </segment>
      </unit>
      <unit id="7248" name="warn_preferred_type_signed_bitfield_enum_conversion">
        <segment>
          <source>signed bit-field %0 needs an extra bit to represent the largest positive enumerators of preferred type %1</source>
          <target>signed bit-field {$arg0} needs an extra bit to represent the largest positive enumerators of preferred type {$arg1}</target>
        </segment>
      </unit>
      <unit id="7249" name="warn_preferred_type_unsigned_bitfield_assigned_signed_enum">
        <segment>
          <source>assigning value of preferred signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values</source>
          <target>assigning value of preferred signed enum type {$arg1} to unsigned bit-field {$arg0}; negative enumerators of enum {$arg1} will be converted to positive values</target>
        </segment>
      </unit>
      <unit id="7250" name="warn_printf_ObjCflags_without_ObjCConversion">
        <segment>
          <source>object format flags cannot be used with '%0' conversion specifier</source>
          <target>object format flags cannot be used with '{$arg0}' conversion specifier</target>
        </segment>
      </unit>
      <unit id="7251" name="warn_printf_asterisk_missing_arg">
        <segment>
          <source>'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument</source>
          <target>'{$arg0 :select s0=|*| s1=|.*|}' specified field {$arg0 :select s0=|width| s1=|precision|} is missing a matching 'int' argument</target>
        </segment>
      </unit>
      <unit id="7252" name="warn_printf_asterisk_wrong_type">
        <segment>
          <source>field %select{width|precision}0 should have type %1, but argument has type %2</source>
          <target>field {$arg0 :select s0=|width| s1=|precision|} should have type {$arg1}, but argument has type {$arg2}</target>
        </segment>
      </unit>
      <unit id="7253" name="warn_printf_data_arg_not_used">
        <segment>
          <source>data argument not used by format string</source>
          <target>data argument not used by format string</target>
        </segment>
      </unit>
      <unit id="7254" name="warn_printf_empty_objc_flag">
        <segment>
          <source>missing object format flag</source>
          <target>missing object format flag</target>
        </segment>
      </unit>
      <unit id="7255" name="warn_printf_format_string_contains_null_char">
        <segment>
          <source>format string contains '\0' within the string body</source>
          <target>format string contains '\\0' within the string body</target>
        </segment>
      </unit>
      <unit id="7256" name="warn_printf_format_string_not_null_terminated">
        <segment>
          <source>format string is not null-terminated</source>
          <target>format string is not null-terminated</target>
        </segment>
      </unit>
      <unit id="7257" name="warn_printf_ignored_flag">
        <segment>
          <source>flag '%0' is ignored when flag '%1' is present</source>
          <target>flag '{$arg0}' is ignored when flag '{$arg1}' is present</target>
        </segment>
      </unit>
      <unit id="7258" name="warn_printf_incomplete_specifier">
        <segment>
          <source>incomplete format specifier</source>
          <target>incomplete format specifier</target>
        </segment>
      </unit>
      <unit id="7259" name="warn_printf_insufficient_data_args">
        <segment>
          <source>more '%%' conversions than data arguments</source>
          <target>more '%' conversions than data arguments</target>
        </segment>
      </unit>
      <unit id="7260" name="warn_printf_invalid_objc_flag">
        <segment>
          <source>'%0' is not a valid object format flag</source>
          <target>'{$arg0}' is not a valid object format flag</target>
        </segment>
      </unit>
      <unit id="7261" name="warn_printf_narg_not_supported">
        <segment>
          <source>'%%n' specifier not supported on this platform</source>
          <target>'%n' specifier not supported on this platform</target>
        </segment>
      </unit>
      <unit id="7262" name="warn_printf_nonsensical_flag">
        <segment>
          <source>flag '%0' results in undefined behavior with '%1' conversion specifier</source>
          <target>flag '{$arg0}' results in undefined behavior with '{$arg1}' conversion specifier</target>
        </segment>
      </unit>
      <unit id="7263" name="warn_printf_nonsensical_optional_amount">
        <segment>
          <source>%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior</source>
          <target>{$arg0 :select s0=|field width| s1=|precision|} used with '{$arg1}' conversion specifier, resulting in undefined behavior</target>
        </segment>
      </unit>
      <unit id="7264" name="warn_printf_positional_arg_exceeds_data_args">
        <segment>
          <source>data argument position '%0' exceeds the number of data arguments (%1)</source>
          <target>data argument position '{$arg0}' exceeds the number of data arguments ({$arg1})</target>
        </segment>
      </unit>
      <unit id="7265" name="warn_private_extern">
        <segment>
          <source>use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated</source>
          <target>use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated</target>
        </segment>
      </unit>
      <unit id="7266" name="warn_property_access_suggest">
        <segment>
          <source>property %0 not found on object of type %1; did you mean to access property %2?</source>
          <target>property {$arg0} not found on object of type {$arg1}; did you mean to access property {$arg2}?</target>
        </segment>
      </unit>
      <unit id="7267" name="warn_property_attr_mismatch">
        <segment>
          <source>property attribute in class extension does not match the primary class</source>
          <target>property attribute in class extension does not match the primary class</target>
        </segment>
      </unit>
      <unit id="7268" name="warn_property_attribute">
        <segment>
          <source>'%1' attribute on property %0 does not match the property inherited from %2</source>
          <target>'{$arg1}' attribute on property {$arg0} does not match the property inherited from {$arg2}</target>
        </segment>
      </unit>
      <unit id="7269" name="warn_property_getter_owning_mismatch">
        <segment>
          <source>property declared as returning non-retained objects; getter returning retained objects</source>
          <target>property declared as returning non-retained objects; getter returning retained objects</target>
        </segment>
      </unit>
      <unit id="7270" name="warn_property_implicitly_mismatched">
        <segment>
          <source>primary property declaration is implicitly strong while redeclaration in class extension is weak</source>
          <target>primary property declaration is implicitly strong while redeclaration in class extension is weak</target>
        </segment>
      </unit>
      <unit id="7271" name="warn_property_method_deprecated">
        <segment>
          <source>property access is using %0 method which is deprecated</source>
          <target>property access is using {$arg0} method which is deprecated</target>
        </segment>
      </unit>
      <unit id="7272" name="warn_property_redecl_getter_mismatch">
        <segment>
          <source>getter name mismatch between property redeclaration (%1) and its original declaration (%0)</source>
          <target>getter name mismatch between property redeclaration ({$arg1}) and its original declaration ({$arg0})</target>
        </segment>
      </unit>
      <unit id="7273" name="warn_property_types_are_incompatible">
        <segment>
          <source>property type %0 is incompatible with type %1 inherited from %2</source>
          <target>property type {$arg0} is incompatible with type {$arg1} inherited from {$arg2}</target>
        </segment>
      </unit>
      <unit id="7274" name="warn_protocol_property_mismatch">
        <segment>
          <source>property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis</source>
          <target>property {$arg0 :select s0=|of type {$arg1}| s1=|with attribute '{$arg1}'| s2=|without attribute '{$arg1}'| s3=|with getter {$arg1}| s4=|with setter {$arg1}|} was selected for synthesis</target>
        </segment>
      </unit>
      <unit id="7275" name="warn_pt_guarded_pass_by_reference">
        <segment>
          <source>passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>passing the value that {$arg1} points to by reference requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7276" name="warn_pt_guarded_pass_pointer">
        <segment>
          <source>passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>passing pointer {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7277" name="warn_pt_guarded_return_by_reference">
        <segment>
          <source>returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>returning the value that {$arg1} points to by reference requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7278" name="warn_pt_guarded_return_pointer">
        <segment>
          <source>returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>returning pointer {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7279" name="warn_ptr_arith_exceeds_bounds">
        <segment>
          <source>the pointer incremented by %0 refers past the end of the array (that has type %1)</source>
          <target>the pointer incremented by {$arg0} refers past the end of the array (that has type {$arg1})</target>
        </segment>
      </unit>
      <unit id="7280" name="warn_ptr_arith_exceeds_max_addressable_bounds">
        <segment>
          <source>the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)</source>
          <target>the pointer incremented by {$arg0} refers past the last possible element for an array in {$arg1}-bit address space containing {$arg2}-bit ({$arg3}-byte) elements (max possible {$arg4} element%s5)</target>
        </segment>
      </unit>
      <unit id="7281" name="warn_ptr_arith_precedes_bounds">
        <segment>
          <source>the pointer decremented by %0 refers before the beginning of the array</source>
          <target>the pointer decremented by {$arg0} refers before the beginning of the array</target>
        </segment>
      </unit>
      <unit id="7282" name="warn_ptr_independentclass_attribute">
        <segment>
          <source>'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored</source>
          <target>'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored</target>
        </segment>
      </unit>
      <unit id="7283" name="warn_ptrauth_auth_null_pointer">
        <segment>
          <source>authenticating a null pointer will almost certainly trap</source>
          <target>authenticating a null pointer will almost certainly trap</target>
        </segment>
      </unit>
      <unit id="7284" name="warn_ptrauth_sign_null_pointer">
        <segment>
          <source>signing a null pointer will yield a non-null pointer</source>
          <target>signing a null pointer will yield a non-null pointer</target>
        </segment>
      </unit>
      <unit id="7285" name="warn_pure_function_returns_void">
        <segment>
          <source>'%select{pure|const}0' attribute on function returning 'void'; attribute ignored</source>
          <target>'{$arg0 :select s0=|pure| s1=|const|}' attribute on function returning 'void'; attribute ignored</target>
        </segment>
      </unit>
      <unit id="7286" name="warn_qual_base_type">
        <segment>
          <source state="initial">'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect</source>
          <target>'{$arg0}' qualifier%s1 on base class type {$arg2} %plural{1:has|:have}1 no effect</target>
        </segment>
      </unit>
      <unit id="7287" name="warn_qual_return_type">
        <segment>
          <source>'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect</source>
          <target>'{$arg0}' type qualifier%s1 on return type %plural{1:has|:have}1 no effect</target>
        </segment>
      </unit>
      <unit id="7288" name="warn_readonly_property">
        <segment>
          <source>attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1</source>
          <target>attribute 'readonly' of property {$arg0} restricts attribute 'readwrite' of property inherited from {$arg1}</target>
        </segment>
      </unit>
      <unit id="7289" name="warn_receiver_forward_class">
        <segment>
          <source>receiver %0 is a forward class and corresponding @interface may not exist</source>
          <target>receiver {$arg0} is a forward class and corresponding @interface may not exist</target>
        </segment>
      </unit>
      <unit id="7290" name="warn_receiver_forward_instance">
        <segment>
          <source>receiver type %0 for instance message is a forward declaration</source>
          <target>receiver type {$arg0} for instance message is a forward declaration</target>
        </segment>
      </unit>
      <unit id="7291" name="warn_redecl_library_builtin">
        <segment>
          <source>incompatible redeclaration of library function %0</source>
          <target>incompatible redeclaration of library function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7292" name="warn_redeclaration_without_attribute_prev_attribute_ignored">
        <segment>
          <source>%q0 redeclared without %1 attribute: previous %1 ignored</source>
          <target>{$arg0 :q} redeclared without {$arg1} attribute: previous {$arg1} ignored</target>
        </segment>
      </unit>
      <unit id="7293" name="warn_redeclaration_without_import_attribute">
        <segment>
          <source>%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added</source>
          <target>{$arg0 :q} redeclared without 'dllimport' attribute: 'dllexport' attribute added</target>
        </segment>
      </unit>
      <unit id="7294" name="warn_redefine_extname_not_applied">
        <segment>
          <source>#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1</source>
          <target>#pragma redefine_extname is applicable to external C declarations only; not applied to {$arg0 :select s0=|function| s1=|variable|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="7295" name="warn_redefinition_in_param_list">
        <segment>
          <source>redefinition of %0 will not be visible outside of this function</source>
          <target>redefinition of {$arg0} will not be visible outside of this function</target>
        </segment>
      </unit>
      <unit id="7296" name="warn_redundant_loop_iteration">
        <segment>
          <source>variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body</source>
          <target>variable {$arg0} is {$arg1 :select s0=|decremented| s1=|incremented|} both in the loop header and in the loop body</target>
        </segment>
      </unit>
      <unit id="7297" name="warn_redundant_move_on_return">
        <segment>
          <source>redundant move in return statement</source>
          <target>redundant move in return statement</target>
        </segment>
      </unit>
      <unit id="7298" name="warn_redundant_parens_around_declarator">
        <segment>
          <source>redundant parentheses surrounding declarator</source>
          <target>redundant parentheses surrounding declarator</target>
        </segment>
      </unit>
      <unit id="7299" name="warn_reference_field_is_uninit">
        <segment>
          <source>reference %0 is not yet bound to a value when used here</source>
          <target>reference {$arg0} is not yet bound to a value when used here</target>
        </segment>
      </unit>
      <unit id="7300" name="warn_register_objc_catch_parm">
        <segment>
          <source>'register' storage specifier on @catch parameter will be ignored</source>
          <target>'register' storage specifier on @catch parameter will be ignored</target>
        </segment>
      </unit>
      <unit id="7301" name="warn_reinterpret_different_from_static">
        <segment>
          <source>'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'</source>
          <target>'reinterpret_cast' {$arg3 :select s0=|from| s1=|to|} class {$arg0} {$arg3 :select s0=|to| s1=|from|} its {$arg2 :select s0=|virtual base| s1=|base at non-zero offset|} {$arg1} behaves differently from 'static_cast'</target>
        </segment>
      </unit>
      <unit id="7302" name="warn_related_result_type_compatibility_class">
        <segment>
          <source>method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1</source>
          <target>method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1</target>
        </segment>
      </unit>
      <unit id="7303" name="warn_related_result_type_compatibility_protocol">
        <segment>
          <source>protocol method is expected to return an instance of the implementing class, but is declared to return %0</source>
          <target>protocol method is expected to return an instance of the implementing class, but is declared to return {$arg0}</target>
        </segment>
      </unit>
      <unit id="7304" name="warn_remainder_division_by_zero">
        <segment>
          <source>%select{remainder|division}0 by zero is undefined</source>
          <target>{$arg0 :select s0=|remainder| s1=|division|} by zero is undefined</target>
        </segment>
      </unit>
      <unit id="7305" name="warn_require_const_init_added_too_late">
        <segment>
          <source>'require_constant_initialization' attribute added after initialization of variable</source>
          <target>'require_constant_initialization' attribute added after initialization of variable</target>
        </segment>
      </unit>
      <unit id="7306" name="warn_reserved_extern_symbol">
        <segment>
          <source>identifier %0 is reserved because %select{&lt;ERROR&gt;|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1</source>
          <target>identifier {$arg0} is reserved because {$arg1 :select s0=|&lt;ERROR&gt;| s1=|it starts with '_' at global scope| s2=|it starts with '_' and has C language linkage| s3=|it starts with '__'| s4=|it starts with '_' followed by a capital letter| s5=|it contains '__'|}</target>
        </segment>
      </unit>
      <unit id="7307" name="warn_reserved_module_name">
        <segment>
          <source>%0 is a reserved name for a module</source>
          <target>{$arg0} is a reserved name for a module</target>
        </segment>
      </unit>
      <unit id="7308" name="warn_ret_addr_label">
        <segment>
          <source>returning address of label, which is local</source>
          <target>returning address of label, which is local</target>
        </segment>
      </unit>
      <unit id="7309" name="warn_ret_local_temp_addr_ref">
        <segment>
          <source>returning %select{address of|reference to}0 local temporary object</source>
          <target>returning {$arg0 :select s0=|address of| s1=|reference to|} local temporary object</target>
        </segment>
      </unit>
      <unit id="7310" name="warn_ret_stack_addr_ref">
        <segment>
          <source state="initial">%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3</source>
          <target>{$arg0 :select s0=|address of| s1=|reference to|} stack memory associated with {$arg2 :select s0=|local variable| s1=|parameter| s2=|compound literal|} {$arg1} {$arg3 :select s0=|returned| s1=|passed to musttail function|}</target>
        </segment>
      </unit>
      <unit id="7311" name="warn_return_missing_expr">
        <segment>
          <source>non-void %select{function|method}1 %0 should return a value</source>
          <target>non-void {$arg1 :select s0=|function| s1=|method|} {$arg0} should return a value</target>
        </segment>
      </unit>
      <unit id="7312" name="warn_return_typestate_for_unconsumable_type">
        <segment>
          <source>return state set for an unconsumable type '%0'</source>
          <target>return state set for an unconsumable type '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="7313" name="warn_return_typestate_mismatch">
        <segment>
          <source>return value not in expected state; expected '%0', observed '%1'</source>
          <target>return value not in expected state; expected '{$arg0}', observed '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="7314" name="warn_return_value_size">
        <segment>
          <source>return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?</source>
          <target>return value of {$arg0} is a large ({$arg1} bytes) pass-by-value object; pass it by reference instead ?</target>
        </segment>
      </unit>
      <unit id="7315" name="warn_return_value_udt">
        <segment>
          <source>%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C</source>
          <target>{$arg0} has C-linkage specified, but returns user-defined type {$arg1} which is incompatible with C</target>
        </segment>
      </unit>
      <unit id="7316" name="warn_return_value_udt_incomplete">
        <segment>
          <source>%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C</source>
          <target>{$arg0} has C-linkage specified, but returns incomplete type {$arg1} which could be incompatible with C</target>
        </segment>
      </unit>
      <unit id="7317" name="warn_riscv_repeated_interrupt_attribute">
        <segment>
          <source>repeated RISC-V 'interrupt' attribute</source>
          <target>repeated RISC-V 'interrupt' attribute</target>
        </segment>
      </unit>
      <unit id="7318" name="warn_root_inst_method_not_found">
        <segment>
          <source>instance method %0 is being used on 'Class' which is not in the root class</source>
          <target>instance method {$arg0} is being used on 'Class' which is not in the root class</target>
        </segment>
      </unit>
      <unit id="7319" name="warn_sampler_initializer_invalid_bits">
        <segment>
          <source>sampler initializer has invalid %0 bits</source>
          <target>sampler initializer has invalid {$arg0} bits</target>
        </segment>
      </unit>
      <unit id="7320" name="warn_scanf_nonzero_width">
        <segment>
          <source>zero field width in scanf format string is unused</source>
          <target>zero field width in scanf format string is unused</target>
        </segment>
      </unit>
      <unit id="7321" name="warn_scanf_scanlist_incomplete">
        <segment>
          <source>no closing ']' for '%%[' in scanf format string</source>
          <target>no closing ']' for '%[' in scanf format string</target>
        </segment>
      </unit>
      <unit id="7322" name="warn_second_arg_of_va_start_not_last_non_variadic_param">
        <segment>
          <source>second argument to 'va_start' is not the last non-variadic parameter</source>
          <target>second argument to 'va_start' is not the last non-variadic parameter</target>
        </segment>
      </unit>
      <unit id="7323" name="warn_second_parameter_to_va_arg_array">
        <segment>
          <source>second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type</source>
          <target>second argument to 'va_arg' is of array type {$arg0}; this va_arg has undefined behavior because arguments will never be compatible with array type</target>
        </segment>
      </unit>
      <unit id="7324" name="warn_second_parameter_to_va_arg_never_compatible">
        <segment>
          <source>second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1</source>
          <target>second argument to 'va_arg' is of promotable type {$arg0}; this va_arg has undefined behavior because arguments will be promoted to {$arg1}</target>
        </segment>
      </unit>
      <unit id="7325" name="warn_second_parameter_to_va_arg_not_pod">
        <segment>
          <source>second argument to 'va_arg' is of non-POD type %0</source>
          <target>second argument to 'va_arg' is of non-POD type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7326" name="warn_second_parameter_to_va_arg_ownership_qualified">
        <segment>
          <source>second argument to 'va_arg' is of ARC ownership-qualified type %0</source>
          <target>second argument to 'va_arg' is of ARC ownership-qualified type {$arg0}</target>
        </segment>
      </unit>
      <unit id="7327" name="warn_section_msvc_compat">
        <segment>
          <source>`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2</source>
          <target>`#pragma const_seg` for section {$arg1} will not apply to {$arg0} due to the presence of a {$arg2 :select s0=|mutable field| s1=|| s2=|non-trivial constructor| s3=|non-trivial destructor|}</target>
        </segment>
      </unit>
      <unit id="7328" name="warn_self_assignment_builtin">
        <segment>
          <source>explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1</source>
          <target>explicitly assigning value of variable of type {$arg0} to itself{$arg1 :select s0=|| s1=|; did you mean to assign to member {$arg2}?|}</target>
        </segment>
      </unit>
      <unit id="7329" name="warn_self_assignment_overloaded">
        <segment>
          <source>explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1</source>
          <target>explicitly assigning value of variable of type {$arg0} to itself{$arg1 :select s0=|| s1=|; did you mean to assign to member {$arg2}?|}</target>
        </segment>
      </unit>
      <unit id="7330" name="warn_self_move">
        <segment>
          <source>explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1</source>
          <target>explicitly moving variable of type {$arg0} to itself{$arg1 :select s0=|| s1=|; did you mean to move to member {$arg2}?|}</target>
        </segment>
      </unit>
      <unit id="7331" name="warn_setter_getter_impl_required">
        <segment>
          <source>property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation</source>
          <target>property {$arg0} requires method {$arg1} to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation</target>
        </segment>
      </unit>
      <unit id="7332" name="warn_setter_getter_impl_required_in_category">
        <segment>
          <source>property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category</source>
          <target>property {$arg0} requires method {$arg1} to be defined - use @dynamic or provide a method implementation in this category</target>
        </segment>
      </unit>
      <unit id="7333" name="warn_shadow_field">
        <segment>
          <source>%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2</source>
          <target>{$arg3 :select s0=|parameter| s1=|non-static data member|} {$arg0} {$arg3 :select s0=|| s1=|of {$arg1} |}shadows member inherited from type {$arg2}</target>
        </segment>
      </unit>
      <unit id="7334" name="warn_shift_bool">
        <segment>
          <source>right shifting a 'bool' implicitly converts it to 'int'</source>
          <target>right shifting a 'bool' implicitly converts it to 'int'</target>
        </segment>
      </unit>
      <unit id="7335" name="warn_shift_gt_typewidth">
        <segment>
          <source>shift count &gt;= width of type</source>
          <target>shift count &gt;= width of type</target>
        </segment>
      </unit>
      <unit id="7336" name="warn_shift_lhs_negative">
        <segment>
          <source>shifting a negative signed value is undefined</source>
          <target>shifting a negative signed value is undefined</target>
        </segment>
      </unit>
      <unit id="7337" name="warn_shift_negative">
        <segment>
          <source>shift count is negative</source>
          <target>shift count is negative</target>
        </segment>
      </unit>
      <unit id="7338" name="warn_shift_result_gt_typewidth">
        <segment>
          <source>signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits</source>
          <target>signed shift result ({$arg0}) requires {$arg1} bits to represent, but {$arg2} only has {$arg3} bits</target>
        </segment>
      </unit>
      <unit id="7339" name="warn_shift_result_sets_sign_bit">
        <segment>
          <source>signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative</source>
          <target>signed shift result ({$arg0}) sets the sign bit of the shift expression's type ({$arg1}) and becomes negative</target>
        </segment>
      </unit>
      <unit id="7340" name="warn_side_effects_typeid">
        <segment>
          <source>expression with side effects will be evaluated despite being used as an operand to 'typeid'</source>
          <target>expression with side effects will be evaluated despite being used as an operand to 'typeid'</target>
        </segment>
      </unit>
      <unit id="7341" name="warn_side_effects_unevaluated_context">
        <segment>
          <source>expression with side effects has no effect in an unevaluated context</source>
          <target>expression with side effects has no effect in an unevaluated context</target>
        </segment>
      </unit>
      <unit id="7342" name="warn_signed_bitfield_enum_conversion">
        <segment>
          <source>signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1</source>
          <target>signed bit-field {$arg0} needs an extra bit to represent the largest positive enumerators of {$arg1}</target>
        </segment>
      </unit>
      <unit id="7343" name="warn_sizeof_array_decay">
        <segment>
          <source>sizeof on pointer operation will return size of %0 instead of %1</source>
          <target>sizeof on pointer operation will return size of {$arg0} instead of {$arg1}</target>
        </segment>
      </unit>
      <unit id="7344" name="warn_sizeof_array_param">
        <segment>
          <source>sizeof on array function parameter will return size of %0 instead of %1</source>
          <target>sizeof on array function parameter will return size of {$arg0} instead of {$arg1}</target>
        </segment>
      </unit>
      <unit id="7345" name="warn_sizeof_pointer_expr_memaccess">
        <segment>
          <source>'%0' call operates on objects of type %1 while the size is based on a different type %2</source>
          <target>'{$arg0}' call operates on objects of type {$arg1} while the size is based on a different type {$arg2}</target>
        </segment>
      </unit>
      <unit id="7346" name="warn_sizeof_pointer_expr_memaccess_note">
        <segment>
          <source>did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?</source>
          <target>did you mean to {$arg0 :select s0=|dereference the argument to 'sizeof' (and multiply it by the number of elements)| s1=|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)| s2=|provide an explicit length|}?</target>
        </segment>
      </unit>
      <unit id="7347" name="warn_sizeof_pointer_type_memaccess">
        <segment>
          <source>argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length</source>
          <target>argument to 'sizeof' in {$arg0} call is the same pointer type {$arg1} as the {$arg2 :select s0=|destination| s1=|source|}; expected {$arg3} or an explicit length</target>
        </segment>
      </unit>
      <unit id="7348" name="warn_sme_locally_streaming_has_vl_args_returns">
        <segment>
          <source>%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime</source>
          <target>{$arg0 :select s0=|returning| s1=|passing|} a VL-dependent argument {$arg0 :select s0=|from| s1=|to|} a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime</target>
        </segment>
      </unit>
      <unit id="7349" name="warn_sme_streaming_pass_return_vl_to_non_streaming">
        <segment>
          <source>%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime</source>
          <target>{$arg0 :select s0=|returning| s1=|passing|} a VL-dependent argument {$arg0 :select s0=|from| s1=|to|} a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime</target>
        </segment>
      </unit>
      <unit id="7350" name="warn_some_initializers_out_of_order">
        <segment>
          <source>initializer order does not match the declaration order</source>
          <target>initializer order does not match the declaration order</target>
        </segment>
      </unit>
      <unit id="7351" name="warn_sometimes_uninit_var">
        <segment>
          <source>variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2</source>
          <target>variable {$arg0} is {$arg1 :select s0=|used| s1=|captured|} uninitialized whenever %select{'{$arg3}' condition is {$arg4 :select s0=|true| s1=|false|}|'{$arg3}' loop {$arg4 :select s0=|is entered| s1=|exits because its condition is false|}|'{$arg3}' loop {$arg2 :select s0=|condition is true| s1=|exits because its condition is false}4| s2=|switch {$arg3} is taken| s3=|its declaration is reached| s4=|{$arg3} is called|}</target>
        </segment>
      </unit>
      <unit id="7352" name="warn_splice_in_doxygen_comment">
        <segment>
          <source>line splicing in Doxygen comments are not supported</source>
          <target>line splicing in Doxygen comments are not supported</target>
        </segment>
      </unit>
      <unit id="7353" name="warn_standalone_specifier">
        <segment>
          <source>'%0' ignored on this declaration</source>
          <target>'{$arg0}' ignored on this declaration</target>
        </segment>
      </unit>
      <unit id="7354" name="warn_static_array_too_small">
        <segment>
          <source>array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1</source>
          <target>array argument is too small; {$arg2 :select s0=|contains {$arg0} elements| s1=|is of size {$arg0}|}, callee requires at least {$arg1}</target>
        </segment>
      </unit>
      <unit id="7355" name="warn_static_local_in_extern_inline">
        <segment>
          <source>non-constant static local variable in inline function may be different in different files</source>
          <target>non-constant static local variable in inline function may be different in different files</target>
        </segment>
      </unit>
      <unit id="7356" name="warn_static_main">
        <segment>
          <source>'main' should not be declared static</source>
          <target>'main' should not be declared static</target>
        </segment>
      </unit>
      <unit id="7357" name="warn_static_self_reference_in_init">
        <segment>
          <source>static variable %0 is suspiciously used within its own initialization</source>
          <target>static variable {$arg0} is suspiciously used within its own initialization</target>
        </segment>
      </unit>
      <unit id="7358" name="warn_strict_multiple_method_decl">
        <segment>
          <source>multiple methods named %0 found</source>
          <target>multiple methods named {$arg0} found</target>
        </segment>
      </unit>
      <unit id="7359" name="warn_strict_potentially_direct_selector_expression">
        <segment>
          <source>@selector expression formed with potentially direct selector %0</source>
          <target>@selector expression formed with potentially direct selector {$arg0}</target>
        </segment>
      </unit>
      <unit id="7360" name="warn_strict_prototypes">
        <segment>
          <source>a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0</source>
          <target>a {$arg0 :select s0=|function| s1=|block|} declaration without a prototype is deprecated {$arg0 :select s0=|in all versions of C| s1=||}</target>
        </segment>
      </unit>
      <unit id="7361" name="warn_strict_uses_without_prototype">
        <segment>
          <source>passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23</source>
          <target>passing arguments to {$arg0 :select s0=|a function| s1=|{$arg1}|} without a prototype is deprecated in all versions of C and is not supported in C23</target>
        </segment>
      </unit>
      <unit id="7362" name="warn_string_plus_char">
        <segment>
          <source>adding %0 to a string pointer does not append to the string</source>
          <target>adding {$arg0} to a string pointer does not append to the string</target>
        </segment>
      </unit>
      <unit id="7363" name="warn_string_plus_int">
        <segment>
          <source>adding %0 to a string does not append to the string</source>
          <target>adding {$arg0} to a string does not append to the string</target>
        </segment>
      </unit>
      <unit id="7364" name="warn_stringcompare">
        <segment>
          <source>result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)</source>
          <target>result of comparison against {$arg0 :select s0=|a string literal| s1=|@encode|} is unspecified (use an explicit string comparison function instead)</target>
        </segment>
      </unit>
      <unit id="7365" name="warn_strlcpycat_wrong_size">
        <segment>
          <source>size argument in %0 call appears to be size of the source; expected the size of the destination</source>
          <target>size argument in {$arg0} call appears to be size of the source; expected the size of the destination</target>
        </segment>
      </unit>
      <unit id="7366" name="warn_strncat_large_size">
        <segment>
          <source>the value of the size argument in 'strncat' is too large, might lead to a buffer overflow</source>
          <target>the value of the size argument in 'strncat' is too large, might lead to a buffer overflow</target>
        </segment>
      </unit>
      <unit id="7367" name="warn_strncat_src_size">
        <segment>
          <source>size argument in 'strncat' call appears to be size of the source</source>
          <target>size argument in 'strncat' call appears to be size of the source</target>
        </segment>
      </unit>
      <unit id="7368" name="warn_strncat_wrong_size">
        <segment>
          <source>the value of the size argument to 'strncat' is wrong</source>
          <target>the value of the size argument to 'strncat' is wrong</target>
        </segment>
      </unit>
      <unit id="7369" name="warn_struct_class_previous_tag_mismatch">
        <segment>
          <source>%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI</source>
          <target>{$arg2} defined as {$arg0 :select s0=|a struct| s1=|an interface| s2=|a class|}{$arg1 :select s0=|| s1=| template|} here but previously declared as {$arg3 :select s0=|a struct| s1=|an interface| s2=|a class|}{$arg1 :select s0=|| s1=| template|}; this is valid, but may result in linker errors under the Microsoft C++ ABI</target>
        </segment>
      </unit>
      <unit id="7370" name="warn_struct_class_tag_mismatch">
        <segment>
          <source>%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI</source>
          <target>{$arg0 :select s0=|struct| s1=|interface| s2=|class|}{$arg1 :select s0=|| s1=| template|} {$arg2} was previously declared as a {$arg3 :select s0=|struct| s1=|interface| s2=|class|}{$arg1 :select s0=|| s1=| template|}; this is valid, but may result in linker errors under the Microsoft C++ ABI</target>
        </segment>
      </unit>
      <unit id="7371" name="warn_sub_ptr_zero_size_types">
        <segment>
          <source>subtraction of pointers to type %0 of zero size has undefined behavior</source>
          <target>subtraction of pointers to type {$arg0} of zero size has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7372" name="warn_subscript_is_char">
        <segment>
          <source>array subscript is of type 'char'</source>
          <target>array subscript is of type 'char'</target>
        </segment>
      </unit>
      <unit id="7373" name="warn_suggest_destructor_marked_not_override_overriding">
        <segment>
          <source>%0 overrides a destructor but is not marked 'override'</source>
          <target>{$arg0} overrides a destructor but is not marked 'override'</target>
        </segment>
      </unit>
      <unit id="7374" name="warn_suggest_function_marked_not_override_overriding">
        <segment>
          <source>%0 overrides a member function but is not marked 'override'</source>
          <target>{$arg0} overrides a member function but is not marked 'override'</target>
        </segment>
      </unit>
      <unit id="7375" name="warn_suggest_noreturn_block">
        <segment>
          <source>block could be declared with attribute 'noreturn'</source>
          <target>block could be declared with attribute 'noreturn'</target>
        </segment>
      </unit>
      <unit id="7376" name="warn_suggest_noreturn_function">
        <segment>
          <source>%select{function|method}0 %1 could be declared with attribute 'noreturn'</source>
          <target>{$arg0 :select s0=|function| s1=|method|} {$arg1} could be declared with attribute 'noreturn'</target>
        </segment>
      </unit>
      <unit id="7377" name="warn_superclass_variable_sized_type_not_at_end">
        <segment>
          <source>field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3</source>
          <target>field {$arg0} can overwrite instance variable {$arg1} with variable sized type {$arg2} in superclass {$arg3}</target>
        </segment>
      </unit>
      <unit id="7378" name="warn_suspicious_bzero_size">
        <segment>
          <source>'size' argument to bzero is '0'</source>
          <target>'size' argument to bzero is '0'</target>
        </segment>
      </unit>
      <unit id="7379" name="warn_suspicious_sizeof_memset">
        <segment>
          <source>%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?</source>
          <target>{$arg0 :select s0=|'size' argument to memset is '0'| s1=|setting buffer to a 'sizeof' expression|}; did you mean to transpose the last two arguments?</target>
        </segment>
      </unit>
      <unit id="7380" name="warn_switch_default">
        <segment>
          <source>'switch' missing 'default' label</source>
          <target>'switch' missing 'default' label</target>
        </segment>
      </unit>
      <unit id="7381" name="warn_sycl_entry_point_redundant_declaration">
        <segment>
          <source>redundant 'sycl_kernel_entry_point' attribute</source>
          <target>redundant 'sycl_kernel_entry_point' attribute</target>
        </segment>
      </unit>
      <unit id="7382" name="warn_sycl_kernel_invalid_template_param_type">
        <segment>
          <source>template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter</source>
          <target>template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter</target>
        </segment>
      </unit>
      <unit id="7383" name="warn_sycl_kernel_name_not_a_class_type">
        <segment>
          <source>%0 is not a valid SYCL kernel name type; a non-union class type is required</source>
          <target>{$arg0} is not a valid SYCL kernel name type; a non-union class type is required</target>
        </segment>
      </unit>
      <unit id="7384" name="warn_sycl_kernel_num_of_function_params">
        <segment>
          <source>function template with 'sycl_kernel' attribute must have a single parameter</source>
          <target>function template with 'sycl_kernel' attribute must have a single parameter</target>
        </segment>
      </unit>
      <unit id="7385" name="warn_sycl_kernel_num_of_template_params">
        <segment>
          <source>'sycl_kernel' attribute only applies to a function template with at least two template parameters</source>
          <target>'sycl_kernel' attribute only applies to a function template with at least two template parameters</target>
        </segment>
      </unit>
      <unit id="7386" name="warn_sycl_kernel_return_type">
        <segment>
          <source>function template with 'sycl_kernel' attribute must have a 'void' return type</source>
          <target>function template with 'sycl_kernel' attribute must have a 'void' return type</target>
        </segment>
      </unit>
      <unit id="7387" name="warn_sync_fetch_and_nand_semantics_change">
        <segment>
          <source>the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here</source>
          <target>the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here</target>
        </segment>
      </unit>
      <unit id="7388" name="warn_taking_address_of_packed_member">
        <segment>
          <source>taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value</source>
          <target>taking address of packed member {$arg0} of class or structure {$arg1 :q} may result in an unaligned pointer value</target>
        </segment>
      </unit>
      <unit id="7389" name="warn_target_clone_duplicate_options">
        <segment>
          <source>version list contains duplicate entries</source>
          <target>version list contains duplicate entries</target>
        </segment>
      </unit>
      <unit id="7390" name="warn_target_clone_mixed_values">
        <segment>
          <source>mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions</source>
          <target>mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions</target>
        </segment>
      </unit>
      <unit id="7391" name="warn_target_clone_no_impact_options">
        <segment>
          <source>version list contains entries that don't impact code generation</source>
          <target>version list contains entries that don't impact code generation</target>
        </segment>
      </unit>
      <unit id="7392" name="warn_tautological_bool_compare">
        <segment>
          <source>result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4</source>
          <target>result of comparison of {$arg1 :select s0=|constant {$arg0}| s1=|true| s2=|false|} with {$arg3 :select s0=|expression of type {$arg2}| s1=|boolean expression|} is always {$arg4}</target>
        </segment>
      </unit>
      <unit id="7393" name="warn_tautological_compare_objc_bool">
        <segment>
          <source>result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO</source>
          <target>result of comparison of constant {$arg0} with expression of type 'BOOL' is always {$arg1}, as the only well defined values for 'BOOL' are YES and NO</target>
        </segment>
      </unit>
      <unit id="7394" name="warn_tautological_compare_value_range">
        <segment>
          <source>result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5</source>
          <target>result of comparison of %select{{$arg4}|{$arg1}-bit {$arg0 :select s0=|signed| s1=|unsigned}2 value|} {$arg3} %select{{$arg1}-bit {$arg0 :select s0=|signed| s1=|unsigned}2 value| s2=|{$arg4}|} is always {$arg5}</target>
        </segment>
      </unit>
      <unit id="7395" name="warn_tautological_constant_compare">
        <segment>
          <source>result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4</source>
          <target>result of comparison {$arg0 :select s0=|{$arg3}| s1=|{$arg1}|} {$arg2} {$arg0 :select s0=|{$arg1}| s1=|{$arg3}|} is always {$arg4}</target>
        </segment>
      </unit>
      <unit id="7396" name="warn_tautological_negation_and_compare">
        <segment>
          <source>'&amp;&amp;' of a value and its negation always evaluates to false</source>
          <target>'&amp;&amp;' of a value and its negation always evaluates to false</target>
        </segment>
      </unit>
      <unit id="7397" name="warn_tautological_negation_or_compare">
        <segment>
          <source>'||' of a value and its negation always evaluates to true</source>
          <target>'||' of a value and its negation always evaluates to true</target>
        </segment>
      </unit>
      <unit id="7398" name="warn_tautological_overlap_comparison">
        <segment>
          <source state="initial">%select{non-|}0overlapping comparisons always evaluate to %select{false|true}0</source>
          <target>{$arg0 :select s0=|non-| s1=||}overlapping comparisons always evaluate to {$arg0 :select s0=|false| s1=|true|}</target>
        </segment>
      </unit>
      <unit id="7399" name="warn_tcb_enforcement_violation">
        <segment>
          <source>calling %0 is a violation of trusted computing base '%1'</source>
          <target>calling {$arg0} is a violation of trusted computing base '{$arg1}'</target>
        </segment>
      </unit>
      <unit id="7400" name="warn_template_arg_negative">
        <segment>
          <source>non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2</source>
          <target>non-type template argument with value '{$arg0}' converted to '{$arg1}' for unsigned template parameter of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="7401" name="warn_template_arg_too_large">
        <segment>
          <source>non-type template argument value '%0' truncated to '%1' for template parameter of type %2</source>
          <target>non-type template argument value '{$arg0}' truncated to '{$arg1}' for template parameter of type {$arg2}</target>
        </segment>
      </unit>
      <unit id="7402" name="warn_template_export_unsupported">
        <segment>
          <source>exported templates are unsupported</source>
          <target>exported templates are unsupported</target>
        </segment>
      </unit>
      <unit id="7403" name="warn_template_qualified_friend_ignored">
        <segment>
          <source state="initial">dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration</source>
          <target>dependent nested name specifier {$arg0} for friend template declaration is not supported; ignoring this friend declaration</target>
        </segment>
      </unit>
      <unit id="7404" name="warn_template_qualified_friend_unsupported">
        <segment>
          <source state="initial">dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1</source>
          <target>dependent nested name specifier {$arg0} for friend class declaration is not supported; turning off access control for {$arg1}</target>
        </segment>
      </unit>
      <unit id="7405" name="warn_tentative_incomplete_array">
        <segment>
          <source>tentative array definition assumed to have one element</source>
          <target>tentative array definition assumed to have one element</target>
        </segment>
      </unit>
      <unit id="7406" name="warn_this_bool_conversion">
        <segment>
          <source>'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true</source>
          <target>'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true</target>
        </segment>
      </unit>
      <unit id="7407" name="warn_this_null_compare">
        <segment>
          <source>'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0</source>
          <target>'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to {$arg0 :select s0=|true| s1=|false|}</target>
        </segment>
      </unit>
      <unit id="7408" name="warn_thread_attribute_argument_not_lockable">
        <segment>
          <source>%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1</source>
          <target>{$arg0} attribute requires arguments whose type is annotated with 'capability' attribute; type here is {$arg1}</target>
        </segment>
      </unit>
      <unit id="7409" name="warn_thread_attribute_decl_not_lockable">
        <segment>
          <source>%0 attribute can only be applied in a context annotated with 'capability' attribute</source>
          <target>{$arg0} attribute can only be applied in a context annotated with 'capability' attribute</target>
        </segment>
      </unit>
      <unit id="7410" name="warn_thread_attribute_decl_not_pointer">
        <segment>
          <source>%0 only applies to pointer types; type here is %1</source>
          <target>{$arg0} only applies to pointer types; type here is {$arg1}</target>
        </segment>
      </unit>
      <unit id="7411" name="warn_thread_attribute_ignored">
        <segment>
          <source>ignoring %0 attribute because its argument is invalid</source>
          <target>ignoring {$arg0} attribute because its argument is invalid</target>
        </segment>
      </unit>
      <unit id="7412" name="warn_thread_attribute_not_on_capability_member">
        <segment>
          <source>%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute</source>
          <target>{$arg0} attribute without capability arguments refers to 'this', but {$arg1} isn't annotated with 'capability' or 'scoped_lockable' attribute</target>
        </segment>
      </unit>
      <unit id="7413" name="warn_thread_attribute_not_on_non_static_member">
        <segment>
          <source>%0 attribute without capability arguments can only be applied to non-static methods of a class</source>
          <target>{$arg0} attribute without capability arguments can only be applied to non-static methods of a class</target>
        </segment>
      </unit>
      <unit id="7414" name="warn_thread_attribute_not_on_scoped_lockable_param">
        <segment>
          <source>%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type</source>
          <target>{$arg0} attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type</target>
        </segment>
      </unit>
      <unit id="7415" name="warn_thread_safety_beta">
        <segment>
          <source>thread safety beta warning</source>
          <target>thread safety beta warning</target>
        </segment>
      </unit>
      <unit id="7416" name="warn_thread_safety_verbose">
        <segment>
          <source>thread safety verbose warning</source>
          <target>thread safety verbose warning</target>
        </segment>
      </unit>
      <unit id="7417" name="warn_throw_in_noexcept_func">
        <segment>
          <source>%0 has a non-throwing exception specification but can still throw</source>
          <target>{$arg0} has a non-throwing exception specification but can still throw</target>
        </segment>
      </unit>
      <unit id="7418" name="warn_throw_underaligned_obj">
        <segment>
          <source>underaligned exception object thrown</source>
          <target>underaligned exception object thrown</target>
        </segment>
      </unit>
      <unit id="7419" name="warn_transparent_union_attribute_field_size_align">
        <segment>
          <source>%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored</source>
          <target>{$arg0 :select s0=|alignment| s1=|size|} of field {$arg1} ({$arg2} bits) does not match the {$arg0 :select s0=|alignment| s1=|size|} of the first field in transparent union; transparent_union attribute ignored</target>
        </segment>
      </unit>
      <unit id="7420" name="warn_transparent_union_attribute_floating">
        <segment>
          <source>first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored</source>
          <target>first field of a transparent union cannot have {$arg0 :select s0=|floating point| s1=|vector|} type {$arg1}; transparent_union attribute ignored</target>
        </segment>
      </unit>
      <unit id="7421" name="warn_transparent_union_attribute_not_definition">
        <segment>
          <source>transparent_union attribute can only be applied to a union definition; attribute ignored</source>
          <target>transparent_union attribute can only be applied to a union definition; attribute ignored</target>
        </segment>
      </unit>
      <unit id="7422" name="warn_transparent_union_attribute_zero_fields">
        <segment>
          <source>transparent union definition must contain at least one field; transparent_union attribute ignored</source>
          <target>transparent union definition must contain at least one field; transparent_union attribute ignored</target>
        </segment>
      </unit>
      <unit id="7423" name="warn_type_attribute_deprecated_on_decl">
        <segment>
          <source>applying attribute %0 to a declaration is deprecated; apply it to the type instead</source>
          <target>applying attribute {$arg0} to a declaration is deprecated; apply it to the type instead</target>
        </segment>
      </unit>
      <unit id="7424" name="warn_type_attribute_wrong_type">
        <segment>
          <source>'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2</source>
          <target>'{$arg0}' only applies to {$arg1 :select s0=|function| s1=|pointer| s2=|Objective-C object or block pointer|} types; type here is {$arg2}</target>
        </segment>
      </unit>
      <unit id="7425" name="warn_type_safety_null_pointer_required">
        <segment>
          <source>specified %0 type tag requires a null pointer</source>
          <target>specified {$arg0} type tag requires a null pointer</target>
        </segment>
      </unit>
      <unit id="7426" name="warn_type_safety_type_mismatch">
        <segment>
          <source>argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2</source>
          <target>argument type {$arg0} doesn't match specified {$arg1} type tag {$arg2 :select s0=|that requires {$arg3}| s1=||}</target>
        </segment>
      </unit>
      <unit id="7427" name="warn_type_tag_for_datatype_wrong_kind">
        <segment>
          <source>this type tag was not designed to be used with this function</source>
          <target>this type tag was not designed to be used with this function</target>
        </segment>
      </unit>
      <unit id="7428" name="warn_typecheck_convert_incompatible_function_pointer_strict">
        <segment>
          <source>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &amp;|; remove *|; remove &amp;}3</source>
          <target>incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2{$arg3 :select s0=|| s1=|; dereference with *| s2=|; take the address with &amp;| s3=|; remove *| s4=|; remove &amp;|}</target>
        </segment>
      </unit>
      <unit id="7429" name="warn_typecheck_function_qualifiers_ignored">
        <segment>
          <source>'%0' qualifier on function type %1 has no effect</source>
          <target>'{$arg0}' qualifier on function type {$arg1} has no effect</target>
        </segment>
      </unit>
      <unit id="7430" name="warn_typecheck_ordered_comparison_of_function_pointers">
        <segment>
          <source>ordered comparison of function pointers (%0 and %1)</source>
          <target>ordered comparison of function pointers ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="7431" name="warn_typecheck_reference_qualifiers">
        <segment>
          <source>'%0' qualifier on reference type %1 has no effect</source>
          <target>'{$arg0}' qualifier on reference type {$arg1} has no effect</target>
        </segment>
      </unit>
      <unit id="7432" name="warn_typecheck_vector_element_sizes_not_equal">
        <segment>
          <source>vector operands do not have the same elements sizes (%0 and %1)</source>
          <target>vector operands do not have the same elements sizes ({$arg0} and {$arg1})</target>
        </segment>
      </unit>
      <unit id="7433" name="warn_unannotated_fallthrough">
        <segment>
          <source>unannotated fall-through between switch labels</source>
          <target>unannotated fall-through between switch labels</target>
        </segment>
      </unit>
      <unit id="7434" name="warn_unannotated_fallthrough_per_function">
        <segment>
          <source>unannotated fall-through between switch labels in partly-annotated function</source>
          <target>unannotated fall-through between switch labels in partly-annotated function</target>
        </segment>
      </unit>
      <unit id="7435" name="warn_unavailable_def">
        <segment>
          <source>implementing unavailable method</source>
          <target>implementing unavailable method</target>
        </segment>
      </unit>
      <unit id="7436" name="warn_unavailable_fwdclass_message">
        <segment>
          <source>%0 may be unavailable because the receiver type is unknown</source>
          <target>{$arg0} may be unavailable because the receiver type is unknown</target>
        </segment>
      </unit>
      <unit id="7437" name="warn_undeclared_selector">
        <segment>
          <source>undeclared selector %0</source>
          <target>undeclared selector {$arg0}</target>
        </segment>
      </unit>
      <unit id="7438" name="warn_undeclared_selector_with_typo">
        <segment>
          <source>undeclared selector %0; did you mean %1?</source>
          <target>undeclared selector {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="7439" name="warn_undef_interface">
        <segment>
          <source>cannot find interface declaration for %0</source>
          <target>cannot find interface declaration for {$arg0}</target>
        </segment>
      </unit>
      <unit id="7440" name="warn_undef_interface_suggest">
        <segment>
          <source>cannot find interface declaration for %0; did you mean %1?</source>
          <target>cannot find interface declaration for {$arg0}; did you mean {$arg1}?</target>
        </segment>
      </unit>
      <unit id="7441" name="warn_undef_method_impl">
        <segment>
          <source>method definition for %0 not found</source>
          <target>method definition for {$arg0} not found</target>
        </segment>
      </unit>
      <unit id="7442" name="warn_undef_protocolref">
        <segment>
          <source>cannot find protocol definition for %0</source>
          <target>cannot find protocol definition for {$arg0}</target>
        </segment>
      </unit>
      <unit id="7443" name="warn_undefined_inline">
        <segment>
          <source>inline function %q0 is not defined</source>
          <target>inline function {$arg0 :q} is not defined</target>
        </segment>
      </unit>
      <unit id="7444" name="warn_undefined_internal">
        <segment>
          <source>%select{function|variable}0 %q1 has internal linkage but is not defined</source>
          <target>{$arg0 :select s0=|function| s1=|variable|} {$arg1 :q} has internal linkage but is not defined</target>
        </segment>
      </unit>
      <unit id="7445" name="warn_undefined_reinterpret_cast">
        <segment>
          <source>reinterpret_cast from %0 to %1 has undefined behavior</source>
          <target>reinterpret_cast from {$arg0} to {$arg1} has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7446" name="warn_unguarded_availability">
        <segment>
          <source>%0 is only available %select{|in %4 environment }3on %1 %2 or newer</source>
          <target>{$arg0} is only available {$arg3 :select s0=|| s1=|in {$arg4} environment |}on {$arg1} {$arg2} or newer</target>
        </segment>
      </unit>
      <unit id="7447" name="warn_unguarded_availability_new">
        <segment>
          <source>%0 is only available %select{|in %4 environment }3on %1 %2 or newer</source>
          <target>{$arg0} is only available {$arg3 :select s0=|| s1=|in {$arg4} environment |}on {$arg1} {$arg2} or newer</target>
        </segment>
      </unit>
      <unit id="7448" name="warn_unguarded_availability_unavailable">
        <segment>
          <source>%0 is unavailable</source>
          <target>{$arg0} is unavailable</target>
        </segment>
      </unit>
      <unit id="7449" name="warn_unguarded_availability_unavailable_new">
        <segment>
          <source>%0 is unavailable</source>
          <target>{$arg0} is unavailable</target>
        </segment>
      </unit>
      <unit id="7450" name="warn_unhandled_ms_attribute_ignored">
        <segment>
          <source>__declspec attribute %0 is not supported</source>
          <target>__declspec attribute {$arg0} is not supported</target>
        </segment>
      </unit>
      <unit id="7451" name="warn_unimplemented_protocol_method">
        <segment>
          <source>method %0 in protocol %1 not implemented</source>
          <target>method {$arg0} in protocol {$arg1} not implemented</target>
        </segment>
      </unit>
      <unit id="7452" name="warn_unimplemented_selector">
        <segment>
          <source>no method with selector %0 is implemented in this translation unit</source>
          <target>no method with selector {$arg0} is implemented in this translation unit</target>
        </segment>
      </unit>
      <unit id="7453" name="warn_uninit_byref_blockvar_captured_by_block">
        <segment>
          <source>block pointer variable %0 is %select{uninitialized|null}1 when captured by block</source>
          <target>block pointer variable {$arg0} is {$arg1 :select s0=|uninitialized| s1=|null|} when captured by block</target>
        </segment>
      </unit>
      <unit id="7454" name="warn_uninit_const_reference">
        <segment>
          <source>variable %0 is uninitialized when passed as a const reference argument here</source>
          <target>variable {$arg0} is uninitialized when passed as a const reference argument here</target>
        </segment>
      </unit>
      <unit id="7455" name="warn_uninit_self_reference_in_init">
        <segment>
          <source>variable %0 is uninitialized when used within its own initialization</source>
          <target>variable {$arg0} is uninitialized when used within its own initialization</target>
        </segment>
      </unit>
      <unit id="7456" name="warn_uninit_self_reference_in_reference_init">
        <segment>
          <source>reference %0 is not yet bound to a value when used within its own initialization</source>
          <target>reference {$arg0} is not yet bound to a value when used within its own initialization</target>
        </segment>
      </unit>
      <unit id="7457" name="warn_uninit_var">
        <segment>
          <source>variable %0 is uninitialized when %select{used here|captured by block}1</source>
          <target>variable {$arg0} is uninitialized when {$arg1 :select s0=|used here| s1=|captured by block|}</target>
        </segment>
      </unit>
      <unit id="7458" name="warn_unknown_sanitizer_ignored">
        <segment>
          <source>unknown sanitizer '%0' ignored</source>
          <target>unknown sanitizer '{$arg0}' ignored</target>
        </segment>
      </unit>
      <unit id="7459" name="warn_unlock_but_no_lock">
        <segment>
          <source>releasing %0 '%1' that was not held</source>
          <target>releasing {$arg0} '{$arg1}' that was not held</target>
        </segment>
      </unit>
      <unit id="7460" name="warn_unlock_kind_mismatch">
        <segment>
          <source>releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access</source>
          <target>releasing {$arg0} '{$arg1}' using {$arg2 :select s0=|shared| s1=|exclusive|} access, expected {$arg3 :select s0=|shared| s1=|exclusive|} access</target>
        </segment>
      </unit>
      <unit id="7461" name="warn_unmatched_underlying_mutexes">
        <segment>
          <source>%0 managed by '%1' is '%3' instead of '%2'</source>
          <target>{$arg0} managed by '{$arg1}' is '{$arg3}' instead of '{$arg2}'</target>
        </segment>
      </unit>
      <unit id="7462" name="warn_unnecessary_virtual_specifier">
        <segment>
          <source>virtual method %0 is inside a 'final' class and can never be overridden</source>
          <target>virtual method {$arg0} is inside a 'final' class and can never be overridden</target>
        </segment>
      </unit>
      <unit id="7463" name="warn_unneeded_internal_decl">
        <segment>
          <source>%select{function|variable}0 %1 is not needed and will not be emitted</source>
          <target>{$arg0 :select s0=|function| s1=|variable|} {$arg1} is not needed and will not be emitted</target>
        </segment>
      </unit>
      <unit id="7464" name="warn_unneeded_member_function">
        <segment>
          <source>member function %0 is not needed and will not be emitted</source>
          <target>member function {$arg0} is not needed and will not be emitted</target>
        </segment>
      </unit>
      <unit id="7465" name="warn_unneeded_static_internal_decl">
        <segment>
          <source>'static' function %0 declared in header file should be declared 'static inline'</source>
          <target>'static' function {$arg0} declared in header file should be declared 'static inline'</target>
        </segment>
      </unit>
      <unit id="7466" name="warn_unqualified_call_to_std_cast_function">
        <segment>
          <source>unqualified call to '%0'</source>
          <target>unqualified call to '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="7467" name="warn_unreachable">
        <segment>
          <source>code will never be executed</source>
          <target>code will never be executed</target>
        </segment>
      </unit>
      <unit id="7468" name="warn_unreachable_association">
        <segment>
          <source>due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1</source>
          <target>due to lvalue conversion of the controlling expression, association of type {$arg0} will never be selected because it is {$arg1 :select s0=|of array type| s1=|qualified|}</target>
        </segment>
      </unit>
      <unit id="7469" name="warn_unreachable_break">
        <segment>
          <source>'break' will never be executed</source>
          <target>'break' will never be executed</target>
        </segment>
      </unit>
      <unit id="7470" name="warn_unreachable_default">
        <segment>
          <source>default label in switch which covers all enumeration values</source>
          <target>default label in switch which covers all enumeration values</target>
        </segment>
      </unit>
      <unit id="7471" name="warn_unreachable_fallthrough_attr">
        <segment>
          <source>fallthrough annotation in unreachable code</source>
          <target>fallthrough annotation in unreachable code</target>
        </segment>
      </unit>
      <unit id="7472" name="warn_unreachable_loop_increment">
        <segment>
          <source>loop will run at most once (loop increment never executed)</source>
          <target>loop will run at most once (loop increment never executed)</target>
        </segment>
      </unit>
      <unit id="7473" name="warn_unreachable_return">
        <segment>
          <source>'return' will never be executed</source>
          <target>'return' will never be executed</target>
        </segment>
      </unit>
      <unit id="7474" name="warn_unsafe_buffer_libc_call">
        <segment>
          <source>function %0 is unsafe</source>
          <target>function {$arg0} is unsafe</target>
        </segment>
      </unit>
      <unit id="7475" name="warn_unsafe_buffer_operation">
        <segment>
          <source state="initial">%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0</source>
          <target>{$arg0 :select s0=|unsafe pointer operation| s1=|unsafe pointer arithmetic| s2=|unsafe buffer access| s3=|function introduces unsafe buffer manipulation| s4=|unsafe invocation of {$arg1}| s5=|field {$arg1} prone to unsafe buffer manipulation|}</target>
        </segment>
      </unit>
      <unit id="7476" name="warn_unsafe_buffer_usage_in_container">
        <segment>
          <source>the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information</source>
          <target>the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information</target>
        </segment>
      </unit>
      <unit id="7477" name="warn_unsafe_buffer_variable">
        <segment>
          <source>%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1</source>
          <target>{$arg0} is an {$arg1 :select s0=|unsafe pointer used for buffer access| s1=|unsafe buffer that does not perform bounds checks|}</target>
        </segment>
      </unit>
      <unit id="7478" name="warn_unsequenced_mod_mod">
        <segment>
          <source>multiple unsequenced modifications to %0</source>
          <target>multiple unsequenced modifications to {$arg0}</target>
        </segment>
      </unit>
      <unit id="7479" name="warn_unsequenced_mod_use">
        <segment>
          <source>unsequenced modification and access to %0</source>
          <target>unsequenced modification and access to {$arg0}</target>
        </segment>
      </unit>
      <unit id="7480" name="warn_unsigned_abs">
        <segment>
          <source>taking the absolute value of unsigned type %0 has no effect</source>
          <target>taking the absolute value of unsigned type {$arg0} has no effect</target>
        </segment>
      </unit>
      <unit id="7481" name="warn_unsigned_always_true_comparison">
        <segment>
          <source>result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4</source>
          <target>result of comparison of {$arg0 :select s0=|{$arg3}| s1=|unsigned expression|} {$arg2} {$arg0 :select s0=|unsigned expression| s1=|{$arg3}|} is always {$arg4}</target>
        </segment>
      </unit>
      <unit id="7482" name="warn_unsigned_bitfield_assigned_signed_enum">
        <segment>
          <source>assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values</source>
          <target>assigning value of signed enum type {$arg1} to unsigned bit-field {$arg0}; negative enumerators of enum {$arg1} will be converted to positive values</target>
        </segment>
      </unit>
      <unit id="7483" name="warn_unsigned_char_always_true_comparison">
        <segment>
          <source>result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned</source>
          <target>result of comparison of {$arg0 :select s0=|{$arg3}| s1=|char expression|} {$arg2} {$arg0 :select s0=|char expression| s1=|{$arg3}|} is always {$arg4}, since char is interpreted as unsigned</target>
        </segment>
      </unit>
      <unit id="7484" name="warn_unsigned_enum_always_true_comparison">
        <segment>
          <source>result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4</source>
          <target>result of comparison of {$arg0 :select s0=|{$arg3}| s1=|unsigned enum expression|} {$arg2} {$arg0 :select s0=|unsigned enum expression| s1=|{$arg3}|} is always {$arg4}</target>
        </segment>
      </unit>
      <unit id="7485" name="warn_unsupported_branch_protection_spec">
        <segment>
          <source>unsupported branch protection specification '%0'</source>
          <target>unsupported branch protection specification '{$arg0}'</target>
        </segment>
      </unit>
      <unit id="7486" name="warn_unsupported_target_attribute">
        <segment>
          <source>%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored</source>
          <target>{$arg0 :select s0=|unsupported| s1=|duplicate| s2=|unknown|}{$arg1 :select s0=|| s1=| CPU| s2=| tune CPU|} '{$arg2}' in the '{$arg3 :select s0=|target| s1=|target_clones| s2=|target_version|}' attribute string; '{$arg3 :select s0=|target| s1=|target_clones| s2=|target_version|}' attribute ignored</target>
        </segment>
      </unit>
      <unit id="7487" name="warn_unused_but_set_parameter">
        <segment>
          <source>parameter %0 set but not used</source>
          <target>parameter {$arg0} set but not used</target>
        </segment>
      </unit>
      <unit id="7488" name="warn_unused_but_set_variable">
        <segment>
          <source>variable %0 set but not used</source>
          <target>variable {$arg0} set but not used</target>
        </segment>
      </unit>
      <unit id="7489" name="warn_unused_call">
        <segment>
          <source>ignoring return value of function declared with %0 attribute</source>
          <target>ignoring return value of function declared with {$arg0} attribute</target>
        </segment>
      </unit>
      <unit id="7490" name="warn_unused_comma_left_operand">
        <segment>
          <source>left operand of comma operator has no effect</source>
          <target>left operand of comma operator has no effect</target>
        </segment>
      </unit>
      <unit id="7491" name="warn_unused_comparison">
        <segment>
          <source>%select{equality|inequality|relational|three-way}0 comparison result unused</source>
          <target>{$arg0 :select s0=|equality| s1=|inequality| s2=|relational| s3=|three-way|} comparison result unused</target>
        </segment>
      </unit>
      <unit id="7492" name="warn_unused_const_variable">
        <segment>
          <source>unused variable %0</source>
          <target>unused variable {$arg0}</target>
        </segment>
      </unit>
      <unit id="7493" name="warn_unused_constructor">
        <segment>
          <source state="initial">ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1</source>
          <target>ignoring temporary created by a constructor declared with {$arg0} attribute{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="7494" name="warn_unused_container_subscript_expr">
        <segment>
          <source>container access result unused - container access should not be used for side effects</source>
          <target>container access result unused - container access should not be used for side effects</target>
        </segment>
      </unit>
      <unit id="7495" name="warn_unused_exception_param">
        <segment>
          <source>unused exception parameter %0</source>
          <target>unused exception parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="7496" name="warn_unused_expr">
        <segment>
          <source>expression result unused</source>
          <target>expression result unused</target>
        </segment>
      </unit>
      <unit id="7497" name="warn_unused_function">
        <segment>
          <source>unused function %0</source>
          <target>unused function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7498" name="warn_unused_label">
        <segment>
          <source>unused label %0</source>
          <target>unused label {$arg0}</target>
        </segment>
      </unit>
      <unit id="7499" name="warn_unused_lambda_capture">
        <segment>
          <source>lambda capture %0 is not %select{used|required to be captured for this use}1</source>
          <target>lambda capture {$arg0} is not {$arg1 :select s0=|used| s1=|required to be captured for this use|}</target>
        </segment>
      </unit>
      <unit id="7500" name="warn_unused_local_typedef">
        <segment>
          <source>unused %select{typedef|type alias}0 %1</source>
          <target>unused {$arg0 :select s0=|typedef| s1=|type alias|} {$arg1}</target>
        </segment>
      </unit>
      <unit id="7501" name="warn_unused_member_function">
        <segment>
          <source>unused member function %0</source>
          <target>unused member function {$arg0}</target>
        </segment>
      </unit>
      <unit id="7502" name="warn_unused_parameter">
        <segment>
          <source>unused parameter %0</source>
          <target>unused parameter {$arg0}</target>
        </segment>
      </unit>
      <unit id="7503" name="warn_unused_private_field">
        <segment>
          <source>private field %0 is not used</source>
          <target>private field {$arg0} is not used</target>
        </segment>
      </unit>
      <unit id="7504" name="warn_unused_property_backing_ivar">
        <segment>
          <source>ivar %0 which backs the property is not referenced in this property's accessor</source>
          <target>ivar {$arg0} which backs the property is not referenced in this property's accessor</target>
        </segment>
      </unit>
      <unit id="7505" name="warn_unused_property_expr">
        <segment>
          <source>property access result unused - getters should not be used for side effects</source>
          <target>property access result unused - getters should not be used for side effects</target>
        </segment>
      </unit>
      <unit id="7506" name="warn_unused_result">
        <segment>
          <source state="initial">ignoring return value of function declared with %0 attribute%select{|: %2}1</source>
          <target>ignoring return value of function declared with {$arg0} attribute{$arg1 :select s0=|| s1=|: {$arg2}|}</target>
        </segment>
      </unit>
      <unit id="7507" name="warn_unused_result_typedef_unsupported_spelling">
        <segment>
          <source>'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead</source>
          <target>'[[{$arg0 :select s0=|nodiscard| s1=|gnu::warn_unused_result|}]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead</target>
        </segment>
      </unit>
      <unit id="7508" name="warn_unused_return_type">
        <segment>
          <source>ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3</source>
          <target>ignoring {$arg0 :select s0=|return value| s1=|temporary|} of type {$arg2} declared with {$arg1} attribute{$arg3 :select s0=|| s1=|: {$arg4}|}</target>
        </segment>
      </unit>
      <unit id="7509" name="warn_unused_template">
        <segment>
          <source>unused %select{function|variable}0 template %1</source>
          <target>unused {$arg0 :select s0=|function| s1=|variable|} template {$arg1}</target>
        </segment>
      </unit>
      <unit id="7510" name="warn_unused_variable">
        <segment>
          <source>unused variable %0</source>
          <target>unused variable {$arg0}</target>
        </segment>
      </unit>
      <unit id="7511" name="warn_unused_voidptr">
        <segment>
          <source>expression result unused; should this cast be to 'void'?</source>
          <target>expression result unused; should this cast be to 'void'?</target>
        </segment>
      </unit>
      <unit id="7512" name="warn_unused_volatile">
        <segment>
          <source>expression result unused; assign into a variable to force a volatile load</source>
          <target>expression result unused; assign into a variable to force a volatile load</target>
        </segment>
      </unit>
      <unit id="7513" name="warn_use_in_invalid_state">
        <segment>
          <source>invalid invocation of method '%0' on object '%1' while it is in the '%2' state</source>
          <target>invalid invocation of method '{$arg0}' on object '{$arg1}' while it is in the '{$arg2}' state</target>
        </segment>
      </unit>
      <unit id="7514" name="warn_use_of_temp_in_invalid_state">
        <segment>
          <source>invalid invocation of method '%0' on a temporary object while it is in the '%1' state</source>
          <target>invalid invocation of method '{$arg0}' on a temporary object while it is in the '{$arg1}' state</target>
        </segment>
      </unit>
      <unit id="7515" name="warn_used_but_marked_unused">
        <segment>
          <source>%0 was marked unused but was used</source>
          <target>{$arg0} was marked unused but was used</target>
        </segment>
      </unit>
      <unit id="7516" name="warn_user_defined_msg_constexpr">
        <segment>
          <source>%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression</source>
          <target>{$arg0 :select s0=|the message| s1=|the expression|} in {$arg0 :select s0=|this static assertion| s1=|this asm operand|} is not a constant expression</target>
        </segment>
      </unit>
      <unit id="7517" name="warn_user_literal_reserved">
        <segment>
          <source>user-defined literal suffixes %select{&lt;ERROR&gt;|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1</source>
          <target>user-defined literal suffixes {$arg0 :select s0=|&lt;ERROR&gt;| s1=|not starting with '_'| s2=|containing '__'|} are reserved{$arg1 :select s0=|; no literal will invoke this operator| s1=||}</target>
        </segment>
      </unit>
      <unit id="7518" name="warn_using_directive_in_header">
        <segment>
          <source>using namespace directive in global context in header</source>
          <target>using namespace directive in global context in header</target>
        </segment>
      </unit>
      <unit id="7519" name="warn_va_start_type_is_undefined">
        <segment>
          <source>passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior</source>
          <target>passing {$arg0 :select s0=|an object that undergoes default argument promotion| s1=|an object of reference type| s2=|a parameter declared with the 'register' keyword|} to 'va_start' has undefined behavior</target>
        </segment>
      </unit>
      <unit id="7520" name="warn_var_decl_not_read_only">
        <segment>
          <source>object of type %0 cannot be placed in read-only memory</source>
          <target>object of type {$arg0} cannot be placed in read-only memory</target>
        </segment>
      </unit>
      <unit id="7521" name="warn_var_deref_requires_any_lock">
        <segment>
          <source>%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1</source>
          <target>{$arg1 :select s0=|reading| s1=|writing|} the value pointed to by {$arg0} requires holding {$arg1 :select s0=|any mutex| s1=|any mutex exclusively|}</target>
        </segment>
      </unit>
      <unit id="7522" name="warn_var_deref_requires_lock">
        <segment>
          <source>%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>{$arg3 :select s0=|reading| s1=|writing|} the value pointed to by {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7523" name="warn_var_deref_requires_lock_precise">
        <segment>
          <source>%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>{$arg3 :select s0=|reading| s1=|writing|} the value pointed to by {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7524" name="warn_var_template_missing">
        <segment>
          <source>instantiation of variable %q0 required here, but no definition is available</source>
          <target>instantiation of variable {$arg0 :q} required here, but no definition is available</target>
        </segment>
      </unit>
      <unit id="7525" name="warn_variable_requires_any_lock">
        <segment>
          <source>%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1</source>
          <target>{$arg1 :select s0=|reading| s1=|writing|} variable {$arg0} requires holding {$arg1 :select s0=|any mutex| s1=|any mutex exclusively|}</target>
        </segment>
      </unit>
      <unit id="7526" name="warn_variable_requires_lock">
        <segment>
          <source>%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>{$arg3 :select s0=|reading| s1=|writing|} variable {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7527" name="warn_variable_requires_lock_precise">
        <segment>
          <source>%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3</source>
          <target>{$arg3 :select s0=|reading| s1=|writing|} variable {$arg1} requires holding {$arg0} {$arg3 :select s0=|'{$arg2}'| s1=|'{$arg2}' exclusively|}</target>
        </segment>
      </unit>
      <unit id="7528" name="warn_variable_sized_ivar_visibility">
        <segment>
          <source>field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables</source>
          <target>field {$arg0} with variable sized type {$arg1} is not visible to subclasses and can conflict with their instance variables</target>
        </segment>
      </unit>
      <unit id="7529" name="warn_variables_not_in_loop_body">
        <segment>
          <source>variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body</source>
          <target>variable{$arg0 :select s0=|s| s1=| {$arg1}| s2=|s {$arg1} and {$arg2}| s3=|s {$arg1}, {$arg2}, and {$arg3}| s4=|s {$arg1}, {$arg2}, {$arg3}, and {$arg4}|} used in loop condition not modified in loop body</target>
        </segment>
      </unit>
      <unit id="7530" name="warn_vbase_moved_multiple_times">
        <segment>
          <source>defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times</source>
          <target>defaulted move assignment operator of {$arg0} will move assign virtual base class {$arg1} multiple times</target>
        </segment>
      </unit>
      <unit id="7531" name="warn_vector_long_decl_spec_combination">
        <segment>
          <source>use of 'long' with '__vector' is deprecated</source>
          <target>use of 'long' with '__vector' is deprecated</target>
        </segment>
      </unit>
      <unit id="7532" name="warn_vector_mode_deprecated">
        <segment>
          <source>specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead</source>
          <target>specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead</target>
        </segment>
      </unit>
      <unit id="7533" name="warn_vla_used">
        <segment>
          <source>variable length array used</source>
          <target>variable length array used</target>
        </segment>
      </unit>
      <unit id="7534" name="warn_void_pointer_to_enum_cast">
        <segment>
          <source>cast to smaller integer type %1 from %0</source>
          <target>cast to smaller integer type {$arg1} from {$arg0}</target>
        </segment>
      </unit>
      <unit id="7535" name="warn_void_pointer_to_int_cast">
        <segment>
          <source>cast to smaller integer type %1 from %0</source>
          <target>cast to smaller integer type {$arg1} from {$arg0}</target>
        </segment>
      </unit>
      <unit id="7536" name="warn_wasm_dynamic_exception_spec_ignored">
        <segment>
          <source>dynamic exception specifications with types are currently ignored in wasm</source>
          <target>dynamic exception specifications with types are currently ignored in wasm</target>
        </segment>
      </unit>
      <unit id="7537" name="warn_weak_identifier_undeclared">
        <segment>
          <source>weak identifier %0 never declared</source>
          <target>weak identifier {$arg0} never declared</target>
        </segment>
      </unit>
      <unit id="7538" name="warn_weak_import">
        <segment>
          <source>%0 cannot be declared 'weak_import' because its definition has been provided</source>
          <target>{$arg0} cannot be declared 'weak_import' because its definition has been provided</target>
        </segment>
      </unit>
      <unit id="7539" name="warn_weak_template_vtable">
        <segment>
          <source>this warning is no longer in use and will be removed in the next release</source>
          <target>this warning is no longer in use and will be removed in the next release</target>
        </segment>
      </unit>
      <unit id="7540" name="warn_weak_vtable">
        <segment>
          <source>%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit</source>
          <target>{$arg0} has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit</target>
        </segment>
      </unit>
      <unit id="7541" name="warn_wrong_absolute_value_type">
        <segment>
          <source>using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type</source>
          <target>using {$arg1 :select s0=|integer| s1=|floating point| s2=|complex|} absolute value function {$arg0} when argument is of {$arg2 :select s0=|integer| s1=|floating point| s2=|complex|} type</target>
        </segment>
      </unit>
      <unit id="7542" name="warn_xor_used_as_pow">
        <segment>
          <source>result of '%0' is %1; did you mean exponentiation?</source>
          <target>result of '{$arg0}' is {$arg1}; did you mean exponentiation?</target>
        </segment>
      </unit>
      <unit id="7543" name="warn_xor_used_as_pow_base">
        <segment>
          <source>result of '%0' is %1; did you mean '%2'?</source>
          <target>result of '{$arg0}' is {$arg1}; did you mean '{$arg2}'?</target>
        </segment>
      </unit>
      <unit id="7544" name="warn_xor_used_as_pow_base_extra">
        <segment>
          <source>result of '%0' is %1; did you mean '%2' (%3)?</source>
          <target>result of '{$arg0}' is {$arg1}; did you mean '{$arg2}' ({$arg3})?</target>
        </segment>
      </unit>
      <unit id="7545" name="warn_zero_as_null_pointer_constant">
        <segment>
          <source>zero as null pointer constant</source>
          <target>zero as null pointer constant</target>
        </segment>
      </unit>
      <unit id="7546" name="warn_zero_size_struct_union_compat">
        <segment>
          <source>%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++</source>
          <target>{$arg0 :select s0=|| s1=|empty |}{$arg1 :select s0=|struct| s1=|union|} has size 0 in C, {$arg2 :select s0=|size 1| s1=|non-zero size|} in C++</target>
        </segment>
      </unit>
      <unit id="7547" name="warn_zero_size_struct_union_in_extern_c">
        <segment>
          <source>%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++</source>
          <target>{$arg0 :select s0=|| s1=|empty |}{$arg1 :select s0=|struct| s1=|union|} has size 0 in C, {$arg2 :select s0=|size 1| s1=|non-zero size|} in C++</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>